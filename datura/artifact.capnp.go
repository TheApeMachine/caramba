// Code generated by capnpc-go. DO NOT EDIT.

package datura

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Artifact capnp.Struct

// Artifact_TypeID is the unique identifier for the type Artifact.
const Artifact_TypeID = 0xb1092b0e00ae75e5

func NewArtifact(s *capnp.Segment) (Artifact, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 11})
	return Artifact(st), err
}

func NewRootArtifact(s *capnp.Segment) (Artifact, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 11})
	return Artifact(st), err
}

func ReadRootArtifact(msg *capnp.Message) (Artifact, error) {
	root, err := msg.Root()
	return Artifact(root.Struct()), err
}

func (s Artifact) String() string {
	str, _ := text.Marshal(0xb1092b0e00ae75e5, capnp.Struct(s))
	return str
}

func (s Artifact) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Artifact) DecodeFromPtr(p capnp.Ptr) Artifact {
	return Artifact(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Artifact) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Artifact) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact) Uuid() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Artifact) HasUuid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Artifact) SetUuid(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Artifact) Checksum() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Artifact) HasChecksum() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact) SetChecksum(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Artifact) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Artifact) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Artifact) Mediatype() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s Artifact) HasMediatype() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Artifact) MediatypeBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s Artifact) SetMediatype(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s Artifact) Role() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s Artifact) SetRole(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

func (s Artifact) Scope() uint32 {
	return capnp.Struct(s).Uint32(12)
}

func (s Artifact) SetScope(v uint32) {
	capnp.Struct(s).SetUint32(12, v)
}

func (s Artifact) PseudonymHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Artifact) HasPseudonymHash() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Artifact) SetPseudonymHash(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s Artifact) MerkleRoot() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return []byte(p.Data()), err
}

func (s Artifact) HasMerkleRoot() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Artifact) SetMerkleRoot(v []byte) error {
	return capnp.Struct(s).SetData(4, v)
}

func (s Artifact) Metadata() (Artifact_Metadata_List, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return Artifact_Metadata_List(p.List()), err
}

func (s Artifact) HasMetadata() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Artifact) SetMetadata(v Artifact_Metadata_List) error {
	return capnp.Struct(s).SetPtr(5, v.ToPtr())
}

// NewMetadata sets the metadata field to a newly
// allocated Artifact_Metadata_List, preferring placement in s's segment.
func (s Artifact) NewMetadata(n int32) (Artifact_Metadata_List, error) {
	l, err := NewArtifact_Metadata_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Artifact_Metadata_List{}, err
	}
	err = capnp.Struct(s).SetPtr(5, l.ToPtr())
	return l, err
}
func (s Artifact) EncryptedPayload() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return []byte(p.Data()), err
}

func (s Artifact) HasEncryptedPayload() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Artifact) SetEncryptedPayload(v []byte) error {
	return capnp.Struct(s).SetData(6, v)
}

func (s Artifact) EncryptedKey() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(7)
	return []byte(p.Data()), err
}

func (s Artifact) HasEncryptedKey() bool {
	return capnp.Struct(s).HasPtr(7)
}

func (s Artifact) SetEncryptedKey(v []byte) error {
	return capnp.Struct(s).SetData(7, v)
}

func (s Artifact) EphemeralPublicKey() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(8)
	return []byte(p.Data()), err
}

func (s Artifact) HasEphemeralPublicKey() bool {
	return capnp.Struct(s).HasPtr(8)
}

func (s Artifact) SetEphemeralPublicKey(v []byte) error {
	return capnp.Struct(s).SetData(8, v)
}

func (s Artifact) Approvals() (Artifact_Approval_List, error) {
	p, err := capnp.Struct(s).Ptr(9)
	return Artifact_Approval_List(p.List()), err
}

func (s Artifact) HasApprovals() bool {
	return capnp.Struct(s).HasPtr(9)
}

func (s Artifact) SetApprovals(v Artifact_Approval_List) error {
	return capnp.Struct(s).SetPtr(9, v.ToPtr())
}

// NewApprovals sets the approvals field to a newly
// allocated Artifact_Approval_List, preferring placement in s's segment.
func (s Artifact) NewApprovals(n int32) (Artifact_Approval_List, error) {
	l, err := NewArtifact_Approval_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Artifact_Approval_List{}, err
	}
	err = capnp.Struct(s).SetPtr(9, l.ToPtr())
	return l, err
}
func (s Artifact) Signature() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(10)
	return []byte(p.Data()), err
}

func (s Artifact) HasSignature() bool {
	return capnp.Struct(s).HasPtr(10)
}

func (s Artifact) SetSignature(v []byte) error {
	return capnp.Struct(s).SetData(10, v)
}

// Artifact_List is a list of Artifact.
type Artifact_List = capnp.StructList[Artifact]

// NewArtifact creates a new list of Artifact.
func NewArtifact_List(s *capnp.Segment, sz int32) (Artifact_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 11}, sz)
	return capnp.StructList[Artifact](l), err
}

// Artifact_Future is a wrapper for a Artifact promised by a client call.
type Artifact_Future struct{ *capnp.Future }

func (f Artifact_Future) Struct() (Artifact, error) {
	p, err := f.Future.Ptr()
	return Artifact(p.Struct()), err
}

type Artifact_Metadata capnp.Struct

// Artifact_Metadata_TypeID is the unique identifier for the type Artifact_Metadata.
const Artifact_Metadata_TypeID = 0xc121b65fcd3a05ee

func NewArtifact_Metadata(s *capnp.Segment) (Artifact_Metadata, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Artifact_Metadata(st), err
}

func NewRootArtifact_Metadata(s *capnp.Segment) (Artifact_Metadata, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Artifact_Metadata(st), err
}

func ReadRootArtifact_Metadata(msg *capnp.Message) (Artifact_Metadata, error) {
	root, err := msg.Root()
	return Artifact_Metadata(root.Struct()), err
}

func (s Artifact_Metadata) String() string {
	str, _ := text.Marshal(0xc121b65fcd3a05ee, capnp.Struct(s))
	return str
}

func (s Artifact_Metadata) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Artifact_Metadata) DecodeFromPtr(p capnp.Ptr) Artifact_Metadata {
	return Artifact_Metadata(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Artifact_Metadata) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Artifact_Metadata) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact_Metadata) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact_Metadata) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact_Metadata) Key() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Artifact_Metadata) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Artifact_Metadata) KeyBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Artifact_Metadata) SetKey(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Artifact_Metadata) Value() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Artifact_Metadata) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact_Metadata) ValueBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Artifact_Metadata) SetValue(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Artifact_Metadata_List is a list of Artifact_Metadata.
type Artifact_Metadata_List = capnp.StructList[Artifact_Metadata]

// NewArtifact_Metadata creates a new list of Artifact_Metadata.
func NewArtifact_Metadata_List(s *capnp.Segment, sz int32) (Artifact_Metadata_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Artifact_Metadata](l), err
}

// Artifact_Metadata_Future is a wrapper for a Artifact_Metadata promised by a client call.
type Artifact_Metadata_Future struct{ *capnp.Future }

func (f Artifact_Metadata_Future) Struct() (Artifact_Metadata, error) {
	p, err := f.Future.Ptr()
	return Artifact_Metadata(p.Struct()), err
}

type Artifact_Approval capnp.Struct

// Artifact_Approval_TypeID is the unique identifier for the type Artifact_Approval.
const Artifact_Approval_TypeID = 0x8cc20228b0f1020d

func NewArtifact_Approval(s *capnp.Segment) (Artifact_Approval, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Artifact_Approval(st), err
}

func NewRootArtifact_Approval(s *capnp.Segment) (Artifact_Approval, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Artifact_Approval(st), err
}

func ReadRootArtifact_Approval(msg *capnp.Message) (Artifact_Approval, error) {
	root, err := msg.Root()
	return Artifact_Approval(root.Struct()), err
}

func (s Artifact_Approval) String() string {
	str, _ := text.Marshal(0x8cc20228b0f1020d, capnp.Struct(s))
	return str
}

func (s Artifact_Approval) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Artifact_Approval) DecodeFromPtr(p capnp.Ptr) Artifact_Approval {
	return Artifact_Approval(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Artifact_Approval) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Artifact_Approval) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact_Approval) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact_Approval) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact_Approval) ZkProof() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Artifact_Approval) HasZkProof() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Artifact_Approval) SetZkProof(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Artifact_Approval) OperatorBlindSignature() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Artifact_Approval) HasOperatorBlindSignature() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact_Approval) SetOperatorBlindSignature(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// Artifact_Approval_List is a list of Artifact_Approval.
type Artifact_Approval_List = capnp.StructList[Artifact_Approval]

// NewArtifact_Approval creates a new list of Artifact_Approval.
func NewArtifact_Approval_List(s *capnp.Segment, sz int32) (Artifact_Approval_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Artifact_Approval](l), err
}

// Artifact_Approval_Future is a wrapper for a Artifact_Approval promised by a client call.
type Artifact_Approval_Future struct{ *capnp.Future }

func (f Artifact_Approval_Future) Struct() (Artifact_Approval, error) {
	p, err := f.Future.Ptr()
	return Artifact_Approval(p.Struct()), err
}

const schema_85d3acc39d94e0f8 = "x\xdat\xd3Ah+E\x18\x07\xf0\xff\x7f6\x9bl" +
	"\xda\xe4\xd50\x8b^\x94\xa0\x08\xbe\xa7T\xeb{\x0a\xf2" +
	"\x10\x9e\x0d\x08\xd2\x87\x90\xed\xde\xbc\xc8\x98\x9d\xd7\xae\xd9" +
	"d\x97\xcdnKD\xd1\x83\x05\x91\x0a=T\xb0\xd2\x82" +
	"\x07\x05\x0fU\xeaA\x0f\xdeT\x84^\x04E/B\x0f" +
	"\x1e,x\x12<)\xa2\xacL4\x9bP\xf58\xbf\xf9" +
	"f\xe6\x9bo\xbeY\xd9\xe7\x13\x95\x87\x9b\xb1\x80\xf0\xee" +
	"\xb4\xabES\xfcrrY|\xbe\x8bV\x9b\xbf\x9e\xe7" +
	"\x1f^z\xa0\xfe\x91-j\xc0\xb5\xbb\xd8\xa1\\f\x0d" +
	"\x90W\xb8\x8dr\xd6\xbb\x9d\xa2\xf8\xed\x87\xfd\xa3/\x8e" +
	"\xbf\xdd\x81\xbdh\x02\xde\xe0\xef\xf2\x80\xf7\x01\xd7>\xe6" +
	"\x1d\x16X\xfcl_\xff\xea\xd9O\xee\xfe\xec\xdf\xdb>" +
	"jw(\x9f\xb4\xcd\xaaU{\x1b\xcbE\xa0\xb2<U" +
	"\x0f\xa9J\x9a\x85\xb7T/{\xb0\xa7\x92ar}u" +
	":\\M\x924\xdeR\x11\xba\xa4\xe7X\x15\xa0B\xa0" +
	"u\xa5\x03x\xf7Z\xf4V\x04[\xa4K\x83\xcb\x9f\x02" +
	"\xde\x8aE\xefq\xc1\x97_\xe8w\xd38\xbe\xc5&\x04" +
	"\x9b`\x11':UY\x9c\xb2\x13\x85\xc3\xc0\x0f7n" +
	"\x0c\xcd\xd1\xba\x0c\x98f\".fr\xe3\xef\xb1\xe7p" +
	"\xfef\xf5\xb5\xb9\xea\xd5\xd7\x8a\xa7u\xa6\x02\x95)\x00" +
	"E\x994\xe0=6\xcdY\x8ey?\xe0g\xb4\xe8\xbf" +
	"\xc2Y\xda\xf2%\xae\x01\xfe\x8b\xc6_\xa3 \x85K\x01" +
	"\xc8\x1d\xae\x03\xfe\xab\x86\xf7L\xb8%\\Z\x93j\x1b" +
	"\xdf5\xfe\x96\xf1\x8apY\x01\xe4\x9b\x93\xed\xf7\x8c\x1f" +
	"\x1a\xb7-\x976 \x0fx\x15\xf0\xf7\x8d\xbfc\xbcj" +
	"\xb9\xac\x02\xf2\x88)\xe0\x1f\x1a\x7f\xdfx\xad\xe2N\x9e" +
	"\xfb=>\x03\xf8\xef\x1a?1\xee\xd8.\x1d@~0" +
	"I\xf3\xd8\xf8\xa9\xf1z\xd5e\x1d\x90_\xf2u\xc0?" +
	"5\xfe\x9d\xf1\x85\x9a\xcb\x05@~\xc3\xe7\x01\xffk\xe3" +
	"g\xc6\x17\x1d\x97\x8b\x80\xfc\x9eo\x03\xfe\x99\xf1\x9f\x8c" +
	"7\xea.\x1b\x80<\x9f\xdc\xebGZ\\\x17\x82\xad\xe6" +
	"\x82\xcb& \xff\x9c\xf0\x1f&\xdc\x11\x82Ky\x1e\x06" +
	"\xe5\x9b\xf56u\xaf?\xca\x07\x00J\xcb\xc2\x81\x1ee" +
	"j\x00&\xb4!h\x83\xc5@\x07\xa1\xca\xc6\x09\xa8\xd9" +
	"\x80`\x03\\J\xe3H\xd3\x81\xa0\x03\xb6G\xbd8)" +
	"GE2\xd2y\x10\x0f\xc7h\x0f\x9eR\xa3\xcdr\xeb" +
	"\x81N\xfb\x91^\x8fa\xc5\xd9\x1c\x96\x0f\xcfK`\xd7" +
	"\"o\x9b\xf5\x09h\xb0\xd0\xc3^:N2\xcd\xa0\xab" +
	"\xc6Q\xac\x82\xb9\x84\xa7sX\x0an\xea\xf1\x8c\x93M" +
	"=\xd0\xa9b\xd4\xcd\x9f\x8b\xc2\xdeMknRM;" +
	"\x8c\xa3\xd9\xa1e?\xfes\xe8(\xdc\x98\xf4\xb8\xb9\xf5" +
	"\xc5.\xff\xbf\xffV\xb6\xf1\x85\xffv\xcf\x7f\xfd\xb7\xab" +
	"\x80w\xd9\xa2\xf7\x88`\xad\xaf\xc7\xd3\xd2\xb6\xb7T\x94" +
	"\x97\x85\xfe+\x00\x00\xff\xff\x9a^\xfb\xbf"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_85d3acc39d94e0f8,
		Nodes: []uint64{
			0x8cc20228b0f1020d,
			0xb1092b0e00ae75e5,
			0xc121b65fcd3a05ee,
		},
		Compressed: true,
	})
}
