<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carrier Fields & Emergent Entanglement</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
            color: #e6edf3;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 8px;
            font-weight: 300;
            font-size: 1.8em;
            color: #fff;
        }
        
        .subtitle {
            text-align: center;
            color: #8b949e;
            margin-bottom: 25px;
            font-size: 0.95em;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .main-display {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 900px) {
            .main-display {
                grid-template-columns: 1fr;
            }
        }
        
        .canvas-container {
            background: rgba(22, 27, 34, 0.8);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 15px;
        }
        
        canvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 8px;
        }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .panel {
            background: rgba(22, 27, 34, 0.8);
            border: 1px solid #30363d;
            border-radius: 10px;
            padding: 15px;
        }
        
        .panel h3 {
            font-size: 0.85em;
            margin-bottom: 12px;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #30363d;
            padding-bottom: 8px;
        }
        
        .carrier-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 6px;
            background: rgba(0,0,0,0.2);
        }
        
        .carrier-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .carrier-info {
            flex: 1;
            font-size: 0.85em;
        }
        
        .carrier-name {
            font-weight: 600;
        }
        
        .carrier-freq {
            color: #8b949e;
            font-size: 0.8em;
        }
        
        .carrier-bar {
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }
        
        .carrier-bar-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.1s;
        }
        
        .entanglement-matrix {
            display: grid;
            gap: 2px;
            margin-top: 10px;
        }
        
        .matrix-row {
            display: flex;
            gap: 2px;
        }
        
        .matrix-cell {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65em;
            font-weight: 600;
        }
        
        .matrix-label {
            background: transparent;
            color: #8b949e;
        }
        
        .oscillator-controls {
            margin-top: 10px;
        }
        
        .osc-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding: 6px 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
        }
        
        .osc-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .osc-dot:hover {
            transform: scale(1.2);
        }
        
        .osc-dot.active {
            border-color: #fff;
            box-shadow: 0 0 10px currentColor;
        }
        
        .osc-label {
            font-size: 0.8em;
            width: 20px;
        }
        
        .osc-sliders {
            flex: 1;
            display: flex;
            gap: 4px;
        }
        
        .presence-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            outline: none;
        }
        
        .presence-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.2s;
            flex: 1;
            min-width: 80px;
        }
        
        button:hover {
            background: rgba(255,255,255,0.2);
        }
        
        button.active {
            background: rgba(100, 200, 150, 0.3);
            border-color: #64c896;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            font-size: 0.8em;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }
        
        .info-text {
            font-size: 0.8em;
            color: #8b949e;
            line-height: 1.5;
            margin-top: 8px;
        }
        
        .equation {
            font-family: 'Cambria Math', 'Times New Roman', serif;
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            border-radius: 6px;
            text-align: center;
            margin: 10px 0;
            font-size: 0.9em;
            color: #c9d1d9;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .stat-label {
            color: #8b949e;
        }
        
        .stat-value {
            font-weight: 600;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Carrier Fields & Emergent Entanglement</h1>
        <p class="subtitle">Relationships are not stored — they emerge from shared presence</p>
        
        <div class="main-display">
            <div class="canvas-container">
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-line" style="background: linear-gradient(90deg, #ff6b6b, #4ecdc4);"></div>
                        <span>Presence (oscillator → carrier)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line" style="background: rgba(255,255,255,0.5);"></div>
                        <span>Emergent entanglement</span>
                    </div>
                </div>
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>
            
            <div class="sidebar">
                <div class="panel">
                    <h3>Carrier Fields</h3>
                    <div id="carrier-indicators"></div>
                    <div class="info-text">
                        Carrier fields are the "trampolines" — shared media that oscillators can be present on.
                    </div>
                </div>
                
                <div class="panel">
                    <h3>Oscillator Presence</h3>
                    <div class="info-text" style="margin-top: 0; margin-bottom: 8px;">
                        Click dot to activate. Sliders set presence on each carrier (θ, α, γ).
                    </div>
                    <div id="oscillator-controls"></div>
                </div>
                
                <div class="panel">
                    <h3>Emergent Entanglement</h3>
                    <div class="equation">E(i,j) = Σₖ Pᵢₖ × Pⱼₖ × activity(k)</div>
                    <div id="entanglement-matrix"></div>
                    <div class="info-text">
                        Not stored — computed live from shared presence on active carriers.
                    </div>
                </div>
                
                <div class="panel">
                    <h3>Controls</h3>
                    <div class="buttons">
                        <button id="toggleLearn" class="">Learning</button>
                        <button id="resetPresence">Reset</button>
                    </div>
                    <div class="buttons" style="margin-top: 8px;">
                        <button id="presetShared">Shared θ</button>
                        <button id="presetSplit">Split</button>
                        <button id="presetAll">All</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        const config = {
            numOscillators: 5,
            carriers: [
                { name: 'Theta (θ)', freq: 0.3, color: '#f093fb', hue: 300 },
                { name: 'Alpha (α)', freq: 0.7, color: '#4facfe', hue: 210 },
                { name: 'Gamma (γ)', freq: 1.5, color: '#43e97b', hue: 145 }
            ],
            oscillatorColors: ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff'],
            learningRate: 0.015,
            damping: 0.02
        };
        
        // State
        let time = 0;
        let learning = false;
        
        // Oscillators: { active, phase, freq }
        const oscillators = [];
        for (let i = 0; i < config.numOscillators; i++) {
            oscillators.push({
                active: false,
                phase: Math.random() * Math.PI * 2,
                freq: 0.8 + Math.random() * 0.4
            });
        }
        
        // Presence matrix: oscillator x carrier
        const presence = [];
        for (let i = 0; i < config.numOscillators; i++) {
            presence.push([]);
            for (let k = 0; k < config.carriers.length; k++) {
                presence[i].push(Math.random() * 0.3 + 0.1);
            }
        }
        
        // Carrier field states
        const carrierStates = config.carriers.map(() => ({ energy: 0, phase: 0 }));
        
        // Initialize UI
        function initUI() {
            // Carrier indicators
            const carrierContainer = document.getElementById('carrier-indicators');
            carrierContainer.innerHTML = config.carriers.map((c, i) => `
                <div class="carrier-indicator">
                    <div class="carrier-dot" style="background: ${c.color};"></div>
                    <div class="carrier-info">
                        <div class="carrier-name">${c.name}</div>
                        <div class="carrier-freq">${c.freq.toFixed(1)} Hz</div>
                        <div class="carrier-bar">
                            <div class="carrier-bar-fill" id="carrier-bar-${i}" style="background: ${c.color}; width: 0%;"></div>
                        </div>
                    </div>
                </div>
            `).join('');
            
            // Oscillator controls
            const oscContainer = document.getElementById('oscillator-controls');
            oscContainer.innerHTML = oscillators.map((o, i) => `
                <div class="osc-control">
                    <div class="osc-dot" id="osc-dot-${i}" style="background: ${config.oscillatorColors[i]};" onclick="toggleOscillator(${i})"></div>
                    <div class="osc-label">${String.fromCharCode(65 + i)}</div>
                    <div class="osc-sliders">
                        ${config.carriers.map((c, k) => `
                            <input type="range" class="presence-slider" 
                                id="presence-${i}-${k}" 
                                min="0" max="1" step="0.01" 
                                value="${presence[i][k].toFixed(2)}"
                                style="accent-color: ${c.color};"
                                oninput="updatePresence(${i}, ${k}, this.value)"
                                title="${c.name}">
                        `).join('')}
                    </div>
                </div>
            `).join('');
            
            // Entanglement matrix
            updateEntanglementMatrix();
            
            // Button handlers
            document.getElementById('toggleLearn').addEventListener('click', function() {
                learning = !learning;
                this.classList.toggle('active', learning);
            });
            
            document.getElementById('resetPresence').addEventListener('click', () => {
                for (let i = 0; i < config.numOscillators; i++) {
                    for (let k = 0; k < config.carriers.length; k++) {
                        presence[i][k] = 0.2;
                        document.getElementById(`presence-${i}-${k}`).value = 0.2;
                    }
                    oscillators[i].active = false;
                    document.getElementById(`osc-dot-${i}`).classList.remove('active');
                }
            });
            
            document.getElementById('presetShared').addEventListener('click', () => {
                // All oscillators high presence on theta
                for (let i = 0; i < config.numOscillators; i++) {
                    presence[i][0] = 0.9; // theta
                    presence[i][1] = 0.1; // alpha
                    presence[i][2] = 0.1; // gamma
                    for (let k = 0; k < 3; k++) {
                        document.getElementById(`presence-${i}-${k}`).value = presence[i][k];
                    }
                }
            });
            
            document.getElementById('presetSplit').addEventListener('click', () => {
                // Half on theta, half on gamma
                for (let i = 0; i < config.numOscillators; i++) {
                    if (i < 3) {
                        presence[i][0] = 0.9; presence[i][1] = 0.1; presence[i][2] = 0.1;
                    } else {
                        presence[i][0] = 0.1; presence[i][1] = 0.1; presence[i][2] = 0.9;
                    }
                    for (let k = 0; k < 3; k++) {
                        document.getElementById(`presence-${i}-${k}`).value = presence[i][k];
                    }
                }
            });
            
            document.getElementById('presetAll').addEventListener('click', () => {
                // All oscillators present on all carriers
                for (let i = 0; i < config.numOscillators; i++) {
                    for (let k = 0; k < 3; k++) {
                        presence[i][k] = 0.6;
                        document.getElementById(`presence-${i}-${k}`).value = 0.6;
                    }
                }
            });
        }
        
        window.toggleOscillator = function(i) {
            oscillators[i].active = !oscillators[i].active;
            document.getElementById(`osc-dot-${i}`).classList.toggle('active', oscillators[i].active);
        };
        
        window.updatePresence = function(i, k, val) {
            presence[i][k] = parseFloat(val);
        };
        
        function computeEntanglement() {
            const E = [];
            for (let i = 0; i < config.numOscillators; i++) {
                E.push([]);
                for (let j = 0; j < config.numOscillators; j++) {
                    if (i === j) {
                        E[i].push(1);
                    } else {
                        let sum = 0;
                        for (let k = 0; k < config.carriers.length; k++) {
                            sum += presence[i][k] * presence[j][k] * carrierStates[k].energy;
                        }
                        E[i].push(sum);
                    }
                }
            }
            return E;
        }
        
        function updateEntanglementMatrix() {
            const E = computeEntanglement();
            const container = document.getElementById('entanglement-matrix');
            
            let html = '<div class="entanglement-matrix" style="grid-template-columns: repeat(' + (config.numOscillators + 1) + ', 28px);">';
            
            // Header row
            html += '<div class="matrix-row">';
            html += '<div class="matrix-cell matrix-label"></div>';
            for (let j = 0; j < config.numOscillators; j++) {
                html += `<div class="matrix-cell matrix-label">${String.fromCharCode(65 + j)}</div>`;
            }
            html += '</div>';
            
            // Data rows
            for (let i = 0; i < config.numOscillators; i++) {
                html += '<div class="matrix-row">';
                html += `<div class="matrix-cell matrix-label">${String.fromCharCode(65 + i)}</div>`;
                for (let j = 0; j < config.numOscillators; j++) {
                    const val = E[i][j];
                    const alpha = i === j ? 0.3 : Math.min(1, val * 2);
                    const bg = i === j ? 'rgba(255,255,255,0.1)' : `rgba(255,255,255,${alpha})`;
                    const textColor = alpha > 0.5 ? '#000' : '#fff';
                    html += `<div class="matrix-cell" style="background: ${bg}; color: ${textColor};">${i === j ? '—' : val.toFixed(2)}</div>`;
                }
                html += '</div>';
            }
            html += '</div>';
            
            container.innerHTML = html;
        }
        
        function animate() {
            const width = canvas.width;
            const height = canvas.height;
            const dt = 0.016;
            
            // Clear
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Layout
            const carrierY = [150, 300, 450];
            const carrierHeight = 80;
            const oscRadius = 25;
            const oscY = height - 80;
            const oscSpacing = width / (config.numOscillators + 1);
            
            // Update carrier states based on oscillator activity
            for (let k = 0; k < config.carriers.length; k++) {
                let excitation = 0;
                for (let i = 0; i < config.numOscillators; i++) {
                    if (oscillators[i].active) {
                        const oscAmp = Math.sin(oscillators[i].phase);
                        excitation += presence[i][k] * (0.5 + 0.5 * oscAmp);
                    }
                }
                
                // Carrier dynamics
                carrierStates[k].energy += (excitation * 0.3 - config.damping * carrierStates[k].energy) * dt * 60;
                carrierStates[k].energy = Math.max(0, Math.min(1, carrierStates[k].energy));
                carrierStates[k].phase += config.carriers[k].freq * dt * Math.PI * 2;
                
                // Update UI
                document.getElementById(`carrier-bar-${k}`).style.width = (carrierStates[k].energy * 100) + '%';
            }
            
            // Learning
            if (learning) {
                for (let i = 0; i < config.numOscillators; i++) {
                    if (oscillators[i].active) {
                        for (let k = 0; k < config.carriers.length; k++) {
                            if (carrierStates[k].energy > 0.1) {
                                presence[i][k] += config.learningRate * carrierStates[k].energy * dt * 60;
                                presence[i][k] = Math.min(1, presence[i][k]);
                                document.getElementById(`presence-${i}-${k}`).value = presence[i][k];
                            }
                        }
                    }
                }
            }
            
            // Draw carrier fields
            for (let k = 0; k < config.carriers.length; k++) {
                const carrier = config.carriers[k];
                const y = carrierY[k];
                const energy = carrierStates[k].energy;
                const phase = carrierStates[k].phase;
                
                // Carrier wave background glow
                const gradient = ctx.createLinearGradient(0, y - carrierHeight, 0, y + carrierHeight);
                gradient.addColorStop(0, `hsla(${carrier.hue}, 80%, 60%, 0)`);
                gradient.addColorStop(0.5, `hsla(${carrier.hue}, 80%, 60%, ${0.1 + energy * 0.2})`);
                gradient.addColorStop(1, `hsla(${carrier.hue}, 80%, 60%, 0)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, y - carrierHeight, width, carrierHeight * 2);
                
                // Carrier wave
                ctx.strokeStyle = `hsla(${carrier.hue}, 80%, 70%, ${0.3 + energy * 0.7})`;
                ctx.lineWidth = 2 + energy * 3;
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const waveY = y + Math.sin(phase + x * 0.02 * carrier.freq) * (20 + energy * 40);
                    if (x === 0) ctx.moveTo(x, waveY);
                    else ctx.lineTo(x, waveY);
                }
                ctx.stroke();
                
                // Carrier label
                ctx.fillStyle = carrier.color;
                ctx.font = 'bold 14px Segoe UI';
                ctx.textAlign = 'left';
                ctx.fillText(carrier.name, 15, y - carrierHeight + 20);
            }
            
            // Draw presence lines (oscillator to carrier)
            for (let i = 0; i < config.numOscillators; i++) {
                const oscX = oscSpacing * (i + 1);
                
                for (let k = 0; k < config.carriers.length; k++) {
                    const p = presence[i][k];
                    if (p > 0.05) {
                        const carrier = config.carriers[k];
                        const targetY = carrierY[k];
                        
                        // Curved line from oscillator to carrier
                        ctx.strokeStyle = `hsla(${carrier.hue}, 70%, 60%, ${p * 0.6})`;
                        ctx.lineWidth = p * 4;
                        ctx.beginPath();
                        ctx.moveTo(oscX, oscY - oscRadius);
                        
                        // Control points for bezier
                        const cp1y = oscY - (oscY - targetY) * 0.3;
                        const cp2y = targetY + (oscY - targetY) * 0.3;
                        ctx.bezierCurveTo(oscX, cp1y, oscX, cp2y, oscX, targetY);
                        ctx.stroke();
                        
                        // Glow at carrier intersection when active
                        if (oscillators[i].active && carrierStates[k].energy > 0.1) {
                            ctx.fillStyle = `hsla(${carrier.hue}, 80%, 70%, ${p * carrierStates[k].energy * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(oscX, targetY, 8 + p * 10, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
            
            // Compute and draw emergent entanglement
            const E = computeEntanglement();
            for (let i = 0; i < config.numOscillators; i++) {
                for (let j = i + 1; j < config.numOscillators; j++) {
                    const ent = E[i][j];
                    if (ent > 0.05) {
                        const x1 = oscSpacing * (i + 1);
                        const x2 = oscSpacing * (j + 1);
                        
                        // Entanglement arc below oscillators
                        ctx.strokeStyle = `rgba(255, 255, 255, ${ent * 0.8})`;
                        ctx.lineWidth = 1 + ent * 3;
                        ctx.beginPath();
                        
                        const midX = (x1 + x2) / 2;
                        const arcDepth = 20 + (j - i) * 15;
                        ctx.moveTo(x1, oscY + oscRadius);
                        ctx.quadraticCurveTo(midX, oscY + oscRadius + arcDepth, x2, oscY + oscRadius);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw oscillators
            for (let i = 0; i < config.numOscillators; i++) {
                const x = oscSpacing * (i + 1);
                const color = config.oscillatorColors[i];
                const osc = oscillators[i];
                
                // Update phase
                osc.phase += osc.freq * dt * Math.PI * 2;
                
                // Glow if active
                if (osc.active) {
                    const glowSize = oscRadius + 10 + Math.sin(osc.phase) * 5;
                    const gradient = ctx.createRadialGradient(x, oscY, 0, x, oscY, glowSize);
                    gradient.addColorStop(0, color + '80');
                    gradient.addColorStop(1, color + '00');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, oscY, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Main circle
                ctx.fillStyle = osc.active ? color : color + '60';
                ctx.beginPath();
                ctx.arc(x, oscY, oscRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Border
                ctx.strokeStyle = osc.active ? '#fff' : 'rgba(255,255,255,0.3)';
                ctx.lineWidth = osc.active ? 3 : 1;
                ctx.stroke();
                
                // Phase indicator (rotating line inside)
                if (osc.active) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, oscY);
                    ctx.lineTo(
                        x + Math.cos(osc.phase) * (oscRadius - 5),
                        oscY + Math.sin(osc.phase) * (oscRadius - 5)
                    );
                    ctx.stroke();
                }
                
                // Label
                ctx.fillStyle = osc.active ? '#fff' : 'rgba(255,255,255,0.6)';
                ctx.font = 'bold 16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(String.fromCharCode(65 + i), x, oscY + 5);
            }
            
            // Update entanglement display periodically
            if (Math.floor(time * 10) !== Math.floor((time - dt) * 10)) {
                updateEntanglementMatrix();
            }
            
            time += dt;
            requestAnimationFrame(animate);
        }
        
        initUI();
        animate();
    </script>
</body>
</html>
