Directory Structure:

└── ./
    ├── examples
    │   ├── about
    │   │   ├── public
    │   │   │   └── index.html
    │   │   ├── src
    │   │   │   ├── config
    │   │   │   │   └── Config.js
    │   │   │   ├── controllers
    │   │   │   │   ├── audio
    │   │   │   │   │   └── AudioController.js
    │   │   │   │   ├── panel
    │   │   │   │   │   └── PanelController.js
    │   │   │   │   ├── world
    │   │   │   │   │   ├── FluidController.js
    │   │   │   │   │   └── WorldController.js
    │   │   │   │   ├── App.js
    │   │   │   │   └── Preloader.js
    │   │   │   ├── data
    │   │   │   │   ├── Data.js
    │   │   │   │   └── Socket.js
    │   │   │   ├── materials
    │   │   │   │   ├── FluidPassMaterial.js
    │   │   │   │   └── FluidViewMaterial.js
    │   │   │   ├── views
    │   │   │   │   ├── ui
    │   │   │   │   │   └── DetailsUser.js
    │   │   │   │   ├── PreloaderView.js
    │   │   │   │   └── TrackersView.js
    │   │   │   └── main.js
    │   │   └── rollup.config.js
    │   ├── ogl
    │   │   └── shader_fxaa.html
    │   ├── three
    │   │   ├── transitions
    │   │   │   ├── camera
    │   │   │   │   ├── abstract_cube
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── dark_planet
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── floating_crystal
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── canvas
    │   │   │   │   ├── abstract_cube
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── dark_planet
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── floating_crystal
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── page
    │   │   │   │   ├── abstract_cube
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── dark_planet
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── floating_crystal
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── scene
    │   │   │   │   ├── abstract_cube
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── dark_planet
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── floating_crystal
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── scene_direction
    │   │   │   │   ├── abstract_cube
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── dark_planet
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── floating_crystal
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── scroll
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── scroll_content
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── scroll_content_skew
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── scroll_content_views
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── scroll_direction
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── scroll_direction_zoom
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   ├── shader
    │   │   │   │   ├── abstract_cube
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── dark_planet
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── floating_crystal
    │   │   │   │   │   └── index.html
    │   │   │   │   ├── index.html
    │   │   │   │   └── main.js
    │   │   │   └── shader_fade
    │   │   │       ├── abstract_cube
    │   │   │       │   └── index.html
    │   │   │       ├── dark_planet
    │   │   │       │   └── index.html
    │   │   │       ├── floating_crystal
    │   │   │       │   └── index.html
    │   │   │       ├── index.html
    │   │   │       └── main.js
    │   │   ├── 3d_abstract_cube.html
    │   │   ├── 3d_backdrop.html
    │   │   ├── 3d_black_holes.html
    │   │   ├── 3d_camera_wobble.html
    │   │   ├── 3d_crystal_gltf_basis_draco.html
    │   │   ├── 3d_crystal_gltf.html
    │   │   ├── 3d_cubecamera_rainbow.html
    │   │   ├── 3d_cubecamera.html
    │   │   ├── 3d_cubemap_uv.html
    │   │   ├── 3d_graph_tracking.html
    │   │   ├── 3d_infinite_stars_rgbshift.html
    │   │   ├── 3d_input_manager.html
    │   │   ├── 3d_panel_tracking.html
    │   │   ├── 3d_penrose_triangle.html
    │   │   ├── 3d_physics_gravity_balls_thread.html
    │   │   ├── 3d_physics_gravity_balls.html
    │   │   ├── 3d_physics_instancing_thread.html
    │   │   ├── 3d_physics_instancing.html
    │   │   ├── 3d_physics_picking_thread.html
    │   │   ├── 3d_physics_picking.html
    │   │   ├── 3d_polyhedron.html
    │   │   ├── 3d_ripple.html
    │   │   ├── 3d_spherical_cube_uv.html
    │   │   ├── 3d_stripe_gradient.html
    │   │   ├── shader_afterimage.html
    │   │   ├── shader_anamorphic_light_lensflare.html
    │   │   ├── shader_anamorphic_light.html
    │   │   ├── shader_baked_abstract_cube_dudv.html
    │   │   ├── shader_baked_abstract_cube_sss.html
    │   │   ├── shader_baked_abstract_cube.html
    │   │   ├── shader_baked_cube_dudv.html
    │   │   ├── shader_baked_cube_sss.html
    │   │   ├── shader_baked_cube.html
    │   │   ├── shader_baked_spherical_cube_dudv.html
    │   │   ├── shader_baked_spherical_cube_sss.html
    │   │   ├── shader_baked_spherical_cube.html
    │   │   ├── shader_barrel_distortion.html
    │   │   ├── shader_basic_color_lighting.html
    │   │   ├── shader_basic_texture_lighting.html
    │   │   ├── shader_bloom_dither.html
    │   │   ├── shader_bloom_hdr.html
    │   │   ├── shader_bloom.html
    │   │   ├── shader_blur.html
    │   │   ├── shader_bokeh_blur.html
    │   │   ├── shader_chromatic_aberration.html
    │   │   ├── shader_datamosh.html
    │   │   ├── shader_depth.html
    │   │   ├── shader_dof_fake.html
    │   │   ├── shader_film_grain.html
    │   │   ├── shader_flowmap_rgbshift.html
    │   │   ├── shader_flowmap_view.html
    │   │   ├── shader_flowmap.html
    │   │   ├── shader_fluid_distortion_rgbshift.html
    │   │   ├── shader_fluid_distortion_view.html
    │   │   ├── shader_fluid_distortion.html
    │   │   ├── shader_fresnel.html
    │   │   ├── shader_fxaa.html
    │   │   ├── shader_hologram.html
    │   │   ├── shader_lensflare.html
    │   │   ├── shader_light_rays.html
    │   │   ├── shader_matcap.html
    │   │   ├── shader_motion_blur.html
    │   │   ├── shader_noise.html
    │   │   ├── shader_poisson_disc_blur.html
    │   │   ├── shader_radial_blur_rgbshift.html
    │   │   ├── shader_radial_glow.html
    │   │   ├── shader_reflection_diffuse.html
    │   │   ├── shader_reflection_dudv.html
    │   │   ├── shader_reflection_metalness.html
    │   │   ├── shader_reflection_normalmap.html
    │   │   ├── shader_reflection.html
    │   │   ├── shader_single_pass_blur.html
    │   │   ├── shader_smaa.html
    │   │   ├── shader_soft_particles.html
    │   │   ├── shader_soft_shadows.html
    │   │   ├── shader_subsurface_scattering.html
    │   │   ├── shader_text.html
    │   │   ├── shader_tilt_shift.html
    │   │   ├── shader_unreal_bloom.html
    │   │   ├── shader_vignette_blur.html
    │   │   ├── shader_volumetric_light.html
    │   │   ├── test_oimophysics.html
    │   │   └── test_wobble.html
    │   └── rollup.config.js
    ├── src
    │   ├── ogl
    │   │   └── programs
    │   │       ├── FXAAProgram.js
    │   │       └── Programs.js
    │   ├── shaders
    │   │   ├── modules
    │   │   │   ├── aastep
    │   │   │   │   └── aastep.glsl.js
    │   │   │   ├── badtv
    │   │   │   │   └── badtv.glsl.js
    │   │   │   ├── blending
    │   │   │   │   ├── add.glsl.js
    │   │   │   │   ├── alpha.glsl.js
    │   │   │   │   ├── average.glsl.js
    │   │   │   │   ├── color-burn.glsl.js
    │   │   │   │   ├── color-dodge.glsl.js
    │   │   │   │   ├── darken.glsl.js
    │   │   │   │   ├── difference.glsl.js
    │   │   │   │   ├── divide.glsl.js
    │   │   │   │   ├── exclusion.glsl.js
    │   │   │   │   ├── lighten.glsl.js
    │   │   │   │   ├── multiply.glsl.js
    │   │   │   │   ├── negation.glsl.js
    │   │   │   │   ├── normal.glsl.js
    │   │   │   │   ├── overlay.glsl.js
    │   │   │   │   ├── reflect.glsl.js
    │   │   │   │   ├── screen.glsl.js
    │   │   │   │   ├── soft-light.glsl.js
    │   │   │   │   └── subtract.glsl.js
    │   │   │   ├── blur
    │   │   │   │   ├── blur.glsl.js
    │   │   │   │   ├── blur13.glsl.js
    │   │   │   │   ├── blur5.glsl.js
    │   │   │   │   ├── blur9.glsl.js
    │   │   │   │   ├── poisson-disc-blur12.glsl.js
    │   │   │   │   ├── poisson-disc-blur27.glsl.js
    │   │   │   │   ├── radial-blur10-rgbshift.glsl.js
    │   │   │   │   ├── radial-blur10.glsl.js
    │   │   │   │   ├── radial-blur8-rgbshift.glsl.js
    │   │   │   │   ├── radial-blur8.glsl.js
    │   │   │   │   └── unreal-blur.glsl.js
    │   │   │   ├── brightness-contrast
    │   │   │   │   └── brightness-contrast.glsl.js
    │   │   │   ├── conditionals
    │   │   │   │   ├── when_and.glsl.js
    │   │   │   │   ├── when_eq.glsl.js
    │   │   │   │   ├── when_ge.glsl.js
    │   │   │   │   ├── when_gt.glsl.js
    │   │   │   │   ├── when_le.glsl.js
    │   │   │   │   ├── when_lt.glsl.js
    │   │   │   │   ├── when_neq.glsl.js
    │   │   │   │   ├── when_not.glsl.js
    │   │   │   │   ├── when_or.glsl.js
    │   │   │   │   └── when_xor.glsl.js
    │   │   │   ├── depth
    │   │   │   │   └── depth.glsl.js
    │   │   │   ├── desaturate
    │   │   │   │   └── desaturate.glsl.js
    │   │   │   ├── dither
    │   │   │   │   └── dither.glsl.js
    │   │   │   ├── easing
    │   │   │   │   ├── back-in-out.glsl.js
    │   │   │   │   ├── back-in.glsl.js
    │   │   │   │   ├── back-out.glsl.js
    │   │   │   │   ├── bounce-in-out.glsl.js
    │   │   │   │   ├── bounce-in.glsl.js
    │   │   │   │   ├── bounce-out.glsl.js
    │   │   │   │   ├── circular-in-out.glsl.js
    │   │   │   │   ├── circular-in.glsl.js
    │   │   │   │   ├── circular-out.glsl.js
    │   │   │   │   ├── cubic-in-out.glsl.js
    │   │   │   │   ├── cubic-in.glsl.js
    │   │   │   │   ├── cubic-out.glsl.js
    │   │   │   │   ├── elastic-in-out.glsl.js
    │   │   │   │   ├── elastic-in.glsl.js
    │   │   │   │   ├── elastic-out.glsl.js
    │   │   │   │   ├── exponential-in-out.glsl.js
    │   │   │   │   ├── exponential-in.glsl.js
    │   │   │   │   ├── exponential-out.glsl.js
    │   │   │   │   ├── linear.glsl.js
    │   │   │   │   ├── quadratic-in-out.glsl.js
    │   │   │   │   ├── quadratic-in.glsl.js
    │   │   │   │   ├── quadratic-out.glsl.js
    │   │   │   │   ├── quartic-in-out.glsl.js
    │   │   │   │   ├── quartic-in.glsl.js
    │   │   │   │   ├── quartic-out.glsl.js
    │   │   │   │   ├── quintic-in-out.glsl.js
    │   │   │   │   ├── quintic-in.glsl.js
    │   │   │   │   ├── quintic-out.glsl.js
    │   │   │   │   ├── sine-in-out.glsl.js
    │   │   │   │   ├── sine-in.glsl.js
    │   │   │   │   └── sine-out.glsl.js
    │   │   │   ├── encodings
    │   │   │   │   └── encodings.glsl.js
    │   │   │   ├── fbm
    │   │   │   │   ├── fbm1d.glsl.js
    │   │   │   │   ├── fbm2d.glsl.js
    │   │   │   │   └── fbm3d.glsl.js
    │   │   │   ├── fresnel
    │   │   │   │   └── fresnel.glsl.js
    │   │   │   ├── fxaa
    │   │   │   │   └── fxaa.glsl.js
    │   │   │   ├── hsv
    │   │   │   │   ├── hsv2rgb.glsl.js
    │   │   │   │   ├── hsv2rgbSmooth.glsl.js
    │   │   │   │   ├── lerpHSV.glsl.js
    │   │   │   │   └── rgb2hsv.glsl.js
    │   │   │   ├── lensflare
    │   │   │   │   └── lensflare.glsl.js
    │   │   │   ├── levels
    │   │   │   │   └── levels.glsl.js
    │   │   │   ├── map
    │   │   │   │   └── map.glsl.js
    │   │   │   ├── noise
    │   │   │   │   ├── blue-noise.glsl.js
    │   │   │   │   ├── classic2d.glsl.js
    │   │   │   │   ├── classic3d.glsl.js
    │   │   │   │   ├── classic4d.glsl.js
    │   │   │   │   ├── noise1d.glsl.js
    │   │   │   │   ├── noise2d.glsl.js
    │   │   │   │   ├── noise3d.glsl.js
    │   │   │   │   ├── periodic2d.glsl.js
    │   │   │   │   ├── periodic3d.glsl.js
    │   │   │   │   ├── periodic4d.glsl.js
    │   │   │   │   ├── simplex2d.glsl.js
    │   │   │   │   ├── simplex3d.glsl.js
    │   │   │   │   └── simplex4d.glsl.js
    │   │   │   ├── parabola
    │   │   │   │   └── parabola.glsl.js
    │   │   │   ├── random
    │   │   │   │   └── random.glsl.js
    │   │   │   ├── rgbshift
    │   │   │   │   └── rgbshift.glsl.js
    │   │   │   ├── smootherstep
    │   │   │   │   └── smootherstep.glsl.js
    │   │   │   └── transformUV
    │   │   │       ├── rotateUV.glsl.js
    │   │   │       └── scaleUV.glsl.js
    │   │   ├── ACESFilmicToneMappingShader.js
    │   │   ├── AfterimageShader.js
    │   │   ├── BadTVShader.js
    │   │   ├── BasicLightingShader.js
    │   │   ├── BasicShader.js
    │   │   ├── BloomCompositeShader.js
    │   │   ├── BlurShader.js
    │   │   ├── BokehBlurShader1.js
    │   │   ├── BokehBlurShader2.js
    │   │   ├── ChromaticAberrationShader.js
    │   │   ├── ColorLightingShader.js
    │   │   ├── ColorShader.js
    │   │   ├── CopyShader.js
    │   │   ├── DatamoshShader.js
    │   │   ├── DepthMaskShader.js
    │   │   ├── DepthShader.js
    │   │   ├── DiscardShader.js
    │   │   ├── DrawBuffersShader.js
    │   │   ├── FastGaussianBlurShader.js
    │   │   ├── FresnelShader.js
    │   │   ├── FXAAShader.js
    │   │   ├── GammaCorrectionShader.js
    │   │   ├── LensflareShader.js
    │   │   ├── LuminosityShader.js
    │   │   ├── MaskShader.js
    │   │   ├── MotionBlurCompositeShader.js
    │   │   ├── MotionBlurVelocityShader.js
    │   │   ├── NormalShader.js
    │   │   ├── PoissonDiscBlurShader.js
    │   │   ├── ReflectorBlurShader.js
    │   │   ├── ReflectorDudvShader.js
    │   │   ├── ReflectorShader.js
    │   │   ├── RGBShader.js
    │   │   ├── SceneCompositeAddShader.js
    │   │   ├── SceneCompositeDistortionShader.js
    │   │   ├── SceneCompositeShader.js
    │   │   ├── ShadowTextureShader.js
    │   │   ├── SinglePassBlurShader.js
    │   │   ├── SMAABlendShader.js
    │   │   ├── SMAAEdgesShader.js
    │   │   ├── SMAAWeightsShader.js
    │   │   ├── TextShader.js
    │   │   ├── TiltShiftShader.js
    │   │   ├── UnrealBloomBlurShader.js
    │   │   ├── UnrealBloomCompositeShader.js
    │   │   ├── VideoGlitchShader.js
    │   │   ├── VolumetricLightLensflareShader.js
    │   │   └── VolumetricLightShader.js
    │   ├── three
    │   │   ├── materials
    │   │   │   ├── ACESFilmicToneMappingMaterial.js
    │   │   │   ├── AfterimageMaterial.js
    │   │   │   ├── BadTVMaterial.js
    │   │   │   ├── BasicLightingMaterial.js
    │   │   │   ├── BasicMaterial.js
    │   │   │   ├── BloomCompositeMaterial.js
    │   │   │   ├── BlurMaterial.js
    │   │   │   ├── BokehBlurMaterial1.js
    │   │   │   ├── BokehBlurMaterial2.js
    │   │   │   ├── ChromaticAberrationMaterial.js
    │   │   │   ├── ColorLightingMaterial.js
    │   │   │   ├── ColorMaterial.js
    │   │   │   ├── CopyMaterial.js
    │   │   │   ├── DatamoshMaterial.js
    │   │   │   ├── DepthMaskMaterial.js
    │   │   │   ├── DepthMaterial.js
    │   │   │   ├── DiscardMaterial.js
    │   │   │   ├── DrawBuffersMaterial.js
    │   │   │   ├── FastGaussianBlurMaterial.js
    │   │   │   ├── FresnelMaterial.js
    │   │   │   ├── FXAAMaterial.js
    │   │   │   ├── GammaCorrectionMaterial.js
    │   │   │   ├── LensflareMaterial.js
    │   │   │   ├── LuminosityMaterial.js
    │   │   │   ├── MaskMaterial.js
    │   │   │   ├── Materials.js
    │   │   │   ├── MotionBlurCompositeMaterial.js
    │   │   │   ├── MotionBlurVelocityMaterial.js
    │   │   │   ├── NormalMaterial.js
    │   │   │   ├── PoissonDiscBlurMaterial.js
    │   │   │   ├── ReflectorBlurMaterial.js
    │   │   │   ├── ReflectorDudvMaterial.js
    │   │   │   ├── ReflectorMaterial.js
    │   │   │   ├── RGBMaterial.js
    │   │   │   ├── SceneCompositeAddMaterial.js
    │   │   │   ├── SceneCompositeDistortionMaterial.js
    │   │   │   ├── SceneCompositeMaterial.js
    │   │   │   ├── ShadowTextureMaterial.js
    │   │   │   ├── SinglePassBlurMaterial.js
    │   │   │   ├── SMAABlendMaterial.js
    │   │   │   ├── SMAAEdgesMaterial.js
    │   │   │   ├── SMAAWeightsMaterial.js
    │   │   │   ├── TextMaterial.js
    │   │   │   ├── TiltShiftMaterial.js
    │   │   │   ├── UnrealBloomBlurMaterial.js
    │   │   │   ├── UnrealBloomCompositeMaterial.js
    │   │   │   ├── VideoGlitchMaterial.js
    │   │   │   ├── VolumetricLightLensflareMaterial.js
    │   │   │   └── VolumetricLightMaterial.js
    │   │   └── utils
    │   │       ├── physics
    │   │       │   ├── OimoPhysics.js
    │   │       │   ├── OimoPhysicsBuffer.js
    │   │       │   └── OimoPhysicsController.js
    │   │       ├── DrawBuffers.js
    │   │       ├── Flowmap.js
    │   │       ├── Fluid.js
    │   │       ├── MotionBlur.js
    │   │       ├── Reflector.js
    │   │       ├── SoftShadows.js
    │   │       ├── Text.js
    │   │       └── Wobble.js
    │   ├── all.three.js
    │   ├── ogl.js
    │   ├── three.js
    │   └── three.oimophysics.js
    └── eslint.config.js



---
File: /examples/about/public/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="MVC design pattern and render pipeline.">
    <meta name="keywords" content="alien, alienjs, javascript, 3d, utilities, materials, shaders, physics, threejs, webgl, webgl2, websockets, creative coding">

    <title>Alien.js</title>

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://alien.js.org/">
    <meta property="og:site_name" content="Alien.js">
    <meta property="og:title" content="Alien.js">
    <meta property="og:description" content="MVC design pattern and render pipeline.">
    <meta property="og:image" content="https://alien.js.org/assets/meta/share.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@pschroen">
    <meta name="twitter:creator" content="@pschroen">

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="icon" type="image/svg+xml" href="assets/meta/favicon.svg">

    <script type="module">
        import { Preloader } from './assets/js/loader.js';

        Preloader.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/about/src/config/Config.js
---

export const isMobile = !!navigator.maxTouchPoints;

export const breakpoint = 1000;
export const numPointers = 22; // iOS limit

export const store = {
    users: [],
    sound: true,
    id: null,
    nickname: '',
    observer: false
};



---
File: /examples/about/src/controllers/audio/AudioController.js
---

import { WebAudio, clamp, tween } from '@alienkitty/space.js/three';

import { breakpoint, store } from '../../config/Config.js';

export class AudioController {
    static init(ui) {
        this.ui = ui;

        if (!store.sound) {
            WebAudio.mute(true);
        }

        this.map = new Map();
        this.multiplier = 8;
        this.easing = 0.97;
        this.lerpSpeed = 0.07;
        this.enabled = WebAudio.enabled;

        this.addListeners();
    }

    static addListeners() {
        document.addEventListener('visibilitychange', this.onVisibility);
        document.addEventListener('pointerdown', this.onPointerDown);
        window.addEventListener('beforeunload', this.onBeforeUnload);

        if (this.enabled || !store.sound) {
            return;
        }

        this.ui.instructions.animateIn(3000);
    }

    static getMouseSpeed(id, normalX, normalY) {
        const water = this.map.get(id);
        const time = performance.now() - water.lastEventTime;

        if (time === 0) {
            return water.mouseSpeed;
        }

        const distance = Math.abs(normalX - water.lastMouseX) + Math.abs(normalY - water.lastMouseY);
        const speed = distance / time;

        water.mouseSpeed += speed * this.multiplier;
        water.mouseSpeed *= this.easing;

        if (Math.abs(water.mouseSpeed) < 0.001) {
            water.mouseSpeed = 0;
        }

        water.lastEventTime = performance.now();
        water.lastMouseX = normalX;
        water.lastMouseY = normalY;

        return water.mouseSpeed;
    }

    // Event handlers

    static onVisibility = () => {
        if (!store.sound) {
            return;
        }

        if (document.hidden) {
            WebAudio.mute();
        } else {
            WebAudio.unmute();
        }
    };

    static onPointerDown = () => {
        this.enabled = true;

        document.removeEventListener('pointerdown', this.onPointerDown);

        WebAudio.resume();

        this.ui.instructions.animateOut();

        this.trigger('bass_drum');
    };

    static onBeforeUnload = () => {
        WebAudio.mute();
    };

    // Public methods

    static resize = () => {
        if (document.documentElement.clientWidth < breakpoint) {
            this.easing = 0.8;
        } else {
            this.easing = 0.97;
        }
    };

    static update = (id, x, y) => {
        if (!this.enabled) {
            return;
        }

        const normalX = x / document.documentElement.clientWidth;
        const normalY = y / document.documentElement.clientHeight;

        if (!this.map.has(id)) {
            const water = {};
            water.mouseSpeed = 0;
            water.lastEventTime = performance.now();
            water.lastMouseX = normalX;
            water.lastMouseY = normalY;
            water.sound = WebAudio.clone('water_loop', id);
            this.map.set(id, water);

            WebAudio.play(id, 0, true);
        }

        const speed = clamp(this.getMouseSpeed(id, normalX, normalY) * 0.5, 0, 1);
        const pan = clamp(((normalX * 2) - 1) * 0.8, -1, 1);
        const rate = clamp(0.8 + (1 - normalY) * 0.4, 0.8, 1.2);

        this.trigger('mouse_move', id, speed, pan, rate);
    };

    static trigger = (event, id, gain, pan, rate) => {
        switch (event) {
            case 'bass_drum':
                WebAudio.play('bass_drum').gain.fade(0, 2000);
                break;
            case 'fluid_start':
                WebAudio.fadeInAndPlay('deep_spacy_loop', 0.2, true, 2000, 'linear');
                break;
            case 'mouse_move': {
                const water = this.map.get(id);
                const sound = water && water.sound;

                if (sound && sound.isPlaying) {
                    sound.gain.value += (gain - sound.gain.value) * this.lerpSpeed;
                    sound.stereoPan.value += (pan - sound.stereoPan.value) * this.lerpSpeed;
                    sound.playbackRate.value += (rate - sound.playbackRate.value) * this.lerpSpeed;
                }
                break;
            }
            case 'about_section':
                tween(WebAudio.gain, { value: 0.3 }, 1000, 'easeOutSine');
                break;
            case 'fluid_section':
                tween(WebAudio.gain, { value: 1 }, 1000, 'easeOutSine');
                break;
            case 'sound_off':
                tween(WebAudio.gain, { value: 0 }, 500, 'easeOutSine');
                break;
            case 'sound_on':
                tween(WebAudio.gain, { value: this.ui.details.animatedIn ? 0.3 : 1 }, 500, 'easeOutSine');
                break;
        }
    };

    static remove = id => {
        this.map.delete(id);

        WebAudio.fadeOutAndStop(id, 500, 'easeOutSine', () => {
            WebAudio.remove(id);
        });
    };

    static start = () => {
        this.enabled = true;

        this.trigger('fluid_start');
    };

    static mute = () => {
        this.trigger('sound_off');
    };

    static unmute = () => {
        this.trigger('sound_on');
    };
}



---
File: /examples/about/src/controllers/panel/PanelController.js
---

import { PanelItem } from '@alienkitty/space.js/three';

// import { FluidController } from '../world/FluidController.js';

export class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        // const { passMaterial } = FluidController;

        const items = [
            {
                type: 'graph',
                name: 'FPS',
                noText: true,
                noHover: true
            },
            {
                type: 'graph',
                name: 'MS',
                range: 150,
                value: performance.now(),
                noHover: true,
                callback: (value, item) => {
                    const time = performance.now();
                    const ms = time - value;

                    item.update(ms);
                    item.setValue(ms);

                    return time;
                }
            }/* ,
            {
                type: 'slider',
                name: 'Viscosity',
                min: 0,
                max: 10,
                step: 0.1,
                value: passMaterial.uniforms.uDistortion.value,
                callback: value => {
                    passMaterial.uniforms.uDistortion.value = value;
                }
            } */
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}



---
File: /examples/about/src/controllers/world/FluidController.js
---

import { HalfFloatType, Vector2 } from 'three';
import { LinkedList, Reticle, Stage, getDoubleRenderTarget } from '@alienkitty/space.js/three';

import { Data } from '../../data/Data.js';
import { AudioController } from '../audio/AudioController.js';
import { FluidPassMaterial } from '../../materials/FluidPassMaterial.js';
import { FluidViewMaterial } from '../../materials/FluidViewMaterial.js';
import { DetailsUser } from '../../views/ui/DetailsUser.js';

import { numPointers, store } from '../../config/Config.js';

export class FluidController {
    static init(renderer, screen, screenCamera, trackers, ui) {
        this.renderer = renderer;
        this.screen = screen;
        this.screenCamera = screenCamera;
        this.trackers = trackers;
        this.ui = ui;

        this.list = new LinkedList();
        this.pointer = null;
        this.lerpSpeed = 0.07;
        this.enabled = false;

        this.initRenderer();
        this.initPointers();
    }

    static initRenderer() {
        // Render targets
        this.fluid = getDoubleRenderTarget(1, 1, {
            type: HalfFloatType,
            depthBuffer: false
        });

        // Fluid materials
        this.passMaterial = new FluidPassMaterial();
        this.viewMaterial = new FluidViewMaterial();
    }

    static initPointers() {
        for (let i = 0; i < numPointers; i++) {
            this.passMaterial.uniforms.uMouse.value[i] = new Vector2(0.5, 0.5);
            this.passMaterial.uniforms.uLast.value[i] = new Vector2(0.5, 0.5);
            this.passMaterial.uniforms.uVelocity.value[i] = new Vector2();
            this.passMaterial.uniforms.uStrength.value[i] = new Vector2();
        }

        const pointer = {};
        pointer.id = 'main';
        pointer.isMove = false;
        pointer.isDown = false;
        pointer.mouse = new Vector2();
        pointer.last = new Vector2();
        pointer.delta = new Vector2();

        if (!store.observer) {
            pointer.info = this.ui.detailsUsers.add(new DetailsUser());
        }

        this.list.push(pointer);

        this.pointer = pointer;
    }

    static addListeners() {
        Stage.events.on('update', this.onUsers);
        Data.Socket.on('motion', this.onMotion);

        if (store.observer) {
            this.ui.info.animateIn();
            return;
        }

        window.addEventListener('pointerdown', this.onPointerDown);
        window.addEventListener('pointermove', this.onPointerMove);
        window.addEventListener('pointerup', this.onPointerUp);
    }

    // Event handlers

    static onUsers = e => {
        if (!store.id) {
            return;
        }

        const ids = e.map(user => user.id);

        // New
        ids.forEach(id => {
            if (id === store.id) {
                return;
            }

            if (Number(id) !== numPointers && !this.list.find(pointer => pointer.id === id)) {
                const pointer = {};
                pointer.id = id;
                pointer.isMove = false;
                pointer.isDown = false;
                pointer.mouse = new Vector2();
                pointer.last = new Vector2();
                pointer.delta = new Vector2();
                pointer.target = new Vector2();

                pointer.tracker = this.trackers.add(new Reticle());
                pointer.tracker.id = id;

                pointer.info = this.ui.detailsUsers.add(new DetailsUser());

                if (this.ui.details.animatedIn) {
                    pointer.info.enable();
                    pointer.info.animateIn();
                }

                this.list.push(pointer);
            }
        });

        // Update and prune
        if (this.list.length) {
            let pointer = this.list.start();

            while (pointer) {
                if (pointer.id === 'main') {
                    if (pointer.info) {
                        pointer.info.setData(Data.getUserData(store.id));
                    }

                    pointer = this.list.next();
                    continue;
                }

                if (ids.includes(pointer.id)) {
                    pointer.tracker.setData(Data.getReticleData(pointer.id));
                    pointer.info.setData(Data.getUserData(pointer.id));
                } else {
                    const { id, tracker, info } = pointer;

                    tracker.animateOut(() => {
                        this.list.remove(pointer);

                        const i = Number(id);

                        this.passMaterial.uniforms.uMouse.value[i].set(0.5, 0.5);
                        this.passMaterial.uniforms.uLast.value[i].set(0.5, 0.5);
                        this.passMaterial.uniforms.uVelocity.value[i].set(0, 0);
                        this.passMaterial.uniforms.uStrength.value[i].set(0, 0);

                        AudioController.remove(id);

                        tracker.destroy();

                        info.animateOut(() => {
                            info.destroy();
                        });
                    });
                }

                pointer = this.list.next();
            }
        }
    };

    static onPointerDown = e => {
        if (!this.enabled) {
            return;
        }

        this.pointer.isDown = true;

        this.onPointerMove(e);
    };

    static onPointerMove = ({ clientX, clientY }) => {
        if (!this.enabled) {
            return;
        }

        const event = {
            x: clientX,
            y: clientY
        };

        this.pointer.isMove = true;
        this.pointer.mouse.copy(event);

        if (this.pointer.info) {
            this.pointer.info.setData({
                isDown: this.pointer.isDown,
                x: event.x / this.width,
                y: event.y / this.height
            });
        }

        this.send(event);
    };

    static onPointerUp = e => {
        if (!this.enabled) {
            return;
        }

        this.pointer.isDown = false;

        this.onPointerMove(e);
    };

    static onMotion = e => {
        if (!this.enabled) {
            return;
        }

        const pointer = this.list.find(pointer => pointer.id === e.id);

        if (pointer) {
            // First input
            if (!pointer.isMove) {
                pointer.isMove = true;
                pointer.isDown = e.isDown;
                pointer.target.set(e.x * this.width, e.y * this.height);
                pointer.mouse.copy(pointer.target);
                pointer.last.copy(pointer.mouse);

                pointer.tracker.css({ left: pointer.mouse.x, top: pointer.mouse.y });
                pointer.tracker.setData(Data.getReticleData(e.id));
                pointer.tracker.animateIn();

                AudioController.trigger('bass_drum');
            }

            // Update
            pointer.isDown = e.isDown;
            pointer.target.set(e.x * this.width, e.y * this.height);

            pointer.info.setData({
                isDown: e.isDown,
                x: e.x,
                y: e.y
            });
        }
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.width = width;
        this.height = height;

        this.fluid.setSize(width * dpr, height * dpr);

        this.pointer.mouse.set(width / 2, height / 2);
        this.pointer.last.copy(this.pointer.mouse);
    };

    static update = () => {
        if (!this.enabled) {
            return;
        }

        if (this.list.length) {
            let pointer = this.list.start();

            while (pointer) {
                if (pointer.id !== 'main') {
                    pointer.mouse.lerp(pointer.target, this.lerpSpeed);
                    pointer.tracker.css({ left: pointer.mouse.x, top: pointer.mouse.y });
                }

                if (!(store.observer && pointer.id === 'main')) {
                    pointer.delta.subVectors(pointer.mouse, pointer.last);
                    pointer.last.copy(pointer.mouse);

                    const distance = Math.min(10, pointer.delta.length()) / 10;

                    const i = pointer.id === 'main' ? Number(store.id) : Number(pointer.id);

                    this.passMaterial.uniforms.uLast.value[i].copy(this.passMaterial.uniforms.uMouse.value[i]);
                    this.passMaterial.uniforms.uMouse.value[i].set(pointer.mouse.x / this.width, (this.height - pointer.mouse.y) / this.height);
                    this.passMaterial.uniforms.uVelocity.value[i].copy(pointer.delta);
                    this.passMaterial.uniforms.uStrength.value[i].set((pointer.id === 'main' && !pointer.isMove) || pointer.isDown ? 50 : 50 * distance, 50 * distance);

                    AudioController.update(pointer.id, pointer.mouse.x, pointer.mouse.y);
                }

                pointer = this.list.next();
            }
        }

        // Fluid pass
        this.passMaterial.uniforms.tMap.value = this.fluid.read.texture;
        this.screen.material = this.passMaterial;
        this.renderer.setRenderTarget(this.fluid.write);
        this.renderer.render(this.screen, this.screenCamera);
        this.fluid.swap();

        // View pass (render to screen)
        this.viewMaterial.uniforms.tMap.value = this.fluid.read.texture;
        this.screen.material = this.viewMaterial;
        this.renderer.setRenderTarget(null);
        this.renderer.render(this.screen, this.screenCamera);
    };

    static send = e => {
        Data.Socket.motion({
            isDown: this.pointer.isDown,
            x: e.x / this.width,
            y: e.y / this.height
        });
    };

    static start = () => {
        this.addListeners();
    };

    static animateIn = () => {
        this.enabled = true;
    };
}



---
File: /examples/about/src/controllers/world/WorldController.js
---

import { ColorManagement, LinearSRGBColorSpace, Mesh, OrthographicCamera, Vector2, WebGLRenderer } from 'three';
import { getFullscreenTriangle } from '@alienkitty/space.js/three';

export class WorldController {
    static init() {
        this.initWorld();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            depth: false
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screenTriangle = getFullscreenTriangle();
        this.screen = new Mesh(this.screenTriangle, this.material);
        this.screen.frustumCulled = false;

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };
}



---
File: /examples/about/src/controllers/App.js
---

import { Interface, Stage, UI, WebAudio, clearTween, delayedCall, ticker, wait } from '@alienkitty/space.js/three';

import { Data } from '../data/Data.js';
import { AudioController } from './audio/AudioController.js';
import { WorldController } from './world/WorldController.js';
import { FluidController } from './world/FluidController.js';
import { PanelController } from './panel/PanelController.js';
import { TrackersView } from '../views/TrackersView.js';

import { breakpoint, store } from '../config/Config.js';

export class App {
    static async init(loader) {
        this.loader = loader;

        const sound = localStorage.getItem('sound');
        store.sound = sound ? JSON.parse(sound) : true;

        this.initWorld();
        this.initViews();

        await Data.Socket.ready();

        this.initControllers();

        this.addListeners();
        this.onResize();

        await Promise.all([
            document.fonts.ready,
            this.loader.ready()
        ]);

        this.initAudio();
        this.initPanel();

        FluidController.start();
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static initViews() {
        this.trackers = new TrackersView();
        Stage.add(this.trackers);

        this.ui = new UI({
            fps: true,
            breakpoint,
            header: {
                links: [
                    {
                        title: 'Alien.js',
                        link: 'https://github.com/alienkitty/alien.js'
                    }
                ]
            },
            info: {
                content: 'Observer'
            },
            details: {
                background: true,
                title: 'Multiuser Fluid'.replace(/[\s.-]+/g, '_'),
                content: [
                    {
                        content: /* html */ `
<p>A fluid shader tribute to Mr.doob’s Multiuser Sketchpad from 2010. Multiuser Fluid is an experiment to combine UI and data visualization elements in a multiuser environment.</p>
                        `,
                        links: [
                            {
                                title: 'Mr.doob’s Multiuser Sketchpad',
                                link: 'https://multiuser-sketchpad.glitch.me/'
                            },
                            {
                                title: 'David A Roberts’ Single-pass Fluid Solver',
                                link: 'https://www.shadertoy.com/view/XlsBDf'
                            },
                            {
                                title: 'Source code',
                                link: 'https://github.com/pschroen/multiuser-fluid'
                            }
                        ]
                    },
                    {
                        title: 'Development',
                        content: /* html */ `
Space.js
<br>Alien.js
<br>Three.js
                        `
                    },
                    {
                        title: 'Fonts',
                        content: /* html */ `
Roboto
<br>Roboto Mono
<br>Gothic A1
                        `
                    },
                    {
                        title: 'Audio',
                        content: /* html */ `
AudioMicro
                        `
                    },
                    {
                        title: 'Users',
                        width: '100%'
                    }
                ]
            },
            instructions: {
                content: `${navigator.maxTouchPoints ? 'Tap' : 'Click'} for sound`
            },
            detailsButton: true,
            muteButton: {
                sound: store.sound
            }
        });
        this.ui.css({ position: 'static' });
        Stage.add(this.ui);

        const content = new Interface('.content');
        content.css({
            width: 'fit-content'
        });
        this.ui.detailsUsers = this.ui.details.content[this.ui.details.content.length - 1].add(content);
        this.ui.detailsUsers.css({
            position: 'relative',
            display: 'flex',
            flexWrap: 'wrap',
            gap: 12
        });
    }

    static initControllers() {
        const { renderer, screen, screenCamera } = WorldController;

        FluidController.init(renderer, screen, screenCamera, this.trackers, this.ui);
    }

    static initAudio() {
        WebAudio.init({ sampleRate: 48000 });
        WebAudio.load(this.loader.files);

        AudioController.init(this.ui);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        Stage.events.on('update', this.onUsers);
        Stage.events.on('details', this.onDetails);
        this.ui.muteButton.events.on('update', this.onMute);
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onUsers = e => {
        this.ui.detailsButton.setData({ number: e.length });
    };

    static onDetails = ({ open }) => {
        clearTween(this.timeout);

        if (open) {
            document.documentElement.classList.add('scroll');

            this.ui.detailsUsers.children.forEach((child, i) => {
                child.enable();
                child.animateIn(1075 + i * 15, true);
            });

            if (store.sound) {
                AudioController.trigger('about_section');
            }
        } else {
            this.timeout = delayedCall(400, () => {
                document.documentElement.classList.remove('scroll');

                this.ui.detailsUsers.children.forEach(child => {
                    child.disable();
                });
            });

            if (store.sound) {
                AudioController.trigger('fluid_section');
            }
        }
    };

    static onMute = ({ sound }) => {
        if (sound) {
            AudioController.unmute();
        } else {
            AudioController.mute();
        }

        localStorage.setItem('sound', JSON.stringify(sound));

        store.sound = sound;
    };

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = 1; // Always 1

        AudioController.resize();
        WorldController.resize(width, height, dpr);
        FluidController.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        FluidController.update();
        this.ui.update();
    };

    // Public methods

    static start = async () => {
        AudioController.start();
    };

    static animateIn = async () => {
        FluidController.animateIn();

        await wait(1000);

        this.ui.animateIn();
    };
}



---
File: /examples/about/src/controllers/Preloader.js
---

import { BufferLoader, MultiLoader, Stage } from '@alienkitty/space.js/three';

import { Data } from '../data/Data.js';
import { PreloaderView } from '../views/PreloaderView.js';

export class Preloader {
    static init() {
        Data.init();
        Data.Socket.init();

        this.initStage();
        this.initView();
        this.initLoader();

        this.addListeners();
    }

    static initStage() {
        Stage.init();
    }

    static initView() {
        this.view = new PreloaderView();
        Stage.add(this.view);
    }

    static async initLoader() {
        this.view.animateIn();

        const bufferLoader = new BufferLoader();
        bufferLoader.setPath('assets/sounds/');
        bufferLoader.loadAll([
            'bass_drum.mp3',
            'deep_spacy_loop.mp3',
            'water_loop.mp3'
        ]);

        this.loader = new MultiLoader();
        this.loader.load(bufferLoader);
        this.loader.add(2);

        const { App } = await import('./App.js');
        this.loader.trigger(1);

        this.app = App;

        await this.app.init(bufferLoader);
        this.loader.trigger(1);
    }

    static addListeners() {
        this.loader.events.on('progress', this.view.onProgress);
        this.view.events.on('complete', this.onComplete);
    }

    static removeListeners() {
        this.loader.events.off('progress', this.view.onProgress);
        this.view.events.off('complete', this.onComplete);
    }

    // Event handlers

    static onComplete = async () => {
        this.removeListeners();

        this.loader = this.loader.destroy();

        this.app.start();

        await this.view.animateOut();
        this.view = this.view.destroy();

        this.app.animateIn();
    };
}



---
File: /examples/about/src/data/Data.js
---

import { Socket } from './Socket.js';

import { numPointers, store } from '../config/Config.js';

export class Data {
    static init() {
        this.Socket = new Socket();
    }

    // Public methods

    static getUser = id => {
        return store.users.find(item => item.id === id);
    };

    static getUserData = id => {
        const data = this.getUser(id);

        if (!data) {
            return;
        }

        return {
            id: data.id,
            nickname: data.nickname || (Number(data.id) === numPointers ? 'Observer' : data.id),
            // remoteAddress: data.remoteAddress,
            latency: data.latency
        };
    };

    static getReticleData = id => {
        const data = this.getUser(id);

        if (!data) {
            return;
        }

        return {
            // primary: data.nickname || data.remoteAddress,
            primary: data.nickname || data.id,
            secondary: `${data.latency}ms`
        };
    };
}



---
File: /examples/about/src/data/Socket.js
---

import { EventEmitter, Stage } from '@alienkitty/space.js/three';

import { numPointers, store } from '../config/Config.js';

export class Socket extends EventEmitter {
    constructor() {
        super();

        this.views = [];
        // 0: USERS: EVENT_ID(UINT8), MOUSE_ID(UINT8), NICKNAME(UINT8), REMOTE_ADDRESS(UINT32), LATENCY(UINT16)
        // 1: HEARTBEAT: EVENT_ID(UINT8), MOUSE_ID(UINT8), TIME(UINT64)
        // 2: NICKNAME: EVENT_ID(UINT8), MOUSE_ID(UINT8), NICKNAME(UINT8)
        this.views[2] = new DataView(new ArrayBuffer(1 + 1 + 10));
        // 3: MOTION: EVENT_ID(UINT8), MOUSE_ID(UINT8), IS_DOWN(UINT8), X(FLOAT32), Y(FLOAT32)
        this.views[3] = new DataView(new ArrayBuffer(1 + 1 + 1 + 4 + 4));

        this.encoder = new TextEncoder();
        this.decoder = new TextDecoder();

        this.connected = false;

        this.promise = new Promise(resolve => this.resolve = resolve);
    }

    init() {
        this.server = 'wss://multiuser-fluid.glitch.me';

        this.connect();
    }

    addListeners() {
        this.socket.addEventListener('close', this.onClose);
        this.socket.addEventListener('message', this.onMessage);
        this.on('users', this.onUsers);
        this.on('heartbeat', this.onHeartbeat);
    }

    removeListeners() {
        this.socket.removeEventListener('close', this.onClose);
        this.socket.removeEventListener('message', this.onMessage);
        this.off('users', this.onUsers);
        this.off('heartbeat', this.onHeartbeat);
    }

    ip2long(ip) {
        let ipl = 0;

        ip.split('.').forEach(octet => {
            ipl <<= 8;
            ipl += parseInt(octet, 10);
        });

        return ipl >>> 0;
    }

    long2ip(ipl) {
        return (ipl >>> 24) + '.' + (ipl >> 16 & 255) + '.' + (ipl >> 8 & 255) + '.' + (ipl & 255);
    }

    // Event handlers

    onClose = () => {
        this.connected = false;
    };

    onMessage = ({ data }) => {
        data = new DataView(data);

        switch (data.getUint8(0)) {
            case 0: {
                const users = [];
                const byteLength = 1 + 10 + 4 + 2;

                let index = 1;

                for (let i = 0, l = (data.byteLength - 1) / byteLength; i < l; i++) {
                    const id = data.getUint8(index).toString();
                    const nickname = this.decoder.decode(data.buffer.slice(index + 1, index + 11)).replace(/\0/g, '');
                    const remoteAddress = this.long2ip(data.getUint32(index + 11));
                    const latency = data.getUint16(index + 15);

                    users.push({ id, nickname, remoteAddress, latency });

                    index += byteLength;
                }

                this.emit('users', { users });
                break;
            }
            case 1: {
                const id = data.getUint8(1).toString();
                const time = Number(data.getBigInt64(2));

                this.emit('heartbeat', { id, time });

                this.send(data);
                break;
            }
            case 3: {
                const id = data.getUint8(1).toString();
                const isDown = !!data.getUint8(2);
                const x = data.getFloat32(3);
                const y = data.getFloat32(7);

                this.emit('motion', { id, isDown, x, y });
                break;
            }
        }
    };

    onUsers = ({ users }) => {
        store.users = users;

        Stage.events.emit('update', users);
    };

    onHeartbeat = ({ id/* , time */ }) => {
        if (!this.connected) {
            this.connected = true;
            // this.id = id;

            store.id = id;

            if (Number(id) === numPointers) {
                store.observer = true;
            }

            this.nickname(store.nickname);

            this.resolve();
        }
    };

    // Public methods

    nickname = text => {
        const view = this.views[2];
        view.setUint8(0, 2);
        // view.setUint8(1, this.id); // Set server-side

        const buf = this.encoder.encode(text);

        for (let i = 0; i < 10; i++) {
            view.setUint8(2 + i, buf[i]);
        }

        this.send(view);
    };

    motion = ({ isDown, x, y }) => {
        const view = this.views[3];
        view.setUint8(0, 3);
        // view.setUint8(1, this.id); // Set server-side
        view.setUint8(2, isDown ? 1 : 0);
        view.setFloat32(3, x);
        view.setFloat32(7, y);

        this.send(view);
    };

    send = view => {
        if (!this.connected) {
            return;
        }

        this.socket.send(view.buffer);
    };

    connect = () => {
        if (this.socket) {
            this.close();
        }

        this.socket = new WebSocket(this.server, ['permessage-deflate']);
        this.socket.binaryType = 'arraybuffer';

        this.addListeners();
    };

    close = () => {
        this.removeListeners();

        this.socket.close();
    };

    ready = () => this.promise;
}



---
File: /examples/about/src/materials/FluidPassMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { WorldController } from '../controllers/world/WorldController.js';

import { numPointers } from '../config/Config.js';

// Based on https://www.shadertoy.com/view/XlsBDf by davidar

const vertexShader = /* glsl */ `
in vec3 position;

void main() {
    gl_Position = vec4(position, 1.0);
}
`;

const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform vec2 uMouse[NUM_POINTERS];
uniform vec2 uLast[NUM_POINTERS];
uniform vec2 uVelocity[NUM_POINTERS];
uniform vec2 uStrength[NUM_POINTERS];
uniform vec2 uResolution;
uniform int uFrame;

out vec4 FragColor;

#define T(p) texture(tMap, (p) / uResolution.xy)
#define length2(p) dot(p, p)

#define dt 0.15
#define K 0.2
#define nu 0.5
#define kappa 0.1

void main() {
    if (uFrame < 10) {
        FragColor = vec4(0, 0, 1, 0);
        return;
    }

    vec2 p = gl_FragCoord.xy;
    vec4 c = T(p);

    vec4 n = T(p + vec2(0, 1));
    vec4 e = T(p + vec2(1, 0));
    vec4 s = T(p - vec2(0, 1));
    vec4 w = T(p - vec2(1, 0));

    vec4 laplacian = (n + e + s + w - 4.0 * c);

    vec4 dx = (e - w) / 2.0;
    vec4 dy = (n - s) / 2.0;

    // Velocity field divergence
    float div = dx.x + dy.y;

    // Mass conservation, Euler method step
    c.z -= dt * (dx.z * c.x + dy.z * c.y + div * c.z);

    // Semi-Langrangian advection
    c.xyw = T(p - dt * c.xy).xyw;

    // Viscosity/diffusion
    c.xyw += dt * vec3(nu, nu, kappa) * laplacian.xyw;

    // Nullify divergence with pressure field gradient
    c.xy -= K * vec2(dx.z, dy.z);

    // External source
    for (int i = 0; i < NUM_POINTERS; i++) {
        if (uStrength[i].x == 0.0 && uStrength[i].y == 0.0) continue;

        // Add iterations between the last and current mouse position, smoothing-out the mouse trail
        vec2 pos = uLast[i].xy;
        float iterations = clamp((length(uVelocity[i]) / 40.0) * MAX_ITERATIONS, 1.0, MAX_ITERATIONS);

        for (float j = 0.0; j < MAX_ITERATIONS; j++) {
            if (j >= iterations) break;

            pos += (uMouse[i].xy - pos.xy) * ((j + 1.0) / iterations);
            vec2 m = pos.xy * uResolution.xy;
            c.xyw += dt * exp(-length2(p - m) / uStrength[i].x) * vec3(p - m + (uVelocity[i].xy * uStrength[i].y), 1);
        }
    }

    // Dissipation
    c.w -= dt * 0.0005;

    FragColor = clamp(c, vec4(-5, -5, 0.5, 0), vec4(5, 5, 3, 5));
}
`;

export class FluidPassMaterial extends RawShaderMaterial {
    constructor() {
        const { resolution, frame } = WorldController;

        super({
            glslVersion: GLSL3,
            defines: {
                NUM_POINTERS: numPointers,
                MAX_ITERATIONS: '5.0'
            },
            uniforms: {
                tMap: { value: null },
                uMouse: { value: [] },
                uLast: { value: [] },
                uVelocity: { value: [] },
                uStrength: { value: [] },
                uResolution: resolution,
                uFrame: frame
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /examples/about/src/materials/FluidViewMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { WorldController } from '../controllers/world/WorldController.js';

// Based on https://www.shadertoy.com/view/XlsBDf by davidar

const vertexShader = /* glsl */ `
in vec3 position;

void main() {
    gl_Position = vec4(position, 1.0);
}
`;

const fragmentShader = /* glsl */ `
precision highp float;

#define TWO_PI 6.28

uniform sampler2D tMap;
uniform vec2 uResolution;

out vec4 FragColor;

void main() {
    vec4 c = texture(tMap, gl_FragCoord.xy / uResolution.xy);

    // Velocity
    FragColor.rgb = 0.6 + 0.6 * cos(6.3 * atan(c.y, c.x) / TWO_PI + vec3(0, 23, 21));

    // Ink
    FragColor.rgb *= c.w / 5.0;

    // Local fluid density
    FragColor.rgb += clamp(c.z - 1.0, 0.0, 1.0) / 10.0;
    FragColor.a = 1.0;
}
`;

export class FluidViewMaterial extends RawShaderMaterial {
    constructor() {
        const { resolution } = WorldController;

        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uResolution: resolution
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /examples/about/src/views/ui/DetailsUser.js
---

import { Graph, Interface, Stage, ticker } from '@alienkitty/space.js/three';

export class DetailsUser extends Interface {
    constructor() {
        super('.user');

        this.infoWidth = parseFloat(Stage.rootStyle.getPropertyValue('--ui-panel-width').trim());
        this.width = this.infoWidth * 2;
        this.height = 60;
        this.hoveredIn = false;

        this.data = {
            id: '',
            nickname: '',
            latency: 0,
            isDown: '',
            x: 0,
            y: 0
        };

        this.init();

        this.update();
    }

    init() {
        this.invisible();
        this.css({
            position: 'relative',
            width: this.width,
            height: this.height
        });

        this.graph = new Graph({
            width: this.width - this.infoWidth,
            height: this.height,
            range: 300,
            suffix: 'ms',
            ghost: true,
            noMarker: true
        });
        this.add(this.graph);

        this.container = new Interface('.container');
        this.container.css({
            position: 'absolute',
            left: 0,
            top: 0,
            width: this.width,
            height: this.height,
            pointerEvents: 'none',
            webkitUserSelect: 'none',
            userSelect: 'none'
        });
        this.add(this.container);

        this.content = new Interface('.content', 'pre');
        this.content.css({
            position: 'absolute',
            left: 0,
            top: 0,
            width: this.graph.width,
            height: this.height
        });
        this.container.add(this.content);

        this.info = new Interface('.info', 'pre');
        this.info.css({
            position: 'absolute',
            left: this.graph.width + 10,
            top: 0,
            width: this.infoWidth - 10,
            height: this.height
        });
        this.container.add(this.info);
    }

    addListeners() {
        this.element.addEventListener('mouseenter', this.onHover);
        this.element.addEventListener('mouseleave', this.onHover);
        this.graph.element.addEventListener('mouseenter', this.onGraphHover);
        this.graph.element.addEventListener('mouseleave', this.onGraphHover);
        ticker.add(this.onUpdate);
    }

    removeListeners() {
        this.element.removeEventListener('mouseenter', this.onHover);
        this.element.removeEventListener('mouseleave', this.onHover);
        this.graph.element.removeEventListener('mouseenter', this.onGraphHover);
        this.graph.element.removeEventListener('mouseleave', this.onGraphHover);
        ticker.remove(this.onUpdate);
    }

    // Event handlers

    onHover = ({ type }) => {
        if (type === 'mouseenter') {
            Stage.events.emit('tracker', { select: this.data.id });
        } else {
            Stage.events.emit('tracker', { select: null });
        }
    };

    onGraphHover = ({ type }) => {
        if (type === 'mouseenter') {
            this.hoveredIn = true;
        } else {
            this.hoveredIn = false;
        }
    };

    onUpdate = () => {
        if (this.graph.needsUpdate || this.hoveredIn) {
            this.graph.update();
        }
    };

    // Public methods

    setData = data => {
        Object.assign(this.data, data);

        if (data.id) {
            this.content.text(`${this.data.nickname}
${this.data.latency}ms`);

            this.update();
        }

        this.info.text(`Mouse:  ${this.data.id}${this.data.isDown ? ' Down' : ''}
X:${this.data.x.toFixed(4).padStart(12, ' ')}
Y:${this.data.y.toFixed(4).padStart(12, ' ')}`);
    };

    update = () => {
        this.graph.update(this.data.latency);
    };

    animateIn = (delay, fast) => {
        this.clearTween();
        this.visible();

        this.graph.animateIn();

        if (fast) {
            this.css({ opacity: 0 }).tween({ opacity: 1 }, 400, 'easeOutCubic', delay);
        } else {
            this.css({ y: -10, opacity: 0 }).tween({ y: 0, opacity: 1 }, 400, 'easeOutCubic', delay);
        }
    };

    animateOut = callback => {
        this.graph.animateOut();

        this.clearTween().tween({ opacity: 0 }, 500, 'easeInCubic', () => {
            this.invisible();

            if (callback) {
                callback();
            }
        });
    };

    enable = () => {
        this.addListeners();
    };

    disable = () => {
        this.removeListeners();
    };

    destroy = () => {
        this.disable();

        return super.destroy();
    };
}



---
File: /examples/about/src/views/PreloaderView.js
---

import { Interface, ProgressCanvas } from '@alienkitty/space.js/three';

export class PreloaderView extends Interface {
    constructor() {
        super('.preloader');

        this.init();
        this.initView();

        this.addListeners();
    }

    init() {
        this.css({
            position: 'fixed',
            left: 0,
            top: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'var(--bg-color)',
            zIndex: 100,
            pointerEvents: 'none'
        });
    }

    initView() {
        this.view = new ProgressCanvas();
        this.view.css({
            position: 'absolute',
            left: '50%',
            top: '50%',
            marginLeft: -this.view.width / 2,
            marginTop: -this.view.height / 2
        });
        this.add(this.view);
    }

    addListeners() {
        this.view.events.on('complete', this.onComplete);
    }

    removeListeners() {
        this.view.events.off('complete', this.onComplete);
    }

    // Event handlers

    onProgress = e => {
        this.view.onProgress(e);
    };

    onComplete = () => {
        this.events.emit('complete');
    };

    // Public methods

    animateIn = () => {
        this.view.animateIn();
    };

    animateOut = () => {
        this.view.animateOut();
        return this.tween({ opacity: 0 }, 250, 'easeOutSine', 500);
    };

    destroy = () => {
        this.removeListeners();

        return super.destroy();
    };
}



---
File: /examples/about/src/views/TrackersView.js
---

import { Interface, Stage, clearTween, delayedCall } from '@alienkitty/space.js/three';

export class TrackersView extends Interface {
    constructor() {
        super('.trackers');

        this.init();

        this.addListeners();
    }

    init() {
        this.css({
            position: 'fixed',
            left: 0,
            top: 0,
            width: '100%',
            height: '100%',
            pointerEvents: 'none',
            webkitUserSelect: 'none',
            userSelect: 'none'
        });
    }

    addListeners() {
        Stage.events.on('tracker', this.onTracker);
    }

    // Event handlers

    onTracker = ({ select }) => {
        clearTween(this.timeout);

        if (select) {
            this.children.filter(child => child.id !== select).forEach(child => child.deactivate());
            this.children.filter(child => child.id === select).forEach(child => child.activate());
        } else {
            this.timeout = delayedCall(200, () => {
                this.children.forEach(child => child.activate());
            });
        }
    };
}



---
File: /examples/about/src/main.js
---

export { Preloader } from './controllers/Preloader.js';



---
File: /examples/about/rollup.config.js
---

import resolve from '@rollup/plugin-node-resolve';
import { terser, timestamp } from 'rollup-plugin-bundleutils';

const production = !process.env.ROLLUP_WATCH;

export default {
  input: 'src/main.js',
  preserveEntrySignatures: 'allow-extension',
  output: {
    dir: 'public/assets/js',
    entryFileNames: 'loader.js',
    chunkFileNames: ({ name }) => `${name.toLowerCase()}.js`,
    format: 'es',
    minifyInternalExports: false
  },
  plugins: [
    resolve({
      browser: true
    }),
    production && terser({
      // Keep class and function names when using `Thread` from Space.js
      // keep_classnames: true,
      // keep_fnames: true,
      output: {
        preamble: `// ${timestamp()}`
      }
    })
  ]
};



---
File: /examples/ogl/shader_fxaa.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>OGL FXAA Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="importmap">
        {
            "imports": {
                "ogl": "https://unpkg.com/ogl",
                "@alienkitty/space.js": "https://unpkg.com/@alienkitty/space.js/src/index.js",
                "@alienkitty/alien.js/ogl": "../../src/ogl.js"
            }
        }
    </script>

    <script type="module">
        import { Camera, Color, Mesh, Program, RenderTarget, Renderer, Sphere, Transform, Triangle, Vec2 } from 'ogl';
        import { PanelItem, UI, getKeyByValue, ticker } from '@alienkitty/space.js';
        import { FXAAProgram } from '@alienkitty/alien.js/ogl';

        const colors = {
            backgroundColor: new Color('#060606')
        };

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Transform {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { gl, time } = WorldController;

                const geometry = new Sphere(gl, { radius: 1, widthSegments: 80, heightSegments: 80 });

                // Based on https://oframe.github.io/ogl/examples/?src=helpers.html by gordonnl
                // Based on https://github.com/spite/perlin-experiments

                const program = new Program(gl, {
                    uniforms: {
                        uTime: time
                    },
                    vertex: /* glsl */ `#version 300 es
                        in vec3 position;
                        in vec3 normal;

                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform mat3 normalMatrix;

                        uniform float uTime;

                        out vec3 vNormal;

                        ${periodic3d}

                        void main() {
                            vNormal = normalize(normalMatrix * normal);

                            float f = 0.05 * pnoise(vec3(2.0 * normal + uTime), vec3(10.0));

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position + f * normal, 1.0);
                        }
                    `,
                    fragment: /* glsl */ `#version 300 es
                        precision highp float;

                        in vec3 vNormal;

                        out vec4 FragColor;

                        void main() {
                            vec3 normal = normalize(vNormal);
                            float lighting = dot(normal, normalize(vec3(1.0, 1.0, 1.0)));

                            FragColor.rgb = vec3(0.75) + lighting * 0.25;
                            FragColor.a = 1.0;
                        }
                    `
                });

                const mesh = new Mesh(gl, { geometry, program });
                this.addChild(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const postOptions = {
                    Off: false,
                    FXAA: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: value => {
                            RenderManager.enabled = postOptions[value];
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { gl, screenTriangle: geometry, resolution } = WorldController;

                // Fullscreen triangle
                this.screen = new Mesh(gl, { geometry });
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new RenderTarget(gl);

                // FXAA program
                this.fxaaProgram = new FXAAProgram(gl);
                this.fxaaProgram.uniforms.tMap.value = this.renderTarget.texture;
                this.fxaaProgram.uniforms.uResolution = resolution;
                this.screen.program = this.fxaaProgram;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.dpr = dpr;
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.render({ scene, camera });
                    return;
                }

                // Scene pass
                renderer.render({ scene, camera, target: this.renderTarget });

                // FXAA pass (render to screen)
                renderer.render({ scene: this.screen });
            };
        }

        class WorldController {
            static init() {
                this.initWorld();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new Renderer({
                    powerPreference: 'high-performance'
                });
                this.gl = this.renderer.gl;

                // Output canvas
                this.element = this.gl.canvas;

                // Clear color
                this.gl.clearColor(...colors.backgroundColor, 1);

                // 3D scene
                this.scene = new Transform();
                this.camera = new Camera(this.gl, { fov: 30, near: 0.5, far: 40 });
                this.camera.position.z = 8;
                this.camera.lookAt([0, 0, 0]);

                // Global geometries
                this.screenTriangle = new Triangle(this.gl);

                // Global uniforms
                this.resolution = { value: new Vec2() };
                this.texelSize = { value: new Vec2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static addListeners() {
                this.gl.canvas.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.perspective();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.addChild(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/camera/abstract_cube/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Abstract Cube — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/camera/style.css">

    <script type="module" src="/examples/three/transitions/camera/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/camera/dark_planet/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Dark Planet — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/camera/style.css">

    <script type="module" src="/examples/three/transitions/camera/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/camera/floating_crystal/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Floating Crystal — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/camera/style.css">

    <script type="module" src="/examples/three/transitions/camera/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/camera/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Camera Transition — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/camera/style.css">

    <script type="module" src="/examples/three/transitions/camera/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/camera/main.js
---

import { AdditiveBlending, AssetLoader, BasicShadowMap, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, CopyMaterial, DepthMaterial, DirectionalLight, DisplayOptions, DrawBuffers, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MapControls, MathUtils, Mesh, MeshBasicMaterial, MeshMatcapMaterial, MeshStandardMaterial, MotionBlurCompositeMaterial, NearestFilter, NoBlending, NormalMaterial, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Point3D, RawShaderMaterial, Reflector, RepeatWrapping, Scene, SceneCompositeMaterial, ShadowMaterial, Stage, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, clearTween, delayedCall, getFullscreenTriangle, getKeyByValue, lerpCameras, router, ticker, tween } from '../../../../build/alien.three.js';

const isDebug = /[?&]debug/.test(location.search);

const basePath = '/examples/three/transitions/camera';
const breakpoint = 1000;

const layers = {
    default: 0,
    buffers: 1
};

const params = {
    animate: true,
    speed: 1
};

class Page {
    constructor({ path, title }) {
        this.path = path;
        this.title = title;

        document.title = `${this.title} — Alien.js`;
    }
}

class Data {
    static init({ pages }) {
        this.pages = pages;
    }

    // Public methods

    static getNext = page => {
        let index = this.pages.indexOf(page);

        if (!~index || ++index > this.pages.length - 1) {
            index = 0;
        }

        return this.pages[index];
    };
}

import smootherstep from '../../../../src/shaders/modules/smootherstep/smootherstep.glsl.js';
import rotateUV from '../../../../src/shaders/modules/transformUV/rotateUV.glsl.js';
import rgbshift from '../../../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
import dither from '../../../../src/shaders/modules/dither/dither.glsl.js';

class CompositeMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tScene: { value: null },
                uFocus: { value: 0.5 },
                uRotation: { value: 0 },
                uBlurAmount: { value: 1 },
                uRGBAmount: { value: 1.5 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tScene;
                uniform float uFocus;
                uniform float uRotation;
                uniform float uBlurAmount;
                uniform float uRGBAmount;

                in vec2 vUv;

                out vec4 FragColor;

                ${smootherstep}
                ${rotateUV}
                ${rgbshift}
                ${dither}

                void main() {
                    float d = abs(uFocus - rotateUV(vUv, uRotation).y);
                    float t = smootherstep(0.0, 1.0, d);

                    float angle = length(vUv - 0.5);
                    float amount = 0.002 * uRGBAmount * uBlurAmount * t;

                    FragColor += getRGB(tScene, vUv, angle, amount);

                    FragColor.rgb = dither(FragColor.rgb);
                    FragColor.a = 1.0;
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

import blur from '../../../../src/shaders/modules/blur/blur.glsl.js';
import blueNoise from '../../../../src/shaders/modules/noise/blue-noise.glsl.js';

class BlurMaterial extends RawShaderMaterial {
    constructor(direction = new Vector2(0.5, 0.5)) {
        const { getTexture } = WorldController;

        const texture = getTexture('blue_noise.png');
        texture.wrapS = RepeatWrapping;
        texture.wrapT = RepeatWrapping;
        texture.magFilter = NearestFilter;
        texture.minFilter = NearestFilter;
        texture.generateMipmaps = false;

        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                tBlueNoise: { value: texture },
                uBlueNoiseResolution: { value: new Vector2(256, 256) },
                uFocus: { value: 0.5 },
                uRotation: { value: 0 },
                uBlurAmount: { value: 1 },
                uDirection: { value: direction },
                uDebug: { value: isDebug },
                uResolution: { value: new Vector2() },
                uTime: { value: 0 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tMap;
                uniform sampler2D tBlueNoise;
                uniform vec2 uBlueNoiseResolution;
                uniform float uFocus;
                uniform float uRotation;
                uniform float uBlurAmount;
                uniform vec2 uDirection;
                uniform bool uDebug;
                uniform vec2 uResolution;
                uniform float uTime;

                in vec2 vUv;

                out vec4 FragColor;

                vec2 rot2d(vec2 p, float a) {
                    vec2 sc = vec2(sin(a), cos(a));
                    return vec2(dot(p, vec2(sc.y, -sc.x)), dot(p, sc.xy));
                }

                ${smootherstep}
                ${rotateUV}
                ${blur}
                ${blueNoise}

                void main() {
                    float d = abs(uFocus - rotateUV(vUv, uRotation).y);
                    float t = smootherstep(0.0, 1.0, d);
                    float rnd = getBlueNoise(tBlueNoise, gl_FragCoord.xy, uBlueNoiseResolution, vec2(fract(uTime)));

                    FragColor = blur(tMap, vUv, uResolution, 20.0 * uBlurAmount * t * rot2d(uDirection, rnd));

                    if (uDebug) {
                        FragColor.rgb = mix(FragColor.rgb, mix(FragColor.rgb, vec3(1), 0.5), uBlurAmount * t);
                    }
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

class AbstractCube extends Group {
    constructor() {
        super();

        this.position.x = 2.5;

        this.initCamera();
    }

    initCamera() {
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;
        this.camera.zoom = 1.5;
        this.camera.lookAt(this.position.x - 1.2, this.position.y, 0);
        this.camera.matrixAutoUpdate = false;
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            name: 'Abstract Cube',
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true,
            polygonOffset: true,
            polygonOffsetFactor: 1,
            polygonOffsetUnits: 1
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.layers.enable(layers.buffers);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    resize = (width, height) => {
        this.camera.aspect = width / height;

        if (width < breakpoint) {
            this.camera.lookAt(this.position.x, this.position.y, 0);
            this.camera.zoom = 1;
        } else {
            this.camera.lookAt(this.position.x - 1.2, this.position.y, 0);
            this.camera.zoom = 1.5;
        }

        this.camera.updateProjectionMatrix();
    };

    update = () => {
        this.mesh.rotation.y -= 0.005 * params.speed;
    };

    ready = () => this.initMesh();
}

class FloatingCrystal extends Group {
    constructor() {
        super();

        this.position.y = 0.7;

        this.initCamera();
    }

    initCamera() {
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;
        this.camera.zoom = 1.5;
        this.camera.lookAt(this.position.x - 1.3, this.position.y, 0);
        this.camera.matrixAutoUpdate = false;
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            name: 'Floating Crystal',
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true,
            polygonOffset: true,
            polygonOffsetFactor: 1,
            polygonOffsetUnits: 1
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.layers.enable(layers.buffers);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    resize = (width, height) => {
        this.camera.aspect = width / height;

        if (width < breakpoint) {
            this.camera.lookAt(this.position.x, this.position.y, 0);
            this.camera.zoom = 1;
        } else {
            this.camera.lookAt(this.position.x - 1.3, this.position.y, 0);
            this.camera.zoom = 1.5;
        }

        this.camera.updateProjectionMatrix();
    };

    update = time => {
        this.mesh.position.y = (1 + Math.sin(time * params.speed)) * 0.1;
        this.mesh.rotation.y += 0.01 * params.speed;
    };

    ready = () => this.initMesh();
}

class DarkPlanet extends Group {
    constructor() {
        super();

        this.position.x = -2.5;

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);

        this.initCamera();
    }

    initCamera() {
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;
        this.camera.zoom = 1.5;
        this.camera.lookAt(this.position.x - 1.4, this.position.y, 0);
        this.camera.matrixAutoUpdate = false;
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            name: 'Dark Planet',
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3),
            polygonOffset: true,
            polygonOffsetFactor: 1,
            polygonOffsetUnits: 1
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.layers.enable(layers.buffers);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    resize = (width, height) => {
        this.camera.aspect = width / height;

        if (width < breakpoint) {
            this.camera.lookAt(this.position.x, this.position.y, 0);
            this.camera.zoom = 1;
        } else {
            this.camera.lookAt(this.position.x - 1.4, this.position.y, 0);
            this.camera.zoom = 1.5;
        }

        this.camera.updateProjectionMatrix();
    };

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005 * params.speed;
    };

    ready = () => this.initMesh();
}

class Floor extends Group {
    constructor() {
        super();

        this.initReflector();
    }

    initReflector() {
        this.reflector = new Reflector({ blurIterations: 6 });
    }

    async initMesh() {
        const { loadTexture } = WorldController;

        const geometry = new PlaneGeometry(100, 100);

        const map = await loadTexture('waterdudv.jpg');
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(6, 3);

        const material = new ShadowMaterial({
            toneMapped: false
        });

        material.onBeforeCompile = shader => {
            map.updateMatrix();

            shader.uniforms.map = { value: map };
            shader.uniforms.reflectMap = { value: this.reflector.renderTarget.texture };
            shader.uniforms.reflectMapBlur = this.reflector.renderTargetUniform;
            shader.uniforms.uvTransform = { value: map.matrix };
            shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

            shader.vertexShader = shader.vertexShader.replace(
                'void main() {',
                /* glsl */ `
                uniform mat3 uvTransform;
                uniform mat4 textureMatrix;

                out vec2 vUv;
                out vec4 vCoord;

                void main() {
                `
            );

            shader.vertexShader = shader.vertexShader.replace(
                '#include <project_vertex>',
                /* glsl */ `
                #include <project_vertex>

                vUv = (uvTransform * vec3(uv, 1)).xy;
                vCoord = textureMatrix * vec4(transformed, 1.0);
                `
            );

            shader.fragmentShader = shader.fragmentShader.replace(
                'void main() {',
                /* glsl */ `
                uniform sampler2D map;
                uniform sampler2D reflectMap;
                uniform sampler2D reflectMapBlur;

                in vec2 vUv;
                in vec4 vCoord;

                ${dither}

                void main() {
                `
            );

            shader.fragmentShader = shader.fragmentShader.replace(
                'gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );',
                /* glsl */ `
                vec2 reflectionUv = vCoord.xy / vCoord.w;

                vec4 dudv = texture(map, vUv);
                vec4 color = texture(reflectMap, reflectionUv);

                vec4 blur;

                blur = texture(reflectMapBlur, reflectionUv + dudv.rg / 256.0);
                color = mix(color, blur, smoothstep(1.0, 0.1, dudv.g));

                blur = texture(reflectMapBlur, reflectionUv);
                color = mix(color, blur, smoothstep(0.5, 1.0, dudv.r));

                gl_FragColor = color * mix(0.3, 0.55, dudv.g);

                gl_FragColor.rgb -= (1.0 - getShadowMask()) * 0.025;

                gl_FragColor.rgb = dither(gl_FragColor.rgb);
                `
            );
        };

        const mesh = new Mesh(geometry, material);
        mesh.position.y = -0.86;
        mesh.rotation.x = -Math.PI / 2;
        mesh.receiveShadow = true;
        mesh.add(this.reflector);

        mesh.onBeforeRender = (renderer, scene, camera) => {
            this.visible = false;
            this.reflector.update(renderer, scene, camera);
            this.visible = true;
        };

        this.add(mesh);
    }

    // Public methods

    resize = (width, height) => {
        height = 1024;

        this.reflector.setSize(width, height);
    };

    ready = () => this.initMesh();
}

class SceneView extends Group {
    constructor() {
        super();

        this.visible = false;

        this.initViews();
    }

    initViews() {
        this.floor = new Floor();
        this.add(this.floor);

        this.darkPlanet = new DarkPlanet();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystal();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCube();
        this.add(this.abstractCube);
    }

    // Public methods

    resize = (width, height) => {
        this.floor.resize(width, height);
        this.darkPlanet.resize(width, height);
        this.floatingCrystal.resize(width, height);
        this.abstractCube.resize(width, height);
    };

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.floor.ready(),
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;

        this.animatedOneFramePast = false;
    }

    static addListeners() {
        window.addEventListener('popstate', this.onPopState);
    }

    // Event handlers

    static onPopState = () => {
        const { data } = router.get(location.pathname);

        let view;

        switch (data.path) {
            case '/dark_planet':
                view = this.view.darkPlanet;
                break;
            case '/floating_crystal':
                view = this.view.floatingCrystal;
                break;
            case '/abstract_cube':
                view = this.view.abstractCube;
                break;
        }

        CameraController.setView(view);
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.view.resize(width, height, dpr);
    };

    static update = time => {
        if (!this.view.visible) {
            return;
        }

        if (params.animate || !this.animatedOneFramePast) {
            this.view.update(time);

            this.animatedOneFramePast = !params.animate;
        }
    };

    static animateIn = () => {
        this.addListeners();
        this.onPopState();

        this.view.visible = true;
    };

    static ready = () => this.view.ready();
}

class ScenePanelController {
    static init(view) {
        this.view = view;

        this.initPanel();

        this.addListeners();
    }

    static initPanel() {
        const { darkPlanet, floatingCrystal, abstractCube } = this.view;

        const objects = [darkPlanet, floatingCrystal, abstractCube];

        objects.forEach(object => {
            object.point = new Point3D(object.mesh, {
                type: '',
                noTracker: true
            });
            object.add(object.point);
        });

        // Shrink tracker meshes a little bit
        floatingCrystal.point.mesh.scale.multiply(new Vector3(1, 0.9, 1));
        abstractCube.point.mesh.scale.multiplyScalar(0.9);
    }

    static addListeners() {
        Point3D.events.on('click', this.onClick);
    }

    // Event handlers

    static onClick = ({ target }) => {
        const data = Data.pages[target.index];

        if (data && data.path) {
            const path = router.getPath(data.path);

            router.setPath(`${path}/`);

            Point3D.animateOut();
        }
    };
}

class PanelController {
    static init(renderer, scene, camera, view, ui) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.view = view;
        this.ui = ui;

        this.initControllers();
        this.initPanel();
    }

    static initControllers() {
        Point3D.init(this.renderer, this.scene, this.camera, {
            root: Stage,
            container: this.ui,
            debug: isDebug
        });

        ScenePanelController.init(this.view);
    }

    static initPanel() {
        const { drawBuffers, hBlurMaterial, vBlurMaterial, luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

        const animateOptions = {
            Off: false,
            Animate: true
        };

        const debugOptions = {
            Off: false,
            Debug: true
        };

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'list',
                list: DisplayOptions,
                value: getKeyByValue(DisplayOptions, RenderManager.display),
                callback: value => {
                    RenderManager.display = DisplayOptions[value];
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Speed',
                min: 0,
                max: 50,
                step: 0.1,
                value: params.speed,
                callback: value => {
                    params.speed = value;
                }
            },
            {
                type: 'list',
                list: animateOptions,
                value: getKeyByValue(animateOptions, params.animate),
                callback: value => {
                    params.animate = animateOptions[value];
                    drawBuffers.saveState = params.animate;
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Interp',
                min: 0,
                max: 1,
                step: 0.01,
                value: drawBuffers.interpolateGeometry,
                callback: value => {
                    drawBuffers.interpolateGeometry = value;
                }
            },
            {
                type: 'slider',
                name: 'Smear',
                min: 0,
                max: 4,
                step: 0.02,
                value: drawBuffers.smearIntensity,
                callback: value => {
                    drawBuffers.smearIntensity = value;
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Focus',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.blurFocus,
                callback: value => {
                    hBlurMaterial.uniforms.uFocus.value = value;
                    vBlurMaterial.uniforms.uFocus.value = value;
                    compositeMaterial.uniforms.uFocus.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Rotate',
                min: 0,
                max: 360,
                step: 1,
                value: MathUtils.radToDeg(RenderManager.blurRotation),
                callback: value => {
                    value = MathUtils.degToRad(value);
                    hBlurMaterial.uniforms.uRotation.value = value;
                    vBlurMaterial.uniforms.uRotation.value = value;
                    compositeMaterial.uniforms.uRotation.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Blur',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.blurAmount,
                callback: value => {
                    RenderManager.blurAmount = value;
                }
            },
            {
                type: 'slider',
                name: 'Chroma',
                min: 0,
                max: 10,
                step: 0.1,
                value: compositeMaterial.uniforms.uRGBAmount.value,
                callback: value => {
                    compositeMaterial.uniforms.uRGBAmount.value = value;
                }
            },
            {
                type: 'list',
                list: debugOptions,
                value: getKeyByValue(debugOptions, vBlurMaterial.uniforms.uDebug.value),
                callback: value => {
                    vBlurMaterial.uniforms.uDebug.value = debugOptions[value];
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }

    // Public methods

    static update = time => {
        if (!this.ui) {
            return;
        }

        Point3D.update(time);
    };
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, scene, camera) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;

        // Gaussian blur
        this.blurFocus = navigator.maxTouchPoints ? 0.5 : 0.25;
        this.blurRotation = navigator.maxTouchPoints ? 0 : MathUtils.degToRad(75);
        this.blurAmount = 1;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        // Debug
        this.display = DisplayOptions.Default;

        this.enabled = true;

        this.initRenderer();
    }

    static initRenderer() {
        const { screenTriangle, resolution, time, textureLoader, getTexture } = WorldController;

        // Manually clear
        this.renderer.autoClear = false;

        // Clear colors
        this.clearColor = new Color(0, 0, 0);
        this.currentClearColor = new Color();

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTargetA = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetB = this.renderTargetA.clone();
        this.renderTargetC = this.renderTargetA.clone();

        this.renderTargetBright = this.renderTargetA.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTargetA.clone());
            this.renderTargetsVertical.push(this.renderTargetA.clone());
        }

        this.renderTargetA.depthBuffer = true;

        // G-Buffer
        this.drawBuffers = new DrawBuffers(this.renderer, this.scene, this.camera, layers.buffers, {
            interpolateGeometry: 0
        });

        // Motion blur composite material
        this.motionBlurCompositeMaterial = new MotionBlurCompositeMaterial(textureLoader, {
            blueNoisePath: 'blue_noise.png'
        });
        this.motionBlurCompositeMaterial.uniforms.tVelocity.value = this.drawBuffers.renderTarget.textures[1];

        // Gaussian blur materials
        this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
        this.hBlurMaterial.uniforms.uFocus.value = this.blurFocus;
        this.hBlurMaterial.uniforms.uRotation.value = this.blurRotation;
        this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;
        this.hBlurMaterial.uniforms.uResolution = resolution;
        this.hBlurMaterial.uniforms.uTime = time;

        this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
        this.vBlurMaterial.uniforms.uFocus.value = this.blurFocus;
        this.vBlurMaterial.uniforms.uRotation.value = this.blurRotation;
        this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;
        this.vBlurMaterial.uniforms.uResolution = resolution;
        this.vBlurMaterial.uniforms.uTime = time;

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite materials
        this.sceneCompositeMaterial = new SceneCompositeMaterial();

        this.compositeMaterial = new CompositeMaterial();
        this.compositeMaterial.uniforms.uFocus.value = this.blurFocus;
        this.compositeMaterial.uniforms.uRotation.value = this.blurRotation;
        this.compositeMaterial.uniforms.uBlurAmount.value = this.blurAmount;

        // Debug materials
        this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });
        this.matcap1Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/040full.jpg') });
        this.matcap2Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/defaultwax.jpg') });
        this.normalMaterial = new NormalMaterial();
        this.depthMaterial = new DepthMaterial();
        this.copyMaterial = new CopyMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    static rendererState() {
        this.currentOverrideMaterial = this.scene.overrideMaterial;
        this.currentBackground = this.scene.background;
        this.renderer.getClearColor(this.currentClearColor);
        this.currentClearAlpha = this.renderer.getClearAlpha();
    }

    static restoreRendererState() {
        this.scene.overrideMaterial = this.currentOverrideMaterial;
        this.scene.background = this.currentBackground;
        this.renderer.setClearColor(this.currentClearColor, this.currentClearAlpha);
    }

    // Public methods

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTargetA.setSize(width, height);
        this.renderTargetB.setSize(width, height);
        this.renderTargetC.setSize(width, height);

        this.drawBuffers.setSize(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        const renderer = this.renderer;
        const scene = this.scene;
        const camera = this.camera;

        if (!this.enabled) {
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(scene, camera);
            return;
        }

        const renderTargetA = this.renderTargetA;
        const renderTargetB = this.renderTargetB;
        const renderTargetC = this.renderTargetC;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Renderer state
        this.rendererState();

        // G-Buffer layer
        camera.layers.set(layers.buffers);

        this.drawBuffers.update();

        if (this.display === DisplayOptions.Velocity) {
            // Debug pass (render to screen)
            this.copyMaterial.uniforms.tMap.value = this.drawBuffers.renderTarget.textures[1];
            this.screen.material = this.copyMaterial;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);
            this.restoreRendererState();
            return;
        }

        // Scene layer
        camera.layers.set(layers.default);

        renderer.setRenderTarget(renderTargetA);
        renderer.clear();
        renderer.render(scene, camera);

        // Post-processing
        scene.background = null;
        renderer.setClearColor(this.clearColor, 1);

        // Debug override material passes (render to screen)
        if (this.display === DisplayOptions.Depth) {
            scene.overrideMaterial = this.depthMaterial;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(scene, camera);
            this.restoreRendererState();
            return;
        } else if (this.display === DisplayOptions.Geometry) {
            scene.overrideMaterial = this.normalMaterial;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(scene, camera);
            this.restoreRendererState();
            return;
        } else if (this.display === DisplayOptions.Matcap1) {
            scene.overrideMaterial = this.matcap1Material;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(scene, camera);
            this.restoreRendererState();
            return;
        } else if (this.display === DisplayOptions.Matcap2) {
            scene.overrideMaterial = this.matcap2Material;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(scene, camera);
            this.restoreRendererState();
            return;
        }

        // Motion blur pass
        this.motionBlurCompositeMaterial.uniforms.tMap.value = renderTargetA.texture;
        this.screen.material = this.motionBlurCompositeMaterial;
        renderer.setRenderTarget(renderTargetB);
        renderer.clear();
        renderer.render(this.screen, this.screenCamera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;

        if (this.display === DisplayOptions.Luma) {
            // Debug pass (render to screen)
            this.screen.material = this.blackoutMaterial;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);
            this.screen.material = this.luminosityMaterial;
            this.screen.material.blending = AdditiveBlending;
            renderer.render(this.screen, this.screenCamera);
            this.screen.material.blending = NoBlending;
            this.restoreRendererState();
            return;
        } else {
            this.screen.material = this.luminosityMaterial;
            renderer.setRenderTarget(renderTargetBright);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);
        }

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;

        if (this.display === DisplayOptions.Bloom) {
            // Debug pass (render to screen)
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);
            this.restoreRendererState();
            return;
        } else {
            renderer.setRenderTarget(renderTargetsHorizontal[0]);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);
        }

        // Scene composite pass
        this.sceneCompositeMaterial.uniforms.tScene.value = renderTargetB.texture;
        this.sceneCompositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.sceneCompositeMaterial;
        renderer.setRenderTarget(renderTargetC);
        renderer.clear();
        renderer.render(this.screen, this.screenCamera);

        // Two pass Gaussian blur (horizontal and vertical)
        if (this.blurAmount) {
            this.hBlurMaterial.uniforms.tMap.value = renderTargetC.texture;
            this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;
            this.screen.material = this.hBlurMaterial;
            renderer.setRenderTarget(renderTargetA);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);

            this.vBlurMaterial.uniforms.tMap.value = renderTargetA.texture;
            this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;
            this.screen.material = this.vBlurMaterial;
            renderer.setRenderTarget(renderTargetC);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);
        }

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTargetC.texture;
        this.compositeMaterial.uniforms.uBlurAmount.value = this.blurAmount;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.clear();
        renderer.render(this.screen, this.screenCamera);

        // Restore renderer settings
        this.restoreRendererState();
    };

    static start = () => {
        this.blurAmount = 0;
    };

    static zoomIn = () => {
        clearTween(this.timeout);

        this.timeout = delayedCall(300, () => {
            tween(this, { blurAmount: 1 }, 1000, 'easeOutBack');
        });
    };

    static zoomOut = () => {
        clearTween(this.timeout);

        tween(this, { blurAmount: 0 }, 300, 'linear');
    };
}

class CameraController {
    static init(worldCamera, controlsCamera, controls, ui) {
        this.worldCamera = worldCamera;
        this.controlsCamera = controlsCamera;
        this.controls = controls;
        this.ui = ui;

        // Default camera
        this.camera = this.controlsCamera;

        this.progress = 0;
        this.isTransitioning = false;
        this.zoomedIn = false;
        this.enabled = false;
    }

    static transition() {
        clearTween(this);
        clearTween(this.timeout);

        this.controls.enabled = false;
        Point3D.enabled = false;

        this.progress = 0;
        this.isTransitioning = true;

        tween(this, { progress: 1 }, 1000, 'easeInOutSine', () => {
            this.isTransitioning = false;
        }, () => {
            lerpCameras(this.worldCamera, this.view.camera, this.progress);
        });

        if (this.zoomedIn) {
            this.ui.details.animateOut(() => {
                const { data } = router.get(location.pathname);

                this.ui.details.title.setTitle(data.title.replace(/[\s.-]+/g, '_'));

                const next = Data.getNext(data);
                const path = router.getPath(next.path);

                this.ui.link.setLink(next.path !== '/' ? `${path}/` : path);

                this.ui.details.animateIn();
            });

            RenderManager.zoomIn();
        } else {
            this.ui.details.animateOut();

            RenderManager.zoomOut();

            this.timeout = delayedCall(300, () => {
                this.controls.enabled = true;
                Point3D.enabled = true;
            });
        }
    }

    // Public methods

    static setView = view => {
        if (!navigator.maxTouchPoints && (!view || view === this.next)) {
            this.view = this;
            this.zoomedIn = false;
        } else {
            this.view = view;
            this.zoomedIn = true;
        }

        this.transition();
    };

    static resize = (width, height) => {
        this.worldCamera.aspect = width / height;
        this.worldCamera.updateProjectionMatrix();
    };

    static update = () => {
        if (!this.enabled || this.isTransitioning) {
            return;
        }

        this.worldCamera.position.copy(this.view.camera.position);
        this.worldCamera.quaternion.copy(this.view.camera.quaternion);
    };

    static animateIn = () => {
        this.enabled = true;
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLights();
        this.initLoaders();
        this.initEnvironment();
        this.initControls();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // Shadows
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = BasicShadowMap;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.set(0, 6, 8);
        this.camera.lookAt(this.scene.position);

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(5, 5, 5);
        light.castShadow = true;
        light.shadow.mapSize.width = 2048;
        light.shadow.mapSize.height = 2048;
        this.scene.add(light);
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');
        this.textureLoader.cache = true;

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static async initEnvironment() {
        this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    static initControls() {
        this.controlsCamera = this.camera.clone();
        this.controls = new MapControls(this.controlsCamera, this.renderer.domElement);
        this.controls.enableDamping = true;
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;

        if (this.controls.enabled) {
            this.controls.update();
        }
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initRouter();
        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        RenderManager.start();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init();
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initRouter() {
        Data.pages.forEach(page => {
            router.add(page.path, Page, page);
        });

        // Landing and 404 page
        let home;

        if (!navigator.maxTouchPoints) {
            home = {
                path: '/',
                title: 'Camera Transition'
            };

            Data.pages.push(home);
        } else {
            home = Data.pages[0]; // Dark Planet
        }

        router.add('/', Page, home);
        router.add('404', Page, home);

        router.init({
            path: basePath,
            scrollRestoration: 'auto'
        });
    }

    static initViews() {
        this.view = new SceneView();
        WorldController.scene.add(this.view);

        this.ui = new UI({
            fps: true,
            breakpoint,
            details: {
                title: '',
                content: [
                    {
                        content: /* html */ `
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
                        `,
                        links: [
                            {
                                title: 'Next'
                            }
                        ]
                    }
                ]
            }
        });
        this.ui.link = this.ui.details.links[0];
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer, scene, camera, controlsCamera, controls } = WorldController;

        CameraController.init(camera, controlsCamera, controls, this.ui);
        SceneController.init(this.view);
        RenderManager.init(renderer, scene, camera);
    }

    static initPanel() {
        const { renderer, scene, camera } = WorldController;

        PanelController.init(renderer, scene, camera, this.view, this.ui);
    }

    static addListeners() {
        Stage.events.on('details', this.onDetails);
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
        this.ui.link.events.on('click', this.onClick);
    }

    // Event handlers

    static onDetails = ({ open }) => {
        if (!open) {
            history.back();
        }
    };

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        CameraController.resize(width, height);
        SceneController.resize(width, height);
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        CameraController.update();
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        PanelController.update(time);
        this.ui.update();
    };

    static onClick = (e, { target }) => {
        e.preventDefault();

        router.setPath(target.link);
    };

    // Public methods

    static animateIn = () => {
        CameraController.animateIn();
        SceneController.animateIn();
        this.ui.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/canvas/abstract_cube/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Abstract Cube — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/canvas/style.css">

    <script type="module" src="/examples/three/transitions/canvas/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/canvas/dark_planet/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Dark Planet — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/canvas/style.css">

    <script type="module" src="/examples/three/transitions/canvas/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/canvas/floating_crystal/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Floating Crystal — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/canvas/style.css">

    <script type="module" src="/examples/three/transitions/canvas/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/canvas/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Page Transition — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/canvas/style.css">

    <script type="module" src="/examples/three/transitions/canvas/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/canvas/main.js
---

import { AssetLoader, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, Link, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RepeatWrapping, Scene, SceneCompositeMaterial, Stage, TextureLoader, Title, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, delayedCall, getFullscreenTriangle, router, ticker, tween } from '../../../../build/alien.three.js';

const basePath = '/examples/three/transitions/canvas';
const breakpoint = 1000;

class Page {
    constructor({ path, title }) {
        this.path = path;
        this.title = title;

        document.title = `${this.title} — Alien.js`;
    }
}

class Data {
    static init({ pages }) {
        this.pages = pages;
    }

    // Public methods

    static getNext = page => {
        let index = this.pages.indexOf(page);

        if (!~index || ++index > this.pages.length - 1) {
            index = 0;
        }

        return this.pages[index];
    };
}

class UIBackground extends Interface {
    constructor() {
        super(null, 'canvas');

        this.progress = 0;
        this.bend = 0;
        this.animatedIn = false;
        this.needsUpdate = false;

        this.init();
        this.initCanvas();
        this.initFill();
        this.initPoints();
    }

    init() {
        this.css({
            position: 'absolute',
            left: 0,
            top: 0,
            width: '100%',
            height: '100%',
            pointerEvents: 'none'
        });
    }

    initCanvas() {
        this.context = this.element.getContext('2d');
    }

    initFill() {
        this.fill = {};
        this.fill.fillStyle = '#000';
    }

    initPoints() {
        this.points = [];

        for (let i = 0; i < 3; i++) {
            this.points.push(new Vector2());
        }
    }

    drawFill() {
        this.context.fillStyle = this.fill.fillStyle;

        // Spline
        this.context.beginPath();
        this.context.moveTo(this.points[0].x, this.points[0].y);
        this.context.quadraticCurveTo(this.points[1].x, this.points[1].y, this.points[2].x, this.points[2].y);

        // Fill
        if (this.animatedIn) {
            this.context.lineTo(this.width, 0);
            this.context.lineTo(0, 0);
        } else {
            this.context.lineTo(this.width, this.start);
            this.context.lineTo(0, this.start);
        }

        this.context.lineTo(this.points[0].x, this.points[0].y);
        this.context.fill();
    }

    // Public methods

    resize = (width, height, dpr) => {
        this.width = width;
        this.height = height;

        this.start = height;
        this.end = 0;
        this.direction = this.end - this.start < 0 ? -1 : 1;

        this.element.width = Math.round(this.width * dpr);
        this.element.height = Math.round(this.height * dpr);
        this.element.style.width = `${this.width}px`;
        this.element.style.height = `${this.height}px`;
        this.context.scale(dpr, dpr);

        const increment = width / (this.points.length - 1);

        for (let i = 0, l = this.points.length; i < l; i++) {
            this.points[i].x = increment * i;
            this.points[i].y = this.start;
        }
    };

    update = () => {
        if (this.needsUpdate) {
            for (let i = 0, l = this.points.length; i < l; i++) {
                const difference = Math.abs(this.width / 2 - this.points[i].x) / this.width;
                const offset = (this.bend - (difference * (this.height / 2)) * this.bend) * this.direction;
                this.points[i].y = this.start + offset + this.height * this.progress * this.direction;
            }

            this.context.clearRect(0, 0, this.element.width, this.element.height);

            this.drawFill();
        }
    };

    animateIn = callback => {
        clearTween(this);

        this.progress = 0;
        this.bend = 0;
        this.animatedIn = false;
        this.needsUpdate = true;

        tween(this, { progress: 1 }, 1250, 'easeInOutQuart', () => {
            this.needsUpdate = false;

            if (callback) {
                callback();
            }
        });

        tween(this, { bend: 1 }, 500, 'linear', () => {
            tween(this, { bend: 0 }, 500, 'linear');
        });
    };

    animateOut = callback => {
        clearTween(this);

        this.progress = 0;
        this.bend = 0;
        this.animatedIn = true;
        this.needsUpdate = true;

        tween(this, { progress: 1 }, 1250, 'easeInOutQuart', () => {
            this.needsUpdate = false;
            this.animatedIn = false;

            if (callback) {
                callback();
            }
        });

        tween(this, { bend: 1 }, 500, 'linear', () => {
            tween(this, { bend: 0 }, 500, 'linear');
        });
    };
}

class UIContainer extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();

        this.addListeners();
    }

    init() {
        this.invisible();
        this.css({
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            height: '100%',
            padding: '55px 0'
        });
    }

    initViews() {
        const { data } = router.get(location.pathname);

        this.background = new UIBackground();
        this.add(this.background);

        this.title = new Title(data.title.replace(/[\s.-]+/g, '_'));
        this.title.css({
            width: 'fit-content',
            pointerEvents: 'auto'
        });
        this.add(this.title);

        const next = Data.getNext(data);
        const path = router.getPath(next.path);

        this.link = new Link('Next', `${path}/`);
        this.link.css({ marginTop: 'auto' });
        this.add(this.link);
    }

    addListeners() {
        window.addEventListener('popstate', this.onPopState);
        this.link.events.on('click', this.onClick);
    }

    // Event handlers

    onPopState = () => {
        const { data } = router.get(location.pathname);

        this.title.animateOut();
        this.link.animateOut();

        clearTween(this.timeout);

        this.background.animateIn(() => {
            SceneController.setView();

            this.timeout = delayedCall(950, () => {
                this.title.setTitle(data.title.replace(/[\s.-]+/g, '_'));
            });

            this.background.animateOut(() => {
                const next = Data.getNext(data);
                const path = router.getPath(next.path);

                this.link.setLink(`${path}/`);
                this.link.animateIn();
            });
        });
    };

    onClick = (e, { target }) => {
        e.preventDefault();

        router.setPath(target.link);
    };

    // Public methods

    resize = (width, height, dpr) => {
        if (width < breakpoint) {
            this.css({
                padding: '24px 0'
            });
        } else {
            this.css({
                padding: '55px 0'
            });
        }

        this.background.resize(width, height, dpr);
    };

    update = () => {
        this.background.update();
    };

    animateIn = () => {
        this.visible();

        const duration = 2000;
        const stagger = 175;

        this.children.forEach((view, i) => {
            view.css({ opacity: 0 }).tween({ opacity: 1 }, duration, 'easeOutCubic', i * stagger);
        });

        this.title.animateIn();
        this.link.animateIn();
    };
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };

    ready = () => this.initMesh();
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };

    ready = () => this.initMesh();
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };

    ready = () => this.initMesh();
}

class SceneView extends Group {
    constructor() {
        super();

        this.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystal();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCube();
        this.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;
    }

    // Public methods

    static setView = () => {
        const { data } = router.get(location.pathname);

        this.view.darkPlanet.visible = false;
        this.view.floatingCrystal.visible = false;
        this.view.abstractCube.visible = false;

        switch (data.path) {
            case '/dark_planet':
                this.view.darkPlanet.visible = true;
                break;
            case '/floating_crystal':
                this.view.floatingCrystal.visible = true;
                break;
            case '/abstract_cube':
                this.view.abstractCube.visible = true;
                break;
        }
    };

    static resize = () => {
    };

    static update = time => {
        if (!this.view.visible) {
            return;
        }

        this.view.update(time);
    };

    static animateIn = () => {
        this.setView();

        this.view.visible = true;
    };

    static ready = async () => {
        await this.view.ready();

        // Prerender
        this.view.visible = true;
        RenderManager.update();
        this.view.visible = false;
    };
}

class PanelController {
    static init(ui, container) {
        this.ui = ui;
        this.container = container;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'color',
                value: this.container.background.fill.fillStyle,
                callback: value => {
                    this.container.background.fill.fillStyle = `#${value.getHexString()}`;
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, scene, camera) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.enabled = true;

        this.initRenderer();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetBright = this.renderTarget.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTarget.clone());
            this.renderTargetsVertical.push(this.renderTarget.clone());
        }

        this.renderTarget.depthBuffer = true;

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite material
        this.compositeMaterial = new SceneCompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    // Public methods

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        const renderer = this.renderer;
        const scene = this.scene;
        const camera = this.camera;

        if (!this.enabled) {
            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
            return;
        }

        const renderTarget = this.renderTarget;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Scene pass
        renderer.setRenderTarget(renderTarget);
        renderer.render(scene, camera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
        this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLights();
        this.initLoaders();
        this.initEnvironment();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;
        this.camera.lookAt(this.scene.position);

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static async initEnvironment() {
        this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initRouter();
        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init();
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initRouter() {
        Data.pages.forEach(page => {
            router.add(page.path, Page, page);
        });

        // Landing and 404 page
        const home = Data.pages[0]; // Dark Planet

        router.add('/', Page, home);
        router.add('404', Page, home);

        router.init({
            path: basePath,
            scrollRestoration: 'auto'
        });
    }

    static initViews() {
        this.view = new SceneView();
        WorldController.scene.add(this.view);

        this.ui = new UI({ fps: true, breakpoint });
        this.ui.container = new UIContainer();
        this.ui.add(this.ui.container);
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer, scene, camera } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer, scene, camera);
    }

    static initPanel() {
        PanelController.init(this.ui, this.ui.container);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize();
        RenderManager.resize(width, height, dpr);
        this.ui.container.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
        this.ui.container.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        this.ui.animateIn();
        this.ui.container.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/page/abstract_cube/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Abstract Cube — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/page/style.css">

    <script type="module" src="/examples/three/transitions/page/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/page/dark_planet/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Dark Planet — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/page/style.css">

    <script type="module" src="/examples/three/transitions/page/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/page/floating_crystal/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Floating Crystal — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/page/style.css">

    <script type="module" src="/examples/three/transitions/page/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/page/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Page Transition — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/page/style.css">

    <script type="module" src="/examples/three/transitions/page/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/page/main.js
---

import { AssetLoader, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, Link, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RepeatWrapping, Scene, SceneCompositeMaterial, Stage, TextureLoader, Title, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, delayedCall, getFullscreenTriangle, router, ticker } from '../../../../build/alien.three.js';

const basePath = '/examples/three/transitions/page';
const breakpoint = 1000;

class Page {
    constructor({ path, title }) {
        this.path = path;
        this.title = title;

        document.title = `${this.title} — Alien.js`;
    }
}

class Data {
    static init({ pages }) {
        this.pages = pages;
    }

    // Public methods

    static getNext = page => {
        let index = this.pages.indexOf(page);

        if (!~index || ++index > this.pages.length - 1) {
            index = 0;
        }

        return this.pages[index];
    };
}

class UIContainer extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();

        this.addListeners();
        this.onResize();
    }

    init() {
        this.invisible();
        this.css({
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            height: '100%',
            padding: '55px 0'
        });
    }

    initViews() {
        const { data } = router.get(location.pathname);

        this.title = new Title(data.title.replace(/[\s.-]+/g, '_'));
        this.title.css({
            width: 'fit-content',
            pointerEvents: 'auto'
        });
        this.add(this.title);

        const next = Data.getNext(data);
        const path = router.getPath(next.path);

        this.link = new Link('Next', `${path}/`);
        this.link.css({ marginTop: 'auto' });
        this.add(this.link);
    }

    addListeners() {
        window.addEventListener('popstate', this.onPopState);
        window.addEventListener('resize', this.onResize);
        this.link.events.on('click', this.onClick);
    }

    // Event handlers

    onPopState = () => {
        SceneController.setView();

        const { data } = router.get(location.pathname);

        clearTween(this.timeout);

        this.timeout = delayedCall(300, () => {
            this.title.setTitle(data.title.replace(/[\s.-]+/g, '_'));
        });

        const next = Data.getNext(data);
        const path = router.getPath(next.path);

        this.link.setLink(`${path}/`);
    };

    onResize = () => {
        const width = document.documentElement.clientWidth;

        if (width < breakpoint) {
            this.css({
                padding: '24px 0'
            });
        } else {
            this.css({
                padding: '55px 0'
            });
        }
    };

    onClick = (e, { target }) => {
        e.preventDefault();

        router.setPath(target.link);
    };

    // Public methods

    animateIn = () => {
        this.visible();

        const duration = 2000;
        const stagger = 175;

        this.children.forEach((view, i) => {
            view.css({ opacity: 0 }).tween({ opacity: 1 }, duration, 'easeOutCubic', i * stagger);
        });

        this.title.animateIn();
        this.link.animateIn();
    };
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };

    ready = () => this.initMesh();
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };

    ready = () => this.initMesh();
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };

    ready = () => this.initMesh();
}

class SceneView extends Group {
    constructor() {
        super();

        this.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystal();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCube();
        this.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;
    }

    // Public methods

    static setView = () => {
        const { data } = router.get(location.pathname);

        this.view.darkPlanet.visible = false;
        this.view.floatingCrystal.visible = false;
        this.view.abstractCube.visible = false;

        switch (data.path) {
            case '/dark_planet':
                this.view.darkPlanet.visible = true;
                break;
            case '/floating_crystal':
                this.view.floatingCrystal.visible = true;
                break;
            case '/abstract_cube':
                this.view.abstractCube.visible = true;
                break;
        }
    };

    static resize = () => {
    };

    static update = time => {
        if (!this.view.visible) {
            return;
        }

        this.view.update(time);
    };

    static animateIn = () => {
        this.setView();

        this.view.visible = true;
    };

    static ready = async () => {
        await this.view.ready();

        // Prerender
        this.view.visible = true;
        RenderManager.update();
        this.view.visible = false;
    };
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, scene, camera) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.enabled = true;

        this.initRenderer();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetBright = this.renderTarget.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTarget.clone());
            this.renderTargetsVertical.push(this.renderTarget.clone());
        }

        this.renderTarget.depthBuffer = true;

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite material
        this.compositeMaterial = new SceneCompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    // Public methods

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        const renderer = this.renderer;
        const scene = this.scene;
        const camera = this.camera;

        if (!this.enabled) {
            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
            return;
        }

        const renderTarget = this.renderTarget;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Scene pass
        renderer.setRenderTarget(renderTarget);
        renderer.render(scene, camera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
        this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLights();
        this.initLoaders();
        this.initEnvironment();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;
        this.camera.lookAt(this.scene.position);

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static async initEnvironment() {
        this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initRouter();
        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init();
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initRouter() {
        Data.pages.forEach(page => {
            router.add(page.path, Page, page);
        });

        // Landing and 404 page
        const home = Data.pages[0]; // Dark Planet

        router.add('/', Page, home);
        router.add('404', Page, home);

        router.init({
            path: basePath,
            scrollRestoration: 'auto'
        });
    }

    static initViews() {
        this.view = new SceneView();
        WorldController.scene.add(this.view);

        this.ui = new UI({ fps: true, breakpoint });
        this.ui.container = new UIContainer();
        this.ui.add(this.ui.container);
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer, scene, camera } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer, scene, camera);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize();
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        this.ui.animateIn();
        this.ui.container.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/scene/abstract_cube/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Abstract Cube — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/scene/style.css">

    <script type="module" src="/examples/three/transitions/scene/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/scene/dark_planet/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Dark Planet — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/scene/style.css">

    <script type="module" src="/examples/three/transitions/scene/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/scene/floating_crystal/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Floating Crystal — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/scene/style.css">

    <script type="module" src="/examples/three/transitions/scene/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/scene/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Page Transition — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/scene/style.css">

    <script type="module" src="/examples/three/transitions/scene/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/scene/main.js
---

import { AssetLoader, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, Component, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, Link, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, Stage, TextureLoader, Title, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, delayedCall, getFullscreenTriangle, router, ticker, tween } from '../../../../build/alien.three.js';

const basePath = '/examples/three/transitions/scene';
const breakpoint = 1000;

class Page {
    constructor({ path, title }) {
        this.path = path;
        this.title = title;

        document.title = `${this.title} — Alien.js`;
    }
}

class Data {
    static init({ pages }) {
        this.pages = pages;
    }

    // Public methods

    static getNext = page => {
        let index = this.pages.indexOf(page);

        if (!~index || ++index > this.pages.length - 1) {
            index = 0;
        }

        return this.pages[index];
    };
}

class UIContainer extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();

        this.addListeners();
        this.onResize();
    }

    init() {
        this.invisible();
        this.css({
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            height: '100%',
            padding: '55px 0'
        });
    }

    initViews() {
        const { data } = router.get(location.pathname);

        this.title = new Title(data.title.replace(/[\s.-]+/g, '_'));
        this.title.css({
            width: 'fit-content',
            pointerEvents: 'auto'
        });
        this.add(this.title);

        const next = Data.getNext(data);
        const path = router.getPath(next.path);

        this.link = new Link('Next', `${path}/`);
        this.link.css({ marginTop: 'auto' });
        this.add(this.link);
    }

    addListeners() {
        window.addEventListener('popstate', this.onPopState);
        window.addEventListener('resize', this.onResize);
        this.link.events.on('click', this.onClick);
    }

    // Event handlers

    onPopState = () => {
        const { data } = router.get(location.pathname);

        clearTween(this.timeout);

        this.timeout = delayedCall(300, () => {
            this.title.setTitle(data.title.replace(/[\s.-]+/g, '_'));
        });

        const next = Data.getNext(data);
        const path = router.getPath(next.path);

        this.link.setLink(`${path}/`);
    };

    onResize = () => {
        const width = document.documentElement.clientWidth;

        if (width < breakpoint) {
            this.css({
                padding: '24px 0'
            });
        } else {
            this.css({
                padding: '55px 0'
            });
        }
    };

    onClick = (e, { target }) => {
        e.preventDefault();

        router.setPath(target.link);
    };

    // Public methods

    animateIn = () => {
        this.visible();

        const duration = 2000;
        const stagger = 175;

        this.children.forEach((view, i) => {
            view.css({ opacity: 0 }).tween({ opacity: 1 }, duration, 'easeOutCubic', i * stagger);
        });

        this.title.animateIn();
        this.link.animateIn();
    };
}

class TransitionMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap1: { value: null },
                tMap2: { value: null },
                uProgress: { value: 0 },
                uSize: { value: 0.04 },
                uZoom: { value: 50 },
                uColorSeparation: { value: 0.3 },
                uResolution: { value: new Vector2() },
                uTime: { value: 0 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tMap1;
                uniform sampler2D tMap2;
                uniform float uProgress;
                uniform vec2 uResolution;
                uniform float uTime;

                in vec2 vUv;

                out vec4 FragColor;

                // Based on https://gl-transitions.com/editor/flyeye by gre

                uniform float uSize;
                uniform float uZoom;
                uniform float uColorSeparation;

                void main() {
                    if (uProgress == 0.0) {
                        FragColor = texture(tMap1, vUv);
                        return;
                    } else if (uProgress == 1.0) {
                        FragColor = texture(tMap2, vUv);
                        return;
                    }

                    float inv = 1.0 - uProgress;
                    vec2 disp = uSize * vec2(cos(uZoom * vUv.x), sin(uZoom * vUv.y));

                    vec4 texTo = texture(tMap2, vUv + inv * disp);
                    vec4 texFrom = vec4(
                        texture(tMap1, vUv + uProgress * disp * (1.0 - uColorSeparation)).r,
                        texture(tMap1, vUv + uProgress * disp).g,
                        texture(tMap1, vUv + uProgress * disp * (1.0 + uColorSeparation)).b,
                        1.0
                    );

                    FragColor = texTo * uProgress + texFrom * inv;
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

class RenderScene {
    constructor() {
        this.initRenderer();
        this.initLights();
        this.initEnvironment();
    }

    initRenderer() {
        const { renderer, camera } = WorldController;

        this.renderer = renderer;
        this.camera = camera;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1);
    }

    initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    async initEnvironment() {
        const { loadEnvironmentTexture } = WorldController;

        this.scene.environment = await loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    // Inheritable methods

    resize(width, height, dpr) {
        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);
    }

    update() {
        // Renderer state
        const currentRenderTarget = this.renderer.getRenderTarget();

        // Scene pass
        this.renderer.setRenderTarget(this.renderTarget);
        this.renderer.render(this.scene, this.camera);

        // Restore renderer settings
        this.renderer.setRenderTarget(currentRenderTarget);
    }
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };
}

class AbstractCubeScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.abstractCube = new AbstractCube();
        this.scene.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.abstractCube.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.abstractCube.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };
}

class FloatingCrystalScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.floatingCrystal = new FloatingCrystal();
        this.scene.add(this.floatingCrystal);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.floatingCrystal.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.floatingCrystal.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };
}

class DarkPlanetScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.scene.add(this.darkPlanet);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.darkPlanet.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.darkPlanet.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class SceneView extends Component {
    constructor() {
        super();

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanetScene();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystalScene();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCubeScene();
        this.add(this.abstractCube);
    }

    // Public methods

    resize = (width, height, dpr) => {
        this.darkPlanet.resize(width, height, dpr);
        this.floatingCrystal.resize(width, height, dpr);
        this.abstractCube.resize(width, height, dpr);
    };

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;
    }

    static addListeners() {
        window.addEventListener('popstate', this.onPopState);
    }

    // Event handlers

    static onPopState = () => {
        const { data } = router.get(location.pathname);

        let view;

        switch (data.path) {
            case '/dark_planet':
                view = this.view.darkPlanet;
                break;
            case '/floating_crystal':
                view = this.view.floatingCrystal;
                break;
            case '/abstract_cube':
                view = this.view.abstractCube;
                break;
        }

        RenderManager.setView(view);
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.view.resize(width, height, dpr);
    };

    static update = time => {
        this.view.update(time);
    };

    static animateIn = () => {
        this.addListeners();
        this.onPopState();
    };

    static ready = () => this.view.ready();
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial, transitionMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Size',
                min: 0,
                max: 1,
                step: 0.01,
                value: transitionMaterial.uniforms.uSize.value,
                callback: value => {
                    transitionMaterial.uniforms.uSize.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Zoom',
                min: 0,
                max: 100,
                step: 0.1,
                value: transitionMaterial.uniforms.uZoom.value,
                callback: value => {
                    transitionMaterial.uniforms.uZoom.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Chroma',
                min: 0,
                max: 10,
                step: 0.1,
                value: transitionMaterial.uniforms.uColorSeparation.value,
                callback: value => {
                    transitionMaterial.uniforms.uColorSeparation.value = value;
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer) {
        this.renderer = renderer;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.animatedIn = false;

        this.initRenderer();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetBright = this.renderTarget.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTarget.clone());
            this.renderTargetsVertical.push(this.renderTarget.clone());
        }

        this.renderTarget.depthBuffer = true;

        // Transition material
        this.transitionMaterial = new TransitionMaterial();

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite material
        this.compositeMaterial = new SceneCompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    // Public methods

    static setView = view => {
        if (this.view) {
            this.next = view;

            const start = () => {
                const next = this.next;
                next.scene.visible = true;

                this.transitionMaterial.uniforms.tMap2.value = next.renderTarget.texture;
                tween(this.transitionMaterial.uniforms.uProgress, { value: 1 }, 1500, 'easeInOutCubic', () => {
                    this.transitionMaterial.uniforms.tMap1.value = next.renderTarget.texture;
                    this.transitionMaterial.uniforms.uProgress.value = 0;
                    this.view.scene.visible = false;
                    this.view = next;

                    if (this.next !== this.view) {
                        start();
                    } else {
                        this.animatedIn = false;
                    }
                });
            };

            if (!this.animatedIn) {
                this.animatedIn = true;

                start();
            }
        } else {
            // First view
            view.scene.visible = true;
            this.transitionMaterial.uniforms.tMap1.value = view.renderTarget.texture;
            this.view = view;
        }
    };

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        const renderer = this.renderer;

        const renderTarget = this.renderTarget;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Scene composite pass
        this.screen.material = this.transitionMaterial;
        renderer.setRenderTarget(renderTarget);
        renderer.render(this.screen, this.screenCamera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
        this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLoaders();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // Global 3D camera
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initRouter();
        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init();
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initRouter() {
        Data.pages.forEach(page => {
            router.add(page.path, Page, page);
        });

        // Landing and 404 page
        const home = Data.pages[0]; // Dark Planet

        router.add('/', Page, home);
        router.add('404', Page, home);

        router.init({
            path: basePath,
            scrollRestoration: 'auto'
        });
    }

    static initViews() {
        this.view = new SceneView();

        this.ui = new UI({ fps: true, breakpoint });
        this.ui.container = new UIContainer();
        this.ui.add(this.ui.container);
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize(width, height, dpr);
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        this.ui.animateIn();
        this.ui.container.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/scene_direction/abstract_cube/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Abstract Cube — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/scene_direction/style.css">

    <script type="module" src="/examples/three/transitions/scene_direction/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/scene_direction/dark_planet/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Dark Planet — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/scene_direction/style.css">

    <script type="module" src="/examples/three/transitions/scene_direction/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/scene_direction/floating_crystal/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Floating Crystal — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/scene_direction/style.css">

    <script type="module" src="/examples/three/transitions/scene_direction/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/scene_direction/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Page Transition — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/scene_direction/style.css">

    <script type="module" src="/examples/three/transitions/scene_direction/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/scene_direction/main.js
---

import { AssetLoader, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, Component, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, Link, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, Stage, TextureLoader, Title, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, delayedCall, getFullscreenTriangle, router, ticker, tween } from '../../../../build/alien.three.js';

const basePath = '/examples/three/transitions/scene_direction';
const breakpoint = 1000;

class Page {
    constructor({ path, title }) {
        this.path = path;
        this.title = title;

        document.title = `${this.title} — Alien.js`;
    }
}

class Data {
    static init({ pages }) {
        this.pages = pages;
        this.pageDirection = 1;

        this.setIndexes();

        this.addListeners();
        this.onPopState();
    }

    static setIndexes() {
        this.pages.forEach((page, i) => page.index = i);
    }

    static addListeners() {
        window.addEventListener('popstate', this.onPopState);
    }

    // Event handlers

    static onPopState = () => {
        const lastPosition = Number(sessionStorage.getItem('lastPosition'));

        let position = history.state;

        if (position === null) {
            position = lastPosition + 1;
            history.replaceState(position, null);
        }

        sessionStorage.setItem('lastPosition', String(position));

        this.pageDirection = position - lastPosition < 0 ? -1 : 1;
    };

    // Public methods

    static getNext = page => {
        let index = this.pages.indexOf(page);

        if (!~index || ++index > this.pages.length - 1) {
            index = 0;
        }

        return this.pages[index];
    };
}

class UIContainer extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();

        this.addListeners();
        this.onResize();
    }

    init() {
        this.invisible();
        this.css({
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            height: '100%',
            padding: '55px 0'
        });
    }

    initViews() {
        const { data } = router.get(location.pathname);

        this.title = new Title(data.title.replace(/[\s.-]+/g, '_'));
        this.title.css({
            width: 'fit-content',
            pointerEvents: 'auto'
        });
        this.add(this.title);

        const next = Data.getNext(data);
        const path = router.getPath(next.path);

        this.link = new Link('Next', `${path}/`);
        this.link.css({ marginTop: 'auto' });
        this.add(this.link);
    }

    addListeners() {
        window.addEventListener('popstate', this.onPopState);
        window.addEventListener('resize', this.onResize);
        this.link.events.on('click', this.onClick);
    }

    // Event handlers

    onPopState = () => {
        const { data } = router.get(location.pathname);

        clearTween(this.timeout);

        this.timeout = delayedCall(300, () => {
            this.title.setTitle(data.title.replace(/[\s.-]+/g, '_'), Data.pageDirection);
        });

        const next = Data.getNext(data);
        const path = router.getPath(next.path);

        this.link.setLink(`${path}/`);
    };

    onResize = () => {
        const width = document.documentElement.clientWidth;

        if (width < breakpoint) {
            this.css({
                padding: '24px 0'
            });
        } else {
            this.css({
                padding: '55px 0'
            });
        }
    };

    onClick = (e, { target }) => {
        e.preventDefault();

        router.setPath(target.link);
    };

    // Public methods

    animateIn = () => {
        this.visible();

        const duration = 2000;
        const stagger = 175;

        this.children.forEach((view, i) => {
            view.css({ opacity: 0 }).tween({ opacity: 1 }, duration, 'easeOutCubic', i * stagger);
        });

        this.title.animateIn();
        this.link.animateIn();
    };
}

class TransitionMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap1: { value: null },
                tMap2: { value: null },
                uProgress: { value: 0 },
                uSize: { value: 0.04 },
                uZoom: { value: 50 },
                uColorSeparation: { value: 0.3 },
                uResolution: { value: new Vector2() },
                uTime: { value: 0 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tMap1;
                uniform sampler2D tMap2;
                uniform float uProgress;
                uniform vec2 uResolution;
                uniform float uTime;

                in vec2 vUv;

                out vec4 FragColor;

                // Based on https://gl-transitions.com/editor/flyeye by gre

                uniform float uSize;
                uniform float uZoom;
                uniform float uColorSeparation;

                void main() {
                    if (uProgress == 0.0) {
                        FragColor = texture(tMap1, vUv);
                        return;
                    } else if (uProgress == 1.0) {
                        FragColor = texture(tMap2, vUv);
                        return;
                    }

                    float inv = 1.0 - uProgress;
                    vec2 disp = uSize * vec2(cos(uZoom * vUv.x), sin(uZoom * vUv.y));

                    vec4 texTo = texture(tMap2, vUv + inv * disp);
                    vec4 texFrom = vec4(
                        texture(tMap1, vUv + uProgress * disp * (1.0 - uColorSeparation)).r,
                        texture(tMap1, vUv + uProgress * disp).g,
                        texture(tMap1, vUv + uProgress * disp * (1.0 + uColorSeparation)).b,
                        1.0
                    );

                    FragColor = texTo * uProgress + texFrom * inv;
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

class RenderScene {
    constructor() {
        this.initRenderer();
        this.initLights();
        this.initEnvironment();
    }

    initRenderer() {
        const { renderer, camera } = WorldController;

        this.renderer = renderer;
        this.camera = camera;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1);
    }

    initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    async initEnvironment() {
        const { loadEnvironmentTexture } = WorldController;

        this.scene.environment = await loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    // Inheritable methods

    resize(width, height, dpr) {
        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);
    }

    update() {
        // Renderer state
        const currentRenderTarget = this.renderer.getRenderTarget();

        // Scene pass
        this.renderer.setRenderTarget(this.renderTarget);
        this.renderer.render(this.scene, this.camera);

        // Restore renderer settings
        this.renderer.setRenderTarget(currentRenderTarget);
    }
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };
}

class AbstractCubeScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.abstractCube = new AbstractCube();
        this.scene.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.abstractCube.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.abstractCube.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };
}

class FloatingCrystalScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.floatingCrystal = new FloatingCrystal();
        this.scene.add(this.floatingCrystal);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.floatingCrystal.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.floatingCrystal.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };
}

class DarkPlanetScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.scene.add(this.darkPlanet);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.darkPlanet.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.darkPlanet.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class SceneView extends Component {
    constructor() {
        super();

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanetScene();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystalScene();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCubeScene();
        this.add(this.abstractCube);
    }

    // Public methods

    resize = (width, height, dpr) => {
        this.darkPlanet.resize(width, height, dpr);
        this.floatingCrystal.resize(width, height, dpr);
        this.abstractCube.resize(width, height, dpr);
    };

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;
    }

    static addListeners() {
        window.addEventListener('popstate', this.onPopState);
    }

    // Event handlers

    static onPopState = () => {
        const { data } = router.get(location.pathname);

        let view;

        switch (data.path) {
            case '/dark_planet':
                view = this.view.darkPlanet;
                break;
            case '/floating_crystal':
                view = this.view.floatingCrystal;
                break;
            case '/abstract_cube':
                view = this.view.abstractCube;
                break;
        }

        RenderManager.setView(view);
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.view.resize(width, height, dpr);
    };

    static update = time => {
        this.view.update(time);
    };

    static animateIn = () => {
        this.addListeners();
        this.onPopState();
    };

    static ready = () => this.view.ready();
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial, transitionMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Size',
                min: 0,
                max: 1,
                step: 0.01,
                value: transitionMaterial.uniforms.uSize.value,
                callback: value => {
                    transitionMaterial.uniforms.uSize.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Zoom',
                min: 0,
                max: 100,
                step: 0.1,
                value: transitionMaterial.uniforms.uZoom.value,
                callback: value => {
                    transitionMaterial.uniforms.uZoom.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Chroma',
                min: 0,
                max: 10,
                step: 0.1,
                value: transitionMaterial.uniforms.uColorSeparation.value,
                callback: value => {
                    transitionMaterial.uniforms.uColorSeparation.value = value;
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer) {
        this.renderer = renderer;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.animatedIn = false;

        this.initRenderer();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetBright = this.renderTarget.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTarget.clone());
            this.renderTargetsVertical.push(this.renderTarget.clone());
        }

        this.renderTarget.depthBuffer = true;

        // Transition material
        this.transitionMaterial = new TransitionMaterial();

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite material
        this.compositeMaterial = new SceneCompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    // Public methods

    static setView = (view, direction = 1) => {
        if (this.view) {
            this.next = view;
            this.direction = direction;

            const start = () => {
                const next = this.next;
                next.scene.visible = true;

                const direction = this.direction;

                this.transitionMaterial.uniforms.tMap2.value = next.renderTarget.texture;
                tween(this.transitionMaterial.uniforms.uProgress, { value: 1 }, 1500, 'easeInOutCubic', () => {
                    this.transitionMaterial.uniforms.tMap1.value = next.renderTarget.texture;
                    this.transitionMaterial.uniforms.uProgress.value = 0;
                    this.view.scene.visible = false;
                    this.view = next;

                    if (this.next !== this.view) {
                        start();
                    } else {
                        this.animatedIn = false;
                    }
                }, () => {
                    // Camera parallax by moving the entire scene
                    this.view.scene.position.y = 1.5 * this.transitionMaterial.uniforms.uProgress.value * direction;
                    next.scene.position.y = -1.5 * (1 - this.transitionMaterial.uniforms.uProgress.value) * direction;
                });
            };

            if (!this.animatedIn) {
                this.animatedIn = true;

                start();
            }
        } else {
            // First view
            view.scene.visible = true;
            this.transitionMaterial.uniforms.tMap1.value = view.renderTarget.texture;
            this.view = view;
        }
    };

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        const renderer = this.renderer;

        const renderTarget = this.renderTarget;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Scene composite pass
        this.screen.material = this.transitionMaterial;
        renderer.setRenderTarget(renderTarget);
        renderer.render(this.screen, this.screenCamera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
        this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLoaders();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // Global 3D camera
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initRouter();
        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init();
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initRouter() {
        Data.pages.forEach(page => {
            router.add(page.path, Page, page);
        });

        // Landing and 404 page
        const home = Data.pages[0]; // Dark Planet

        router.add('/', Page, home);
        router.add('404', Page, home);

        router.init({
            path: basePath,
            scrollRestoration: 'auto'
        });
    }

    static initViews() {
        this.view = new SceneView();

        this.ui = new UI({ fps: true, breakpoint });
        this.ui.container = new UIContainer();
        this.ui.add(this.ui.container);
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize(width, height, dpr);
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        this.ui.animateIn();
        this.ui.container.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/scroll/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Smooth Scroll — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">

    <style>
        *, :after, :before {
            touch-action: unset;
        }

        body {
            position: unset;
        }

        h1 {
            margin: 0;
        }

        .link {
            font-weight: 400;
            font-size: 13px;
            line-height: 1.4;
        }
    </style>

    <script type="module" src="main.js"></script>
</head>
<body>
    <div id="root"></div>
</body>
</html>



---
File: /examples/three/transitions/scroll/main.js
---

import { AssetLoader, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, Component, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, Link, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, SmoothViews, Stage, TextureLoader, Title, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, defer, delayedCall, getFullscreenTriangle, ticker } from '../../../../build/alien.three.js';

const isDebug = /[?&]debug/.test(location.search);

const breakpoint = 1000;

class Data {
    static init({ pages }) {
        this.sections = pages;
        this.sectionIndex = 0;

        this.setIndexes();
    }

    static setIndexes() {
        this.sections.forEach((section, i) => section.index = i);
    }

    // Public methods

    static setSection = index => {
        if (index !== this.sectionIndex) {
            this.sectionIndex = index;

            RenderManager.setView(index);
        }
    };

    static getNext = () => {
        let index = this.sectionIndex + 1;

        if (index > this.sections.length - 1) {
            index = 0;
        }

        return this.sections[index];
    };
}

class UIContainer extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();

        this.addListeners();
        this.onResize();
    }

    init() {
        this.invisible();
        this.css({
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            height: '100%',
            padding: '55px 0'
        });
    }

    initViews() {
        this.title = new Title(Data.sections[Data.sectionIndex].title.replace(/[\s.-]+/g, '_'));
        this.title.css({
            width: 'fit-content',
            pointerEvents: 'auto'
        });
        this.add(this.title);

        this.link = new Link('Next');
        this.link.css({ marginTop: 'auto' });
        this.add(this.link);
    }

    addListeners() {
        Stage.events.on('view_change', this.onViewChange);
        window.addEventListener('resize', this.onResize);
        this.link.events.on('click', this.onClick);
    }

    // Event handlers

    onViewChange = ({ index }) => {
        clearTween(this.timeout);

        this.timeout = delayedCall(300, () => {
            this.title.setTitle(Data.sections[index].title.replace(/[\s.-]+/g, '_'));
        });
    };

    onResize = () => {
        const width = document.documentElement.clientWidth;

        if (width < breakpoint) {
            this.css({
                padding: '24px 0'
            });
        } else {
            this.css({
                padding: '55px 0'
            });
        }
    };

    onClick = e => {
        e.preventDefault();

        const next = Data.getNext();

        Data.setSection(next.index);
    };

    // Public methods

    animateIn = () => {
        this.visible();

        const duration = 2000;
        const stagger = 175;

        this.children.forEach((view, i) => {
            view.css({ opacity: 0 }).tween({ opacity: 1 }, duration, 'easeOutCubic', i * stagger);
        });

        this.link.animateIn();
    };
}

class Section extends Interface {
    constructor({ title, index }) {
        super('.section');

        this.title = title;
        this.index = index;

        this.init();
        this.initViews();

        this.addListeners();
    }

    init() {
        this.css({
            position: 'relative',
            height: '100svh'
        });

        if (isDebug) {
            this.css({
                backgroundColor: `rgb(
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    / 0.5
                )`
            });
        }
    }

    initViews() {
    }

    async addListeners() {
        await defer();

        this.observer = new IntersectionObserver(this.onIntersect, {
            threshold: 0.5
        });
        this.observer.observe(this.element);
    }

    // Event handlers

    onIntersect = ([entry]) => {
        if (entry.isIntersecting) {
            Stage.events.emit('view_change', { index: this.index });
        }
    };
}

class Container extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();
    }

    init() {
        this.css({ position: 'static' });
    }

    initViews() {
        this.darkPlanet = new Section(Data.sections[0]);
        this.add(this.darkPlanet);

        this.floatingCrystal = new Section(Data.sections[1]);
        this.add(this.floatingCrystal);

        this.abstractCube = new Section(Data.sections[2]);
        this.add(this.abstractCube);
    }
}

class TransitionMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap1: { value: null },
                tMap2: { value: null },
                uProgress: { value: 0 },
                uSize: { value: 0.04 },
                uZoom: { value: 50 },
                uColorSeparation: { value: 0.3 },
                uResolution: { value: new Vector2() },
                uTime: { value: 0 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tMap1;
                uniform sampler2D tMap2;
                uniform float uProgress;
                uniform vec2 uResolution;
                uniform float uTime;

                in vec2 vUv;

                out vec4 FragColor;

                // Based on https://gl-transitions.com/editor/flyeye by gre

                uniform float uSize;
                uniform float uZoom;
                uniform float uColorSeparation;

                void main() {
                    if (uProgress == 0.0) {
                        FragColor = texture(tMap1, vUv);
                        return;
                    } else if (uProgress == 1.0) {
                        FragColor = texture(tMap2, vUv);
                        return;
                    }

                    float inv = 1.0 - uProgress;
                    vec2 disp = uSize * vec2(cos(uZoom * vUv.x), sin(uZoom * vUv.y));

                    vec4 texTo = texture(tMap2, vUv + inv * disp);
                    vec4 texFrom = vec4(
                        texture(tMap1, vUv + uProgress * disp * (1.0 - uColorSeparation)).r,
                        texture(tMap1, vUv + uProgress * disp).g,
                        texture(tMap1, vUv + uProgress * disp * (1.0 + uColorSeparation)).b,
                        1.0
                    );

                    FragColor = texTo * uProgress + texFrom * inv;
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

class RenderScene {
    constructor() {
        this.initRenderer();
        this.initLights();
        this.initEnvironment();
    }

    initRenderer() {
        const { renderer, camera } = WorldController;

        this.renderer = renderer;
        this.camera = camera;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1);
    }

    initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    async initEnvironment() {
        const { loadEnvironmentTexture } = WorldController;

        this.scene.environment = await loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    // Inheritable methods

    resize(width, height, dpr) {
        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);
    }

    update() {
        // Renderer state
        const currentRenderTarget = this.renderer.getRenderTarget();

        // Scene pass
        this.renderer.setRenderTarget(this.renderTarget);
        this.renderer.render(this.scene, this.camera);

        // Restore renderer settings
        this.renderer.setRenderTarget(currentRenderTarget);
    }
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };
}

class AbstractCubeScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.abstractCube = new AbstractCube();
        this.scene.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.abstractCube.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.abstractCube.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };
}

class FloatingCrystalScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.floatingCrystal = new FloatingCrystal();
        this.scene.add(this.floatingCrystal);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.floatingCrystal.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.floatingCrystal.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };
}

class DarkPlanetScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.scene.add(this.darkPlanet);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.darkPlanet.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.darkPlanet.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class SceneView extends Component {
    constructor() {
        super();

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanetScene();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystalScene();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCubeScene();
        this.add(this.abstractCube);
    }

    // Public methods

    resize = (width, height, dpr) => {
        this.darkPlanet.resize(width, height, dpr);
        this.floatingCrystal.resize(width, height, dpr);
        this.abstractCube.resize(width, height, dpr);
    };

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;
    }

    // Public methods

    static resize = (width, height, dpr) => {
        this.view.resize(width, height, dpr);
    };

    static update = time => {
        this.view.update(time);
    };

    static animateIn = () => {
    };

    static ready = () => this.view.ready();
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial, transitionMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Size',
                min: 0,
                max: 1,
                step: 0.01,
                value: transitionMaterial.uniforms.uSize.value,
                callback: value => {
                    transitionMaterial.uniforms.uSize.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Zoom',
                min: 0,
                max: 100,
                step: 0.1,
                value: transitionMaterial.uniforms.uZoom.value,
                callback: value => {
                    transitionMaterial.uniforms.uZoom.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Chroma',
                min: 0,
                max: 10,
                step: 0.1,
                value: transitionMaterial.uniforms.uColorSeparation.value,
                callback: value => {
                    transitionMaterial.uniforms.uColorSeparation.value = value;
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Lerp',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.smooth.lerpSpeed,
                callback: value => {
                    RenderManager.smooth.lerpSpeed = value;
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, view, container) {
        this.renderer = renderer;
        this.views = view.children;
        this.container = container;
        this.sections = container.children;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.animatedIn = false;

        this.initRenderer();

        this.addListeners();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetBright = this.renderTarget.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTarget.clone());
            this.renderTargetsVertical.push(this.renderTarget.clone());
        }

        this.renderTarget.depthBuffer = true;

        // Transition material
        this.transitionMaterial = new TransitionMaterial();

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite material
        this.compositeMaterial = new SceneCompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    static addListeners() {
        this.smooth = new SmoothViews({
            views: this.views,
            root: Stage,
            container: this.container,
            sections: this.sections,
            lerpSpeed: 0.075
        });
    }

    // Public methods

    static setView = index => {
        this.smooth.setScroll(index);
    };

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        if (!this.animatedIn) {
            return;
        }

        const renderer = this.renderer;

        const renderTarget = this.renderTarget;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Toggle visibility when switching sections
        if (this.index1 !== this.smooth.index1) {
            this.views[this.index1].scene.visible = false;
            this.views[this.index2].scene.visible = false;

            this.index1 = this.smooth.index1;
            this.index2 = this.smooth.index2;

            this.views[this.index1].scene.visible = true;
            this.views[this.index2].scene.visible = true;
        }

        // Scene composite pass
        this.transitionMaterial.uniforms.tMap1.value = this.views[this.index1].renderTarget.texture;
        this.transitionMaterial.uniforms.tMap2.value = this.views[this.index2].renderTarget.texture;
        this.transitionMaterial.uniforms.uProgress.value = this.smooth.progress;
        this.screen.material = this.transitionMaterial;
        renderer.setRenderTarget(renderTarget);
        renderer.render(this.screen, this.screenCamera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
        this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };

    static animateIn = () => {
        this.index1 = 0;
        this.index2 = 1;
        this.views[this.index1].scene.visible = true;
        this.views[this.index2].scene.visible = true;
        this.animatedIn = true;
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLoaders();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // Global 3D camera
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init(document.querySelector('#root'));
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initViews() {
        this.view = new SceneView();

        this.container = new Container();
        Stage.add(this.container);

        this.ui = new UI({ fps: true, breakpoint });
        this.ui.container = new UIContainer();
        this.ui.add(this.ui.container);
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer, this.view, this.container);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize(width, height, dpr);
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        RenderManager.animateIn();
        this.ui.animateIn();
        this.ui.container.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/scroll_content/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Smooth Scroll — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">

    <style>
        *, :after, :before {
            touch-action: unset;
        }

        body {
            position: unset;
        }
    </style>

    <script type="module" src="main.js"></script>
</head>
<body>
    <div id="root"></div>
</body>
</html>



---
File: /examples/three/transitions/scroll_content/main.js
---

import { AssetLoader, BloomCompositeMaterial, BlurMaterial, BoxGeometry, Color, ColorManagement, Details, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, Smooth, Stage, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, defer, getFullscreenTriangle, ticker, tween } from '../../../../build/alien.three.js';

const isDebug = /[?&]debug/.test(location.search);

const breakpoint = 1000;

class Data {
    static init({ pages }) {
        this.sections = pages;
        this.sectionIndex = 0;

        this.setIndexes();
    }

    static setIndexes() {
        this.sections.forEach((section, i) => section.index = i);
    }
}

class Section extends Interface {
    constructor({ title, index }) {
        super('.section');

        this.title = title;
        this.index = index;
        this.animatedIn = false;

        this.init();
        this.initViews();

        this.addListeners();
    }

    init() {
        this.css({
            position: 'relative',
            height: '100svh'
        });

        if (isDebug) {
            this.css({
                backgroundColor: `rgb(
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    / 0.5
                )`
            });
        }
    }

    initViews() {
        this.details = new Details({
            title: this.title.replace(/[\s.-]+/g, '_'),
            content: [
                {
                    content: /* html */ `
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
                    `,
                    links: [
                        {
                            title: 'Lorem ipsum',
                            link: 'https://en.wikipedia.org/wiki/Lorem_ipsum'
                        }
                    ]
                }
            ]
        });
        this.add(this.details);
    }

    async addListeners() {
        await defer();

        this.observer = new IntersectionObserver(this.onIntersect, {
            threshold: 0.5
        });
        this.observer.observe(this.element);
    }

    // Event handlers

    onIntersect = ([entry]) => {
        if (entry.isIntersecting) {
            Stage.events.emit('view_change', { index: this.index });

            if (!this.animatedIn) {
                this.animatedIn = true;

                this.details.animateIn();
            }
        }
    };
}

class Container extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();
    }

    init() {
        this.css({ position: 'static' });
    }

    initViews() {
        this.darkPlanet = new Section(Data.sections[0]);
        this.add(this.darkPlanet);

        this.floatingCrystal = new Section(Data.sections[1]);
        this.add(this.floatingCrystal);

        this.abstractCube = new Section(Data.sections[2]);
        this.add(this.abstractCube);
    }
}

import rgbshift from '../../../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
import dither from '../../../../src/shaders/modules/dither/dither.glsl.js';

class CompositeMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tScene: { value: null },
                uColor: { value: new Color(0x060606) },
                uRGBAmount: { value: 1.5 },
                uOpacity: { value: 0 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tScene;
                uniform vec3 uColor;
                uniform float uRGBAmount;
                uniform float uOpacity;

                in vec2 vUv;

                out vec4 FragColor;

                ${rgbshift}
                ${dither}

                void main() {
                    FragColor = getRGB(tScene, vUv, 0.1, 0.002 * uRGBAmount * (1.0 - uOpacity));

                    FragColor.rgb = mix(uColor, FragColor.rgb, uOpacity);

                    FragColor.rgb = dither(FragColor.rgb);
                    FragColor.a = 1.0;
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };

    ready = () => this.initMesh();
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };

    ready = () => this.initMesh();
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };

    ready = () => this.initMesh();
}

class SceneView extends Group {
    constructor() {
        super();

        this.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystal();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCube();
        this.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;

        this.addListeners();
    }

    static addListeners() {
        Stage.events.on('view_change', this.onViewChange);
    }

    // Event handlers

    static onViewChange = ({ index }) => {
        if (index !== Data.sectionIndex) {
            Data.sectionIndex = index;

            RenderManager.setView(index);
        }
    };

    // Public methods

    static setView = index => {
        this.view.darkPlanet.visible = false;
        this.view.floatingCrystal.visible = false;
        this.view.abstractCube.visible = false;

        switch (index) {
            case 0:
                this.view.darkPlanet.visible = true;
                break;
            case 1:
                this.view.floatingCrystal.visible = true;
                break;
            case 2:
                this.view.abstractCube.visible = true;
                break;
        }
    };

    static resize = () => {
    };

    static update = time => {
        if (!this.view.visible) {
            return;
        }

        this.view.update(time);
    };

    static animateIn = () => {
        this.setView(Data.sectionIndex);

        this.view.visible = true;
    };

    static ready = async () => {
        await this.view.ready();

        // Prerender
        this.view.visible = true;
        RenderManager.update();
        this.view.visible = false;
    };
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Blur',
                min: 0,
                max: 10,
                step: 0.1,
                value: RenderManager.blurAmount,
                callback: value => {
                    RenderManager.blurAmount = value;
                }
            },
            {
                type: 'slider',
                name: 'Opacity',
                min: 0,
                max: 1,
                step: 0.01,
                value: 1,
                callback: value => {
                    compositeMaterial.uniforms.uOpacity.value = value;
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Lerp',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.smooth.lerpSpeed,
                callback: value => {
                    RenderManager.smooth.lerpSpeed = value;
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, scene, camera, view, container) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.views = view.children;
        this.container = container;
        this.sections = container.children;

        // Gaussian blur
        this.blurAmount = 10;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.enabled = true;
        this.animatedIn = false;

        this.initRenderer();

        this.addListeners();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTargetA = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetB = this.renderTargetA.clone();

        this.renderTargetBright = this.renderTargetA.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTargetA.clone());
            this.renderTargetsVertical.push(this.renderTargetA.clone());
        }

        this.renderTargetA.depthBuffer = true;

        // Gaussian blur materials
        this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
        this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

        this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
        this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite materials
        this.sceneCompositeMaterial = new SceneCompositeMaterial();
        this.compositeMaterial = new CompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    static addListeners() {
        this.smooth = new Smooth({
            root: Stage,
            container: this.container,
            lerpSpeed: 0.075
        });
    }

    // Public methods

    static setView = index => {
        this.next = index;

        const start = () => {
            const next = this.next;

            this.animateOut(() => {
                SceneController.setView(next);

                this.animateIn(() => {
                    this.index = next;

                    if (this.next !== this.index) {
                        start();
                    } else {
                        this.animatedIn = false;
                    }
                });
            });
        };

        if (!this.animatedIn) {
            this.animatedIn = true;

            start();
        }
    };

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTargetA.setSize(width, height);
        this.renderTargetB.setSize(width, height);

        // Gaussian blur
        this.hBlurMaterial.uniforms.uResolution.value.set(width, height);
        this.vBlurMaterial.uniforms.uResolution.value.set(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        const renderer = this.renderer;
        const scene = this.scene;
        const camera = this.camera;

        if (!this.enabled) {
            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
            return;
        }

        const renderTargetA = this.renderTargetA;
        const renderTargetB = this.renderTargetB;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Scene pass
        renderer.setRenderTarget(renderTargetA);
        renderer.render(scene, camera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTargetA.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Scene composite pass
        this.sceneCompositeMaterial.uniforms.tScene.value = renderTargetA.texture;
        this.sceneCompositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.sceneCompositeMaterial;
        renderer.setRenderTarget(renderTargetB);
        renderer.render(this.screen, this.screenCamera);

        // Two pass Gaussian blur (horizontal and vertical)
        const blurAmount = MathUtils.clamp(MathUtils.inverseLerp(0.5, 0, this.compositeMaterial.uniforms.uOpacity.value), 0, 1);

        if (blurAmount) {
            this.hBlurMaterial.uniforms.tMap.value = renderTargetB.texture;
            this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount * blurAmount;
            this.screen.material = this.hBlurMaterial;
            renderer.setRenderTarget(renderTargetA);
            renderer.render(this.screen, this.screenCamera);

            this.vBlurMaterial.uniforms.tMap.value = renderTargetA.texture;
            this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount * blurAmount;
            this.screen.material = this.vBlurMaterial;
            renderer.setRenderTarget(renderTargetB);
            renderer.render(this.screen, this.screenCamera);
        }

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTargetB.texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };

    static animateOut = callback => {
        clearTween(this.compositeMaterial.uniforms.uOpacity);
        this.compositeMaterial.uniforms.uOpacity.value = 1;
        tween(this.compositeMaterial.uniforms.uOpacity, { value: 0 }, 300, 'linear', callback);
    };

    static animateIn = callback => {
        clearTween(this.compositeMaterial.uniforms.uOpacity);
        this.compositeMaterial.uniforms.uOpacity.value = 0;
        tween(this.compositeMaterial.uniforms.uOpacity, { value: 1 }, 300, 'linear', callback);
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLights();
        this.initLoaders();
        this.initEnvironment();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;
        this.camera.lookAt(-1.5, 0, -2);
        this.camera.zoom = 1.5;

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static async initEnvironment() {
        this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;

        if (width < breakpoint) {
            this.camera.lookAt(0, 0.5, -2);
            this.camera.zoom = 1;
        } else {
            this.camera.lookAt(-1.5, 0, -2);
            this.camera.zoom = 1.5;
        }

        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init(document.querySelector('#root'));
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initViews() {
        this.view = new SceneView();
        WorldController.scene.add(this.view);

        this.container = new Container();
        Stage.add(this.container);

        this.ui = new UI({ fps: true, breakpoint });
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer, scene, camera } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer, scene, camera, this.view, this.container);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize(width, height, dpr);
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        RenderManager.animateIn();
        this.ui.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/scroll_content_skew/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Smooth Scroll — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">

    <style>
        *, :after, :before {
            touch-action: unset;
        }

        body {
            position: unset;
        }
    </style>

    <script type="module" src="main.js"></script>
</head>
<body>
    <div id="root"></div>
</body>
</html>



---
File: /examples/three/transitions/scroll_content_skew/main.js
---

import { AssetLoader, BloomCompositeMaterial, BlurMaterial, BoxGeometry, Color, ColorManagement, Details, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, SmoothSkew, Stage, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, defer, getFullscreenTriangle, ticker, tween } from '../../../../build/alien.three.js';

const isDebug = /[?&]debug/.test(location.search);

const breakpoint = 1000;

class Data {
    static init({ pages }) {
        this.sections = pages;
        this.sectionIndex = 0;

        this.setIndexes();
    }

    static setIndexes() {
        this.sections.forEach((section, i) => section.index = i);
    }
}

class Section extends Interface {
    constructor({ title, index }) {
        super('.section');

        this.title = title;
        this.index = index;
        this.animatedIn = false;

        this.init();
        this.initViews();

        this.addListeners();
    }

    init() {
        this.css({
            position: 'relative',
            height: '100svh'
        });

        if (isDebug) {
            this.css({
                backgroundColor: `rgb(
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    / 0.5
                )`
            });
        }
    }

    initViews() {
        this.details = new Details({
            title: this.title.replace(/[\s.-]+/g, '_'),
            content: [
                {
                    content: /* html */ `
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
                    `,
                    links: [
                        {
                            title: 'Lorem ipsum',
                            link: 'https://en.wikipedia.org/wiki/Lorem_ipsum'
                        }
                    ]
                }
            ]
        });
        this.add(this.details);
    }

    async addListeners() {
        await defer();

        this.observer = new IntersectionObserver(this.onIntersect, {
            threshold: 0.5
        });
        this.observer.observe(this.element);
    }

    // Event handlers

    onIntersect = ([entry]) => {
        if (entry.isIntersecting) {
            Stage.events.emit('view_change', { index: this.index });

            if (!this.animatedIn) {
                this.animatedIn = true;

                this.details.animateIn();
            }
        }
    };
}

class Container extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();
    }

    init() {
        this.css({ position: 'static' });
    }

    initViews() {
        this.darkPlanet = new Section(Data.sections[0]);
        this.add(this.darkPlanet);

        this.floatingCrystal = new Section(Data.sections[1]);
        this.add(this.floatingCrystal);

        this.abstractCube = new Section(Data.sections[2]);
        this.add(this.abstractCube);
    }
}

import rgbshift from '../../../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
import dither from '../../../../src/shaders/modules/dither/dither.glsl.js';

class CompositeMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tScene: { value: null },
                uColor: { value: new Color(0x060606) },
                uRGBAmount: { value: 1.5 },
                uOpacity: { value: 0 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tScene;
                uniform vec3 uColor;
                uniform float uRGBAmount;
                uniform float uOpacity;

                in vec2 vUv;

                out vec4 FragColor;

                ${rgbshift}
                ${dither}

                void main() {
                    FragColor = getRGB(tScene, vUv, 0.1, 0.002 * uRGBAmount * (1.0 - uOpacity));

                    FragColor.rgb = mix(uColor, FragColor.rgb, uOpacity);

                    FragColor.rgb = dither(FragColor.rgb);
                    FragColor.a = 1.0;
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };

    ready = () => this.initMesh();
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };

    ready = () => this.initMesh();
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };

    ready = () => this.initMesh();
}

class SceneView extends Group {
    constructor() {
        super();

        this.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystal();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCube();
        this.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;

        this.addListeners();
    }

    static addListeners() {
        Stage.events.on('view_change', this.onViewChange);
    }

    // Event handlers

    static onViewChange = ({ index }) => {
        if (index !== Data.sectionIndex) {
            Data.sectionIndex = index;

            RenderManager.setView(index);
        }
    };

    // Public methods

    static setView = index => {
        this.view.darkPlanet.visible = false;
        this.view.floatingCrystal.visible = false;
        this.view.abstractCube.visible = false;

        switch (index) {
            case 0:
                this.view.darkPlanet.visible = true;
                break;
            case 1:
                this.view.floatingCrystal.visible = true;
                break;
            case 2:
                this.view.abstractCube.visible = true;
                break;
        }
    };

    static resize = () => {
    };

    static update = time => {
        if (!this.view.visible) {
            return;
        }

        this.view.update(time);
    };

    static animateIn = () => {
        this.setView(Data.sectionIndex);

        this.view.visible = true;
    };

    static ready = async () => {
        await this.view.ready();

        // Prerender
        this.view.visible = true;
        RenderManager.update();
        this.view.visible = false;
    };
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Blur',
                min: 0,
                max: 10,
                step: 0.1,
                value: RenderManager.blurAmount,
                callback: value => {
                    RenderManager.blurAmount = value;
                }
            },
            {
                type: 'slider',
                name: 'Opacity',
                min: 0,
                max: 1,
                step: 0.01,
                value: 1,
                callback: value => {
                    compositeMaterial.uniforms.uOpacity.value = value;
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Lerp',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.smooth.lerpSpeed,
                callback: value => {
                    RenderManager.smooth.lerpSpeed = value;
                }
            },
            {
                type: 'slider',
                name: 'Skew',
                min: 0,
                max: 10,
                step: 0.1,
                value: RenderManager.smooth.skew,
                callback: value => {
                    RenderManager.smooth.skew = value;
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, scene, camera, view, container) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.views = view.children;
        this.container = container;
        this.sections = container.children;

        // Gaussian blur
        this.blurAmount = 10;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.enabled = true;
        this.animatedIn = false;

        this.initRenderer();

        this.addListeners();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTargetA = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetB = this.renderTargetA.clone();

        this.renderTargetBright = this.renderTargetA.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTargetA.clone());
            this.renderTargetsVertical.push(this.renderTargetA.clone());
        }

        this.renderTargetA.depthBuffer = true;

        // Gaussian blur materials
        this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
        this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

        this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
        this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite materials
        this.sceneCompositeMaterial = new SceneCompositeMaterial();
        this.compositeMaterial = new CompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    static addListeners() {
        this.smooth = new SmoothSkew({
            root: Stage,
            container: this.container,
            lerpSpeed: 0.075,
            skew: 5
        });
    }

    // Public methods

    static setView = index => {
        this.next = index;

        const start = () => {
            const next = this.next;

            this.animateOut(() => {
                SceneController.setView(next);

                this.animateIn(() => {
                    this.index = next;

                    if (this.next !== this.index) {
                        start();
                    } else {
                        this.animatedIn = false;
                    }
                });
            });
        };

        if (!this.animatedIn) {
            this.animatedIn = true;

            start();
        }
    };

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTargetA.setSize(width, height);
        this.renderTargetB.setSize(width, height);

        // Gaussian blur
        this.hBlurMaterial.uniforms.uResolution.value.set(width, height);
        this.vBlurMaterial.uniforms.uResolution.value.set(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        const renderer = this.renderer;
        const scene = this.scene;
        const camera = this.camera;

        if (!this.enabled) {
            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
            return;
        }

        const renderTargetA = this.renderTargetA;
        const renderTargetB = this.renderTargetB;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Scene pass
        renderer.setRenderTarget(renderTargetA);
        renderer.render(scene, camera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTargetA.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Scene composite pass
        this.sceneCompositeMaterial.uniforms.tScene.value = renderTargetA.texture;
        this.sceneCompositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.sceneCompositeMaterial;
        renderer.setRenderTarget(renderTargetB);
        renderer.render(this.screen, this.screenCamera);

        // Two pass Gaussian blur (horizontal and vertical)
        const blurAmount = MathUtils.clamp(MathUtils.inverseLerp(0.5, 0, this.compositeMaterial.uniforms.uOpacity.value), 0, 1);

        if (blurAmount) {
            this.hBlurMaterial.uniforms.tMap.value = renderTargetB.texture;
            this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount * blurAmount;
            this.screen.material = this.hBlurMaterial;
            renderer.setRenderTarget(renderTargetA);
            renderer.render(this.screen, this.screenCamera);

            this.vBlurMaterial.uniforms.tMap.value = renderTargetA.texture;
            this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount * blurAmount;
            this.screen.material = this.vBlurMaterial;
            renderer.setRenderTarget(renderTargetB);
            renderer.render(this.screen, this.screenCamera);
        }

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTargetB.texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };

    static animateOut = callback => {
        clearTween(this.compositeMaterial.uniforms.uOpacity);
        this.compositeMaterial.uniforms.uOpacity.value = 1;
        tween(this.compositeMaterial.uniforms.uOpacity, { value: 0 }, 300, 'linear', callback);
    };

    static animateIn = callback => {
        clearTween(this.compositeMaterial.uniforms.uOpacity);
        this.compositeMaterial.uniforms.uOpacity.value = 0;
        tween(this.compositeMaterial.uniforms.uOpacity, { value: 1 }, 300, 'linear', callback);
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLights();
        this.initLoaders();
        this.initEnvironment();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;
        this.camera.lookAt(-1.5, 0, -2);
        this.camera.zoom = 1.5;

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static async initEnvironment() {
        this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;

        if (width < breakpoint) {
            this.camera.lookAt(0, 0.5, -2);
            this.camera.zoom = 1;
        } else {
            this.camera.lookAt(-1.5, 0, -2);
            this.camera.zoom = 1.5;
        }

        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init(document.querySelector('#root'));
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initViews() {
        this.view = new SceneView();
        WorldController.scene.add(this.view);

        this.container = new Container();
        Stage.add(this.container);

        this.ui = new UI({ fps: true, breakpoint });
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer, scene, camera } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer, scene, camera, this.view, this.container);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize(width, height, dpr);
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        RenderManager.animateIn();
        this.ui.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/scroll_content_views/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Smooth Scroll — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">

    <style>
        *, :after, :before {
            touch-action: unset;
        }

        body {
            position: unset;
        }
    </style>

    <script type="module" src="main.js"></script>
</head>
<body>
    <div id="root"></div>
</body>
</html>



---
File: /examples/three/transitions/scroll_content_views/main.js
---

import { AssetLoader, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, Component, Details, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, SmoothViews, Stage, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, defer, getFullscreenTriangle, ticker } from '../../../../build/alien.three.js';

const isDebug = /[?&]debug/.test(location.search);

const breakpoint = 1000;

class Data {
    static init({ pages }) {
        this.sections = pages;
        this.sectionIndex = 0;

        this.setIndexes();
    }

    static setIndexes() {
        this.sections.forEach((section, i) => section.index = i);
    }
}

class Section extends Interface {
    constructor({ title, index }) {
        super('.section');

        this.title = title;
        this.index = index;
        this.animatedIn = false;

        this.init();
        this.initViews();

        this.addListeners();
    }

    init() {
        this.css({
            position: 'relative',
            height: '100svh'
        });

        if (isDebug) {
            this.css({
                backgroundColor: `rgb(
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    / 0.5
                )`
            });
        }
    }

    initViews() {
        this.details = new Details({
            title: this.title.replace(/[\s.-]+/g, '_'),
            content: [
                {
                    content: /* html */ `
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
                    `,
                    links: [
                        {
                            title: 'Lorem ipsum',
                            link: 'https://en.wikipedia.org/wiki/Lorem_ipsum'
                        }
                    ]
                }
            ]
        });
        this.add(this.details);
    }

    async addListeners() {
        await defer();

        this.observer = new IntersectionObserver(this.onIntersect, {
            threshold: 0.5
        });
        this.observer.observe(this.element);
    }

    // Event handlers

    onIntersect = ([entry]) => {
        if (entry.isIntersecting) {
            if (!this.animatedIn) {
                this.animatedIn = true;

                this.details.animateIn();
            }
        }
    };
}

class Container extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();
    }

    init() {
        this.css({ position: 'static' });
    }

    initViews() {
        this.darkPlanet = new Section(Data.sections[0]);
        this.add(this.darkPlanet);

        this.floatingCrystal = new Section(Data.sections[1]);
        this.add(this.floatingCrystal);

        this.abstractCube = new Section(Data.sections[2]);
        this.add(this.abstractCube);
    }
}

class TransitionMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap1: { value: null },
                tMap2: { value: null },
                uProgress: { value: 0 },
                uSize: { value: 0.04 },
                uZoom: { value: 50 },
                uColorSeparation: { value: 0.3 },
                uResolution: { value: new Vector2() },
                uTime: { value: 0 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tMap1;
                uniform sampler2D tMap2;
                uniform float uProgress;
                uniform vec2 uResolution;
                uniform float uTime;

                in vec2 vUv;

                out vec4 FragColor;

                // Based on https://gl-transitions.com/editor/flyeye by gre

                uniform float uSize;
                uniform float uZoom;
                uniform float uColorSeparation;

                void main() {
                    if (uProgress == 0.0) {
                        FragColor = texture(tMap1, vUv);
                        return;
                    } else if (uProgress == 1.0) {
                        FragColor = texture(tMap2, vUv);
                        return;
                    }

                    float inv = 1.0 - uProgress;
                    vec2 disp = uSize * vec2(cos(uZoom * vUv.x), sin(uZoom * vUv.y));

                    vec4 texTo = texture(tMap2, vUv + inv * disp);
                    vec4 texFrom = vec4(
                        texture(tMap1, vUv + uProgress * disp * (1.0 - uColorSeparation)).r,
                        texture(tMap1, vUv + uProgress * disp).g,
                        texture(tMap1, vUv + uProgress * disp * (1.0 + uColorSeparation)).b,
                        1.0
                    );

                    FragColor = texTo * uProgress + texFrom * inv;
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

class RenderScene {
    constructor() {
        this.initRenderer();
        this.initLights();
        this.initEnvironment();
    }

    initRenderer() {
        const { renderer, camera } = WorldController;

        this.renderer = renderer;
        this.camera = camera;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1);
    }

    initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    async initEnvironment() {
        const { loadEnvironmentTexture } = WorldController;

        this.scene.environment = await loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    // Inheritable methods

    resize(width, height, dpr) {
        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);
    }

    update() {
        // Renderer state
        const currentRenderTarget = this.renderer.getRenderTarget();

        // Scene pass
        this.renderer.setRenderTarget(this.renderTarget);
        this.renderer.render(this.scene, this.camera);

        // Restore renderer settings
        this.renderer.setRenderTarget(currentRenderTarget);
    }
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };
}

class AbstractCubeScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.abstractCube = new AbstractCube();
        this.scene.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.abstractCube.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.abstractCube.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };
}

class FloatingCrystalScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.floatingCrystal = new FloatingCrystal();
        this.scene.add(this.floatingCrystal);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.floatingCrystal.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.floatingCrystal.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };
}

class DarkPlanetScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.scene.add(this.darkPlanet);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.darkPlanet.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.darkPlanet.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class SceneView extends Component {
    constructor() {
        super();

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanetScene();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystalScene();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCubeScene();
        this.add(this.abstractCube);
    }

    // Public methods

    resize = (width, height, dpr) => {
        this.darkPlanet.resize(width, height, dpr);
        this.floatingCrystal.resize(width, height, dpr);
        this.abstractCube.resize(width, height, dpr);
    };

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;
    }

    // Public methods

    static resize = (width, height, dpr) => {
        this.view.resize(width, height, dpr);
    };

    static update = time => {
        this.view.update(time);
    };

    static animateIn = () => {
    };

    static ready = () => this.view.ready();
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial, transitionMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Size',
                min: 0,
                max: 1,
                step: 0.01,
                value: transitionMaterial.uniforms.uSize.value,
                callback: value => {
                    transitionMaterial.uniforms.uSize.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Zoom',
                min: 0,
                max: 100,
                step: 0.1,
                value: transitionMaterial.uniforms.uZoom.value,
                callback: value => {
                    transitionMaterial.uniforms.uZoom.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Chroma',
                min: 0,
                max: 10,
                step: 0.1,
                value: transitionMaterial.uniforms.uColorSeparation.value,
                callback: value => {
                    transitionMaterial.uniforms.uColorSeparation.value = value;
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Lerp',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.smooth.lerpSpeed,
                callback: value => {
                    RenderManager.smooth.lerpSpeed = value;
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, view, container) {
        this.renderer = renderer;
        this.views = view.children;
        this.container = container;
        this.sections = container.children;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.animatedIn = false;

        this.initRenderer();

        this.addListeners();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetBright = this.renderTarget.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTarget.clone());
            this.renderTargetsVertical.push(this.renderTarget.clone());
        }

        this.renderTarget.depthBuffer = true;

        // Transition material
        this.transitionMaterial = new TransitionMaterial();

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite material
        this.compositeMaterial = new SceneCompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    static addListeners() {
        this.smooth = new SmoothViews({
            views: this.views,
            root: Stage,
            container: this.container,
            sections: this.sections,
            lerpSpeed: 0.075
        });
    }

    // Public methods

    static setView = index => {
        this.smooth.setScroll(index);
    };

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        if (!this.animatedIn) {
            return;
        }

        const renderer = this.renderer;

        const renderTarget = this.renderTarget;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Toggle visibility when switching sections
        if (this.index1 !== this.smooth.index1) {
            this.views[this.index1].scene.visible = false;
            this.views[this.index2].scene.visible = false;

            this.index1 = this.smooth.index1;
            this.index2 = this.smooth.index2;

            this.views[this.index1].scene.visible = true;
            this.views[this.index2].scene.visible = true;
        }

        // Camera parallax by moving the entire scene
        this.views[this.index1].scene.position.y = 1.5 * this.smooth.progress;
        this.views[this.index2].scene.position.y = -1.5 * (1 - this.smooth.progress);

        // Scene composite pass
        this.transitionMaterial.uniforms.tMap1.value = this.views[this.index1].renderTarget.texture;
        this.transitionMaterial.uniforms.tMap2.value = this.views[this.index2].renderTarget.texture;
        this.transitionMaterial.uniforms.uProgress.value = this.smooth.progress;
        this.screen.material = this.transitionMaterial;
        renderer.setRenderTarget(renderTarget);
        renderer.render(this.screen, this.screenCamera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
        this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };

    static animateIn = () => {
        this.index1 = 0;
        this.index2 = 1;
        this.views[this.index1].scene.visible = true;
        this.views[this.index2].scene.visible = true;
        this.animatedIn = true;
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLoaders();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // Global 3D camera
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;
        this.camera.lookAt(-1.5, 0, -2);
        this.camera.zoom = 1.5;

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;

        if (width < breakpoint) {
            this.camera.lookAt(0, 0.5, -2);
            this.camera.zoom = 1;
        } else {
            this.camera.lookAt(-1.5, 0, -2);
            this.camera.zoom = 1.5;
        }

        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init(document.querySelector('#root'));
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initViews() {
        this.view = new SceneView();

        this.container = new Container();
        Stage.add(this.container);

        this.ui = new UI({ fps: true, breakpoint });
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer, this.view, this.container);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize(width, height, dpr);
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        RenderManager.animateIn();
        this.ui.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/scroll_direction/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Smooth Scroll — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">

    <style>
        *, :after, :before {
            touch-action: unset;
        }

        body {
            position: unset;
        }

        h1 {
            margin: 0;
        }

        .link {
            font-weight: 400;
            font-size: 13px;
            line-height: 1.4;
        }
    </style>

    <script type="module" src="main.js"></script>
</head>
<body>
    <div id="root"></div>
</body>
</html>



---
File: /examples/three/transitions/scroll_direction/main.js
---

import { AssetLoader, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, Component, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, Link, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, SmoothViews, Stage, TextureLoader, Title, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, defer, delayedCall, getFullscreenTriangle, ticker } from '../../../../build/alien.three.js';

const isDebug = /[?&]debug/.test(location.search);

const breakpoint = 1000;

class Data {
    static init({ pages }) {
        this.sections = pages;
        this.sectionIndex = 0;

        this.setIndexes();
    }

    static setIndexes() {
        this.sections.forEach((section, i) => section.index = i);
    }

    // Public methods

    static setSection = index => {
        if (index !== this.sectionIndex) {
            this.sectionIndex = index;

            RenderManager.setView(index);
        }
    };

    static getNext = () => {
        let index = this.sectionIndex + 1;

        if (index > this.sections.length - 1) {
            index = 0;
        }

        return this.sections[index];
    };
}

class UIContainer extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();

        this.addListeners();
        this.onResize();
    }

    init() {
        this.invisible();
        this.css({
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            height: '100%',
            padding: '55px 0'
        });
    }

    initViews() {
        this.title = new Title(Data.sections[Data.sectionIndex].title.replace(/[\s.-]+/g, '_'));
        this.title.css({
            width: 'fit-content',
            pointerEvents: 'auto'
        });
        this.add(this.title);

        this.link = new Link('Next');
        this.link.css({ marginTop: 'auto' });
        this.add(this.link);
    }

    addListeners() {
        Stage.events.on('view_change', this.onViewChange);
        window.addEventListener('resize', this.onResize);
        this.link.events.on('click', this.onClick);
    }

    // Event handlers

    onViewChange = ({ index }) => {
        clearTween(this.timeout);

        this.timeout = delayedCall(300, () => {
            this.title.setTitle(Data.sections[index].title.replace(/[\s.-]+/g, '_'), RenderManager.smooth.direction);
        });
    };

    onResize = () => {
        const width = document.documentElement.clientWidth;

        if (width < breakpoint) {
            this.css({
                padding: '24px 0'
            });
        } else {
            this.css({
                padding: '55px 0'
            });
        }
    };

    onClick = e => {
        e.preventDefault();

        const next = Data.getNext();

        Data.setSection(next.index);
    };

    // Public methods

    animateIn = () => {
        this.visible();

        const duration = 2000;
        const stagger = 175;

        this.children.forEach((view, i) => {
            view.css({ opacity: 0 }).tween({ opacity: 1 }, duration, 'easeOutCubic', i * stagger);
        });

        this.link.animateIn();
    };
}

class Section extends Interface {
    constructor({ title, index }) {
        super('.section');

        this.title = title;
        this.index = index;

        this.init();
        this.initViews();

        this.addListeners();
    }

    init() {
        this.css({
            position: 'relative',
            height: '100svh'
        });

        if (isDebug) {
            this.css({
                backgroundColor: `rgb(
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    / 0.5
                )`
            });
        }
    }

    initViews() {
    }

    async addListeners() {
        await defer();

        this.observer = new IntersectionObserver(this.onIntersect, {
            threshold: 0.5
        });
        this.observer.observe(this.element);
    }

    // Event handlers

    onIntersect = ([entry]) => {
        if (entry.isIntersecting) {
            Stage.events.emit('view_change', { index: this.index });
        }
    };
}

class Container extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();
    }

    init() {
        this.css({ position: 'static' });
    }

    initViews() {
        this.darkPlanet = new Section(Data.sections[0]);
        this.add(this.darkPlanet);

        this.floatingCrystal = new Section(Data.sections[1]);
        this.add(this.floatingCrystal);

        this.abstractCube = new Section(Data.sections[2]);
        this.add(this.abstractCube);
    }
}

class TransitionMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap1: { value: null },
                tMap2: { value: null },
                uProgress: { value: 0 },
                uSize: { value: 0.04 },
                uZoom: { value: 50 },
                uColorSeparation: { value: 0.3 },
                uResolution: { value: new Vector2() },
                uTime: { value: 0 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tMap1;
                uniform sampler2D tMap2;
                uniform float uProgress;
                uniform vec2 uResolution;
                uniform float uTime;

                in vec2 vUv;

                out vec4 FragColor;

                // Based on https://gl-transitions.com/editor/flyeye by gre

                uniform float uSize;
                uniform float uZoom;
                uniform float uColorSeparation;

                void main() {
                    if (uProgress == 0.0) {
                        FragColor = texture(tMap1, vUv);
                        return;
                    } else if (uProgress == 1.0) {
                        FragColor = texture(tMap2, vUv);
                        return;
                    }

                    float inv = 1.0 - uProgress;
                    vec2 disp = uSize * vec2(cos(uZoom * vUv.x), sin(uZoom * vUv.y));

                    vec4 texTo = texture(tMap2, vUv + inv * disp);
                    vec4 texFrom = vec4(
                        texture(tMap1, vUv + uProgress * disp * (1.0 - uColorSeparation)).r,
                        texture(tMap1, vUv + uProgress * disp).g,
                        texture(tMap1, vUv + uProgress * disp * (1.0 + uColorSeparation)).b,
                        1.0
                    );

                    FragColor = texTo * uProgress + texFrom * inv;
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

class RenderScene {
    constructor() {
        this.initRenderer();
        this.initLights();
        this.initEnvironment();
    }

    initRenderer() {
        const { renderer, camera } = WorldController;

        this.renderer = renderer;
        this.camera = camera;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1);
    }

    initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    async initEnvironment() {
        const { loadEnvironmentTexture } = WorldController;

        this.scene.environment = await loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    // Inheritable methods

    resize(width, height, dpr) {
        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);
    }

    update() {
        // Renderer state
        const currentRenderTarget = this.renderer.getRenderTarget();

        // Scene pass
        this.renderer.setRenderTarget(this.renderTarget);
        this.renderer.render(this.scene, this.camera);

        // Restore renderer settings
        this.renderer.setRenderTarget(currentRenderTarget);
    }
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };
}

class AbstractCubeScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.abstractCube = new AbstractCube();
        this.scene.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.abstractCube.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.abstractCube.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };
}

class FloatingCrystalScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.floatingCrystal = new FloatingCrystal();
        this.scene.add(this.floatingCrystal);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.floatingCrystal.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.floatingCrystal.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };
}

class DarkPlanetScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.scene.add(this.darkPlanet);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.darkPlanet.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.darkPlanet.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class SceneView extends Component {
    constructor() {
        super();

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanetScene();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystalScene();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCubeScene();
        this.add(this.abstractCube);
    }

    // Public methods

    resize = (width, height, dpr) => {
        this.darkPlanet.resize(width, height, dpr);
        this.floatingCrystal.resize(width, height, dpr);
        this.abstractCube.resize(width, height, dpr);
    };

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;
    }

    // Public methods

    static resize = (width, height, dpr) => {
        this.view.resize(width, height, dpr);
    };

    static update = time => {
        this.view.update(time);
    };

    static animateIn = () => {
    };

    static ready = () => this.view.ready();
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial, transitionMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Size',
                min: 0,
                max: 1,
                step: 0.01,
                value: transitionMaterial.uniforms.uSize.value,
                callback: value => {
                    transitionMaterial.uniforms.uSize.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Zoom',
                min: 0,
                max: 100,
                step: 0.1,
                value: transitionMaterial.uniforms.uZoom.value,
                callback: value => {
                    transitionMaterial.uniforms.uZoom.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Chroma',
                min: 0,
                max: 10,
                step: 0.1,
                value: transitionMaterial.uniforms.uColorSeparation.value,
                callback: value => {
                    transitionMaterial.uniforms.uColorSeparation.value = value;
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Lerp',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.smooth.lerpSpeed,
                callback: value => {
                    RenderManager.smooth.lerpSpeed = value;
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, view, container) {
        this.renderer = renderer;
        this.views = view.children;
        this.container = container;
        this.sections = container.children;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.animatedIn = false;

        this.initRenderer();

        this.addListeners();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetBright = this.renderTarget.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTarget.clone());
            this.renderTargetsVertical.push(this.renderTarget.clone());
        }

        this.renderTarget.depthBuffer = true;

        // Transition material
        this.transitionMaterial = new TransitionMaterial();

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite material
        this.compositeMaterial = new SceneCompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    static addListeners() {
        this.smooth = new SmoothViews({
            views: this.views,
            root: Stage,
            container: this.container,
            sections: this.sections,
            lerpSpeed: 0.075
        });
    }

    // Public methods

    static setView = index => {
        this.smooth.setScroll(index);
    };

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        if (!this.animatedIn) {
            return;
        }

        const renderer = this.renderer;

        const renderTarget = this.renderTarget;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Toggle visibility when switching sections
        if (this.index1 !== this.smooth.index1) {
            this.views[this.index1].scene.visible = false;
            this.views[this.index2].scene.visible = false;

            this.index1 = this.smooth.index1;
            this.index2 = this.smooth.index2;

            this.views[this.index1].scene.visible = true;
            this.views[this.index2].scene.visible = true;
        }

        // Camera parallax by moving the entire scene
        this.views[this.index1].scene.position.y = 1.5 * this.smooth.progress;
        this.views[this.index2].scene.position.y = -1.5 * (1 - this.smooth.progress);

        // Scene composite pass
        this.transitionMaterial.uniforms.tMap1.value = this.views[this.index1].renderTarget.texture;
        this.transitionMaterial.uniforms.tMap2.value = this.views[this.index2].renderTarget.texture;
        this.transitionMaterial.uniforms.uProgress.value = this.smooth.progress;
        this.screen.material = this.transitionMaterial;
        renderer.setRenderTarget(renderTarget);
        renderer.render(this.screen, this.screenCamera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
        this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };

    static animateIn = () => {
        this.index1 = 0;
        this.index2 = 1;
        this.views[this.index1].scene.visible = true;
        this.views[this.index2].scene.visible = true;
        this.animatedIn = true;
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLoaders();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // Global 3D camera
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init(document.querySelector('#root'));
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initViews() {
        this.view = new SceneView();

        this.container = new Container();
        Stage.add(this.container);

        this.ui = new UI({ fps: true, breakpoint });
        this.ui.container = new UIContainer();
        this.ui.add(this.ui.container);
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer, this.view, this.container);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize(width, height, dpr);
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        RenderManager.animateIn();
        this.ui.animateIn();
        this.ui.container.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/scroll_direction_zoom/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Smooth Scroll — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">

    <style>
        *, :after, :before {
            touch-action: unset;
        }

        body {
            position: unset;
        }

        h1 {
            margin: 0;
        }

        .link {
            font-weight: 400;
            font-size: 13px;
            line-height: 1.4;
        }
    </style>

    <script type="module" src="main.js"></script>
</head>
<body>
    <div id="root"></div>
</body>
</html>



---
File: /examples/three/transitions/scroll_direction_zoom/main.js
---

import { AssetLoader, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, Component, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, Link, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, SmoothViews, Stage, TextureLoader, Title, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, defer, delayedCall, getFullscreenTriangle, ticker } from '../../../../build/alien.three.js';

const isDebug = /[?&]debug/.test(location.search);

const breakpoint = 1000;

class Data {
    static init({ pages }) {
        this.sections = pages;
        this.sectionIndex = 0;

        this.setIndexes();
    }

    static setIndexes() {
        this.sections.forEach((section, i) => section.index = i);
    }

    // Public methods

    static setSection = index => {
        if (index !== this.sectionIndex) {
            this.sectionIndex = index;

            RenderManager.setView(index);
        }
    };

    static getNext = () => {
        let index = this.sectionIndex + 1;

        if (index > this.sections.length - 1) {
            index = 0;
        }

        return this.sections[index];
    };
}

class UIContainer extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();

        this.addListeners();
        this.onResize();
    }

    init() {
        this.invisible();
        this.css({
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            height: '100%',
            padding: '55px 0'
        });
    }

    initViews() {
        this.title = new Title(Data.sections[Data.sectionIndex].title.replace(/[\s.-]+/g, '_'));
        this.title.css({
            width: 'fit-content',
            pointerEvents: 'auto'
        });
        this.add(this.title);

        this.link = new Link('Next');
        this.link.css({ marginTop: 'auto' });
        this.add(this.link);
    }

    addListeners() {
        Stage.events.on('view_change', this.onViewChange);
        window.addEventListener('resize', this.onResize);
        this.link.events.on('click', this.onClick);
    }

    // Event handlers

    onViewChange = ({ index }) => {
        clearTween(this.timeout);

        this.timeout = delayedCall(300, () => {
            this.title.setTitle(Data.sections[index].title.replace(/[\s.-]+/g, '_'), RenderManager.smooth.direction);
        });
    };

    onResize = () => {
        const width = document.documentElement.clientWidth;

        if (width < breakpoint) {
            this.css({
                padding: '24px 0'
            });
        } else {
            this.css({
                padding: '55px 0'
            });
        }
    };

    onClick = e => {
        e.preventDefault();

        const next = Data.getNext();

        Data.setSection(next.index);
    };

    // Public methods

    animateIn = () => {
        this.visible();

        const duration = 2000;
        const stagger = 175;

        this.children.forEach((view, i) => {
            view.css({ opacity: 0 }).tween({ opacity: 1 }, duration, 'easeOutCubic', i * stagger);
        });

        this.link.animateIn();
    };
}

class Section extends Interface {
    constructor({ title, index }) {
        super('.section');

        this.title = title;
        this.index = index;

        this.init();
        this.initViews();

        this.addListeners();
    }

    init() {
        this.css({
            position: 'relative',
            height: '100svh'
        });

        if (isDebug) {
            this.css({
                backgroundColor: `rgb(
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    ${Math.floor(Math.random() * 255)}
                    / 0.5
                )`
            });
        }
    }

    initViews() {
    }

    async addListeners() {
        await defer();

        this.observer = new IntersectionObserver(this.onIntersect, {
            threshold: 0.5
        });
        this.observer.observe(this.element);
    }

    // Event handlers

    onIntersect = ([entry]) => {
        if (entry.isIntersecting) {
            Stage.events.emit('view_change', { index: this.index });
        }
    };
}

class Container extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();
    }

    init() {
        this.css({ position: 'static' });
    }

    initViews() {
        this.darkPlanet = new Section(Data.sections[0]);
        this.add(this.darkPlanet);

        this.floatingCrystal = new Section(Data.sections[1]);
        this.add(this.floatingCrystal);

        this.abstractCube = new Section(Data.sections[2]);
        this.add(this.abstractCube);
    }
}

class TransitionMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap1: { value: null },
                tMap2: { value: null },
                uProgress: { value: 0 },
                uSize: { value: 0.04 },
                uZoom: { value: 50 },
                uColorSeparation: { value: 0.3 },
                uResolution: { value: new Vector2() },
                uTime: { value: 0 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tMap1;
                uniform sampler2D tMap2;
                uniform float uProgress;
                uniform vec2 uResolution;
                uniform float uTime;

                in vec2 vUv;

                out vec4 FragColor;

                // Based on https://gl-transitions.com/editor/flyeye by gre

                uniform float uSize;
                uniform float uZoom;
                uniform float uColorSeparation;

                void main() {
                    if (uProgress == 0.0) {
                        FragColor = texture(tMap1, vUv);
                        return;
                    } else if (uProgress == 1.0) {
                        FragColor = texture(tMap2, vUv);
                        return;
                    }

                    float inv = 1.0 - uProgress;
                    vec2 disp = uSize * vec2(cos(uZoom * vUv.x), sin(uZoom * vUv.y));

                    vec4 texTo = texture(tMap2, vUv + inv * disp);
                    vec4 texFrom = vec4(
                        texture(tMap1, vUv + uProgress * disp * (1.0 - uColorSeparation)).r,
                        texture(tMap1, vUv + uProgress * disp).g,
                        texture(tMap1, vUv + uProgress * disp * (1.0 + uColorSeparation)).b,
                        1.0
                    );

                    FragColor = texTo * uProgress + texFrom * inv;
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

class RenderScene {
    constructor() {
        this.initRenderer();
        this.initLights();
        this.initEnvironment();
    }

    initRenderer() {
        const { renderer, camera } = WorldController;

        this.renderer = renderer;
        this.camera = camera;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1);
    }

    initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    async initEnvironment() {
        const { loadEnvironmentTexture } = WorldController;

        this.scene.environment = await loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    // Inheritable methods

    resize(width, height, dpr) {
        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);
    }

    update() {
        // Renderer state
        const currentRenderTarget = this.renderer.getRenderTarget();

        // Scene pass
        this.renderer.setRenderTarget(this.renderTarget);
        this.renderer.render(this.scene, this.camera);

        // Restore renderer settings
        this.renderer.setRenderTarget(currentRenderTarget);
    }
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };
}

class AbstractCubeScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.abstractCube = new AbstractCube();
        this.scene.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.abstractCube.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.abstractCube.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };
}

class FloatingCrystalScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.floatingCrystal = new FloatingCrystal();
        this.scene.add(this.floatingCrystal);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.floatingCrystal.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.floatingCrystal.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };
}

class DarkPlanetScene extends RenderScene {
    constructor() {
        super();

        this.scene.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.scene.add(this.darkPlanet);
    }

    // Public methods

    update = time => {
        if (!this.scene.visible) {
            return;
        }

        this.darkPlanet.update(time);

        super.update();
    };

    ready = async () => {
        await Promise.all([
            this.darkPlanet.initMesh()
        ]);

        // Prerender
        this.scene.visible = true;
        super.update();
        this.scene.visible = false;
    };
}

class SceneView extends Component {
    constructor() {
        super();

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanetScene();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystalScene();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCubeScene();
        this.add(this.abstractCube);
    }

    // Public methods

    resize = (width, height, dpr) => {
        this.darkPlanet.resize(width, height, dpr);
        this.floatingCrystal.resize(width, height, dpr);
        this.abstractCube.resize(width, height, dpr);
    };

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;
    }

    // Public methods

    static resize = (width, height, dpr) => {
        this.view.resize(width, height, dpr);
    };

    static update = time => {
        this.view.update(time);
    };

    static animateIn = () => {
    };

    static ready = () => this.view.ready();
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial, transitionMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Size',
                min: 0,
                max: 1,
                step: 0.01,
                value: transitionMaterial.uniforms.uSize.value,
                callback: value => {
                    transitionMaterial.uniforms.uSize.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Zoom',
                min: 0,
                max: 100,
                step: 0.1,
                value: transitionMaterial.uniforms.uZoom.value,
                callback: value => {
                    transitionMaterial.uniforms.uZoom.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Chroma',
                min: 0,
                max: 10,
                step: 0.1,
                value: transitionMaterial.uniforms.uColorSeparation.value,
                callback: value => {
                    transitionMaterial.uniforms.uColorSeparation.value = value;
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Lerp',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.smooth.lerpSpeed,
                callback: value => {
                    RenderManager.smooth.lerpSpeed = value;
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, view, container) {
        this.renderer = renderer;
        this.views = view.children;
        this.container = container;
        this.sections = container.children;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.animatedIn = false;

        this.initRenderer();

        this.addListeners();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetBright = this.renderTarget.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTarget.clone());
            this.renderTargetsVertical.push(this.renderTarget.clone());
        }

        this.renderTarget.depthBuffer = true;

        // Transition material
        this.transitionMaterial = new TransitionMaterial();

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite material
        this.compositeMaterial = new SceneCompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    static addListeners() {
        this.smooth = new SmoothViews({
            views: this.views,
            root: Stage,
            container: this.container,
            sections: this.sections,
            lerpSpeed: 0.075
        });
    }

    // Public methods

    static setView = index => {
        this.smooth.setScroll(index);
    };

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        if (!this.animatedIn) {
            return;
        }

        const renderer = this.renderer;

        const renderTarget = this.renderTarget;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Toggle visibility when switching sections
        if (this.index1 !== this.smooth.index1) {
            this.views[this.index1].scene.visible = false;
            this.views[this.index2].scene.visible = false;

            this.index1 = this.smooth.index1;
            this.index2 = this.smooth.index2;

            this.views[this.index1].scene.visible = true;
            this.views[this.index2].scene.visible = true;
        }

        // Camera parallax by moving the entire scene
        this.views[this.index1].scene.position.z = -15 * this.smooth.progress;
        this.views[this.index2].scene.position.z = 15 * (1 - this.smooth.progress);

        // Scene composite pass
        this.transitionMaterial.uniforms.tMap1.value = this.views[this.index1].renderTarget.texture;
        this.transitionMaterial.uniforms.tMap2.value = this.views[this.index2].renderTarget.texture;
        this.transitionMaterial.uniforms.uProgress.value = this.smooth.progress;
        this.screen.material = this.transitionMaterial;
        renderer.setRenderTarget(renderTarget);
        renderer.render(this.screen, this.screenCamera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
        this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };

    static animateIn = () => {
        this.index1 = 0;
        this.index2 = 1;
        this.views[this.index1].scene.visible = true;
        this.views[this.index2].scene.visible = true;
        this.animatedIn = true;
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLoaders();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // Global 3D camera
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init(document.querySelector('#root'));
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initViews() {
        this.view = new SceneView();

        this.container = new Container();
        Stage.add(this.container);

        this.ui = new UI({ fps: true, breakpoint });
        this.ui.container = new UIContainer();
        this.ui.add(this.ui.container);
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer, this.view, this.container);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize(width, height, dpr);
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        RenderManager.animateIn();
        this.ui.animateIn();
        this.ui.container.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/shader/abstract_cube/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Abstract Cube — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/shader/style.css">

    <script type="module" src="/examples/three/transitions/shader/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/shader/dark_planet/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Dark Planet — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/shader/style.css">

    <script type="module" src="/examples/three/transitions/shader/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/shader/floating_crystal/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Floating Crystal — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/shader/style.css">

    <script type="module" src="/examples/three/transitions/shader/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/shader/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Page Transition — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/shader/style.css">

    <script type="module" src="/examples/three/transitions/shader/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/shader/main.js
---

import { AssetLoader, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, Link, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, Stage, TextureLoader, Title, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, delayedCall, getFullscreenTriangle, router, ticker, tween } from '../../../../build/alien.three.js';

const basePath = '/examples/three/transitions/shader';
const breakpoint = 1000;

class Page {
    constructor({ path, title }) {
        this.path = path;
        this.title = title;

        document.title = `${this.title} — Alien.js`;
    }
}

class Data {
    static init({ pages }) {
        this.pages = pages;
    }

    // Public methods

    static getNext = page => {
        let index = this.pages.indexOf(page);

        if (!~index || ++index > this.pages.length - 1) {
            index = 0;
        }

        return this.pages[index];
    };
}

class UIContainer extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();

        this.addListeners();
        this.onResize();
    }

    init() {
        this.invisible();
        this.css({
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            height: '100%',
            padding: '55px 0'
        });
    }

    initViews() {
        const { data } = router.get(location.pathname);

        this.title = new Title(data.title.replace(/[\s.-]+/g, '_'));
        this.title.css({
            width: 'fit-content',
            pointerEvents: 'auto'
        });
        this.add(this.title);

        const next = Data.getNext(data);
        const path = router.getPath(next.path);

        this.link = new Link('Next', `${path}/`);
        this.link.css({ marginTop: 'auto' });
        this.add(this.link);
    }

    addListeners() {
        window.addEventListener('popstate', this.onPopState);
        window.addEventListener('resize', this.onResize);
        this.link.events.on('click', this.onClick);
    }

    // Event handlers

    onPopState = () => {
        const { data } = router.get(location.pathname);

        this.title.animateOut();
        this.link.animateOut();

        clearTween(this.timeout);

        RenderManager.animateOut(() => {
            SceneController.setView();

            this.timeout = delayedCall(950, () => {
                this.title.setTitle(data.title.replace(/[\s.-]+/g, '_'));
            });

            RenderManager.animateIn(() => {
                const next = Data.getNext(data);
                const path = router.getPath(next.path);

                this.link.setLink(`${path}/`);
                this.link.animateIn();
            });
        });
    };

    onResize = () => {
        const width = document.documentElement.clientWidth;

        if (width < breakpoint) {
            this.css({
                padding: '24px 0'
            });
        } else {
            this.css({
                padding: '55px 0'
            });
        }
    };

    onClick = (e, { target }) => {
        e.preventDefault();

        router.setPath(target.link);
    };

    // Public methods

    animateIn = () => {
        this.visible();

        const duration = 2000;
        const stagger = 175;

        this.children.forEach((view, i) => {
            view.css({ opacity: 0 }).tween({ opacity: 1 }, duration, 'easeOutCubic', i * stagger);
        });

        this.title.animateIn();
        this.link.animateIn();
    };
}

// Based on https://codepen.io/ReGGae/pen/rNxpVEd

class TransitionMaterial extends RawShaderMaterial {
    constructor({
        color
    } = {}) {
        super({
            glslVersion: GLSL3,
            uniforms: {
                uColor: { value: color instanceof Color ? color : new Color(color) },
                uProgress: { value: 0 },
                uPower: { value: 0 },
                uOut: { value: true }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                #define PI 3.1415926535897932384626433832795

                uniform vec3 uColor;
                uniform float uProgress;
                uniform float uPower;
                uniform bool uOut;

                in vec2 vUv;

                out vec4 FragColor;

                void main() {
                    vec2 uv = vUv;

                    uv.y -= (sin(uv.x * PI) * uPower) * 0.1;

                    if (!uOut) {
                        uv.y = 1.0 - uv.y;
                    }

                    float t = smoothstep(uv.y - fwidth(uv.y), uv.y, uProgress);

                    FragColor = mix(vec4(0), vec4(uColor, 1.0), t);
                }
            `,
            transparent: true,
            depthTest: false,
            depthWrite: false
        });
    }
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };

    ready = () => this.initMesh();
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };

    ready = () => this.initMesh();
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };

    ready = () => this.initMesh();
}

class SceneView extends Group {
    constructor() {
        super();

        this.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystal();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCube();
        this.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;
    }

    // Public methods

    static setView = () => {
        const { data } = router.get(location.pathname);

        this.view.darkPlanet.visible = false;
        this.view.floatingCrystal.visible = false;
        this.view.abstractCube.visible = false;

        switch (data.path) {
            case '/dark_planet':
                this.view.darkPlanet.visible = true;
                break;
            case '/floating_crystal':
                this.view.floatingCrystal.visible = true;
                break;
            case '/abstract_cube':
                this.view.abstractCube.visible = true;
                break;
        }
    };

    static resize = () => {
    };

    static update = time => {
        if (!this.view.visible) {
            return;
        }

        this.view.update(time);
    };

    static animateIn = () => {
        this.setView();

        this.view.visible = true;
    };

    static ready = async () => {
        await this.view.ready();

        // Prerender
        this.view.visible = true;
        RenderManager.update();
        this.view.visible = false;
    };
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial, transitionMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'color',
                value: transitionMaterial.uniforms.uColor.value,
                callback: value => {
                    transitionMaterial.uniforms.uColor.value.copy(value);
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, scene, camera) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.enabled = true;

        this.initRenderer();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Manually clear
        this.renderer.autoClear = false;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetBright = this.renderTarget.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTarget.clone());
            this.renderTargetsVertical.push(this.renderTarget.clone());
        }

        this.renderTarget.depthBuffer = true;

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite material
        this.compositeMaterial = new SceneCompositeMaterial();

        // Transition material
        this.transitionMaterial = new TransitionMaterial({
            color: 0x000000
        });
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    // Public methods

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTarget.setSize(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        const renderer = this.renderer;
        const scene = this.scene;
        const camera = this.camera;

        if (!this.enabled) {
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(scene, camera);
            return;
        }

        const renderTarget = this.renderTarget;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Scene pass
        renderer.setRenderTarget(renderTarget);
        renderer.clear();
        renderer.render(scene, camera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.clear();
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.clear();
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.clear();
        renderer.render(this.screen, this.screenCamera);

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
        this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.clear();
        renderer.render(this.screen, this.screenCamera);

        // Transition pass (render to screen)
        if (this.transitionMaterial.uniforms.uProgress.value > 0) {
            this.screen.material = this.transitionMaterial;
            renderer.render(this.screen, this.screenCamera);
        }
    };

    static animateOut = callback => {
        clearTween(this.transitionMaterial.uniforms.uProgress);
        clearTween(this.transitionMaterial.uniforms.uPower);

        this.transitionMaterial.uniforms.uProgress.value = 0;
        this.transitionMaterial.uniforms.uPower.value = 0;
        this.transitionMaterial.uniforms.uOut.value = true;

        tween(this.transitionMaterial.uniforms.uProgress, { value: 1 }, 1250, 'easeInOutQuart', () => {
            if (callback) {
                callback();
            }
        });

        tween(this.transitionMaterial.uniforms.uPower, { value: 1 }, 500, 'linear', () => {
            tween(this.transitionMaterial.uniforms.uPower, { value: 0 }, 500, 'linear');
        });
    };

    static animateIn = callback => {
        clearTween(this.transitionMaterial.uniforms.uProgress);
        clearTween(this.transitionMaterial.uniforms.uPower);

        this.transitionMaterial.uniforms.uProgress.value = 1;
        this.transitionMaterial.uniforms.uPower.value = 0;
        this.transitionMaterial.uniforms.uOut.value = false;

        tween(this.transitionMaterial.uniforms.uProgress, { value: 0 }, 1250, 'easeInOutQuart', () => {
            this.transitionMaterial.uniforms.uOut.value = true;

            if (callback) {
                callback();
            }
        });

        tween(this.transitionMaterial.uniforms.uPower, { value: 1 }, 500, 'linear', () => {
            tween(this.transitionMaterial.uniforms.uPower, { value: 0 }, 500, 'linear');
        });
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLights();
        this.initLoaders();
        this.initEnvironment();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;
        this.camera.lookAt(this.scene.position);

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static async initEnvironment() {
        this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initRouter();
        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init();
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initRouter() {
        Data.pages.forEach(page => {
            router.add(page.path, Page, page);
        });

        // Landing and 404 page
        const home = Data.pages[0]; // Dark Planet

        router.add('/', Page, home);
        router.add('404', Page, home);

        router.init({
            path: basePath,
            scrollRestoration: 'auto'
        });
    }

    static initViews() {
        this.view = new SceneView();
        WorldController.scene.add(this.view);

        this.ui = new UI({ fps: true, breakpoint });
        this.ui.container = new UIContainer();
        this.ui.add(this.ui.container);
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer, scene, camera } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer, scene, camera);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize();
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        this.ui.animateIn();
        this.ui.container.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/transitions/shader_fade/abstract_cube/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Abstract Cube — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/shader_fade/style.css">

    <script type="module" src="/examples/three/transitions/shader_fade/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/shader_fade/dark_planet/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Dark Planet — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/shader_fade/style.css">

    <script type="module" src="/examples/three/transitions/shader_fade/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/shader_fade/floating_crystal/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Floating Crystal — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/shader_fade/style.css">

    <script type="module" src="/examples/three/transitions/shader_fade/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/shader_fade/index.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Page Transition — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1">
    <link rel="stylesheet" href="/examples/assets/css/style.css">
    <link rel="stylesheet" href="/examples/three/transitions/shader_fade/style.css">

    <script type="module" src="/examples/three/transitions/shader_fade/main.js"></script>
</head>
<body>
</body>
</html>



---
File: /examples/three/transitions/shader_fade/main.js
---

import { AssetLoader, BloomCompositeMaterial, BlurMaterial, BoxGeometry, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, Interface, LinearSRGBColorSpace, Link, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, Stage, TextureLoader, Title, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, clearTween, delayedCall, getFullscreenTriangle, router, ticker, tween } from '../../../../build/alien.three.js';

const basePath = '/examples/three/transitions/shader_fade';
const breakpoint = 1000;

class Page {
    constructor({ path, title }) {
        this.path = path;
        this.title = title;

        document.title = `${this.title} — Alien.js`;
    }
}

class Data {
    static init({ pages }) {
        this.pages = pages;
    }

    // Public methods

    static getNext = page => {
        let index = this.pages.indexOf(page);

        if (!~index || ++index > this.pages.length - 1) {
            index = 0;
        }

        return this.pages[index];
    };
}

class UIContainer extends Interface {
    constructor() {
        super('.container');

        this.init();
        this.initViews();

        this.addListeners();
        this.onResize();
    }

    init() {
        this.invisible();
        this.css({
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            height: '100%',
            padding: '55px 0'
        });
    }

    initViews() {
        const { data } = router.get(location.pathname);

        this.title = new Title(data.title.replace(/[\s.-]+/g, '_'));
        this.title.css({
            width: 'fit-content',
            pointerEvents: 'auto'
        });
        this.add(this.title);

        const next = Data.getNext(data);
        const path = router.getPath(next.path);

        this.link = new Link('Next', `${path}/`);
        this.link.css({ marginTop: 'auto' });
        this.add(this.link);
    }

    addListeners() {
        window.addEventListener('popstate', this.onPopState);
        window.addEventListener('resize', this.onResize);
        this.link.events.on('click', this.onClick);
    }

    // Event handlers

    onPopState = () => {
        const { data } = router.get(location.pathname);

        this.title.animateOut();
        this.link.animateOut();

        clearTween(this.timeout);

        RenderManager.animateOut(() => {
            SceneController.setView();

            this.timeout = delayedCall(700, () => {
                this.title.setTitle(data.title.replace(/[\s.-]+/g, '_'));
            });

            RenderManager.animateIn(() => {
                const next = Data.getNext(data);
                const path = router.getPath(next.path);

                this.link.setLink(`${path}/`);
                this.link.animateIn();
            });
        });
    };

    onResize = () => {
        const width = document.documentElement.clientWidth;

        if (width < breakpoint) {
            this.css({
                padding: '24px 0'
            });
        } else {
            this.css({
                padding: '55px 0'
            });
        }
    };

    onClick = (e, { target }) => {
        e.preventDefault();

        router.setPath(target.link);
    };

    // Public methods

    animateIn = () => {
        this.visible();

        const duration = 2000;
        const stagger = 175;

        this.children.forEach((view, i) => {
            view.css({ opacity: 0 }).tween({ opacity: 1 }, duration, 'easeOutCubic', i * stagger);
        });

        this.title.animateIn();
        this.link.animateIn();
    };
}

import rgbshift from '../../../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
import dither from '../../../../src/shaders/modules/dither/dither.glsl.js';

class CompositeMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tScene: { value: null },
                uColor: { value: new Color(0x060606) },
                uRGBAmount: { value: 1.5 },
                uOpacity: { value: 0 }
            },
            vertexShader: /* glsl */ `
                in vec3 position;
                in vec2 uv;

                out vec2 vUv;

                void main() {
                    vUv = uv;

                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */ `
                precision highp float;

                uniform sampler2D tScene;
                uniform vec3 uColor;
                uniform float uRGBAmount;
                uniform float uOpacity;

                in vec2 vUv;

                out vec4 FragColor;

                ${rgbshift}
                ${dither}

                void main() {
                    FragColor = getRGB(tScene, vUv, 0.1, 0.002 * uRGBAmount * (1.0 - uOpacity));

                    FragColor.rgb = mix(uColor, FragColor.rgb, uOpacity);

                    FragColor.rgb = dither(FragColor.rgb);
                    FragColor.a = 1.0;
                }
            `,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}

class AbstractCube extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new BoxGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        normalMap.anisotropy = anisotropy;
        ormMap.anisotropy = anisotropy;

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.rotation.x = MathUtils.degToRad(-45);
        mesh.rotation.z = MathUtils.degToRad(-45);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        this.mesh.rotation.y -= 0.005;
    };

    ready = () => this.initMesh();
}

class FloatingCrystal extends Group {
    constructor() {
        super();
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new OctahedronGeometry();

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 2);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 2);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 2);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 0.7,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(1, 1),
            flatShading: true
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        mesh.scale.set(0.5, 1, 0.5);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = time => {
        this.mesh.position.y = Math.sin(time) * 0.1;
        this.mesh.rotation.y += 0.01;
    };

    ready = () => this.initMesh();
}

class DarkPlanet extends Group {
    constructor() {
        super();

        // 25 degree tilt like Mars
        this.rotation.z = MathUtils.degToRad(25);
    }

    async initMesh() {
        const { anisotropy, loadTexture } = WorldController;

        const geometry = new IcosahedronGeometry(0.6, 12);

        // Second set of UVs for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        geometry.attributes.uv1 = geometry.attributes.uv;

        // Textures
        const [map, normalMap, ormMap] = await Promise.all([
            // loadTexture('uv.jpg'),
            loadTexture('pbr/pitted_metal_basecolor.jpg'),
            loadTexture('pbr/pitted_metal_normal.jpg'),
            // https://occlusion-roughness-metalness.glitch.me/
            loadTexture('pbr/pitted_metal_orm.jpg')
        ]);

        map.anisotropy = anisotropy;
        map.wrapS = RepeatWrapping;
        map.wrapT = RepeatWrapping;
        map.repeat.set(2, 1);

        normalMap.anisotropy = anisotropy;
        normalMap.wrapS = RepeatWrapping;
        normalMap.wrapT = RepeatWrapping;
        normalMap.repeat.set(2, 1);

        ormMap.anisotropy = anisotropy;
        ormMap.wrapS = RepeatWrapping;
        ormMap.wrapT = RepeatWrapping;
        ormMap.repeat.set(2, 1);

        const material = new MeshStandardMaterial({
            color: new Color().offsetHSL(0, 0, -0.65),
            metalness: 0.7,
            roughness: 2,
            map,
            metalnessMap: ormMap,
            roughnessMap: ormMap,
            aoMap: ormMap,
            aoMapIntensity: 1,
            normalMap,
            normalScale: new Vector2(3, 3)
        });

        // Second channel for aoMap and lightMap
        // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
        material.aoMap.channel = 1;

        const mesh = new Mesh(geometry, material);
        this.add(mesh);

        this.mesh = mesh;
    }

    // Public methods

    update = () => {
        // Counter clockwise rotation
        this.mesh.rotation.y += 0.005;
    };

    ready = () => this.initMesh();
}

class SceneView extends Group {
    constructor() {
        super();

        this.visible = false;

        this.initViews();
    }

    initViews() {
        this.darkPlanet = new DarkPlanet();
        this.add(this.darkPlanet);

        this.floatingCrystal = new FloatingCrystal();
        this.add(this.floatingCrystal);

        this.abstractCube = new AbstractCube();
        this.add(this.abstractCube);
    }

    // Public methods

    update = time => {
        this.darkPlanet.update(time);
        this.floatingCrystal.update(time);
        this.abstractCube.update(time);
    };

    ready = () => Promise.all([
        this.darkPlanet.ready(),
        this.floatingCrystal.ready(),
        this.abstractCube.ready()
    ]);
}

class SceneController {
    static init(view) {
        this.view = view;
    }

    // Public methods

    static setView = () => {
        const { data } = router.get(location.pathname);

        this.view.darkPlanet.visible = false;
        this.view.floatingCrystal.visible = false;
        this.view.abstractCube.visible = false;

        switch (data.path) {
            case '/dark_planet':
                this.view.darkPlanet.visible = true;
                break;
            case '/floating_crystal':
                this.view.floatingCrystal.visible = true;
                break;
            case '/abstract_cube':
                this.view.abstractCube.visible = true;
                break;
        }
    };

    static resize = () => {
    };

    static update = time => {
        if (!this.view.visible) {
            return;
        }

        this.view.update(time);
    };

    static animateIn = () => {
        this.setView();

        this.view.visible = true;
    };

    static ready = async () => {
        await this.view.ready();

        // Prerender
        this.view.visible = true;
        RenderManager.update();
        this.view.visible = false;
    };
}

class PanelController {
    static init(ui) {
        this.ui = ui;

        this.initPanel();
    }

    static initPanel() {
        const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

        const items = [
            {
                name: 'FPS'
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Thresh',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uThreshold.value,
                callback: value => {
                    luminosityMaterial.uniforms.uThreshold.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Smooth',
                min: 0,
                max: 1,
                step: 0.01,
                value: luminosityMaterial.uniforms.uSmoothing.value,
                callback: value => {
                    luminosityMaterial.uniforms.uSmoothing.value = value;
                }
            },
            {
                type: 'slider',
                name: 'Strength',
                min: 0,
                max: 2,
                step: 0.01,
                value: RenderManager.bloomStrength,
                callback: value => {
                    RenderManager.bloomStrength = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'slider',
                name: 'Radius',
                min: 0,
                max: 1,
                step: 0.01,
                value: RenderManager.bloomRadius,
                callback: value => {
                    RenderManager.bloomRadius = value;
                    bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                }
            },
            {
                type: 'divider'
            },
            {
                type: 'slider',
                name: 'Blur',
                min: 0,
                max: 10,
                step: 0.1,
                value: RenderManager.blurAmount,
                callback: value => {
                    RenderManager.blurAmount = value;
                }
            },
            {
                type: 'slider',
                name: 'Opacity',
                min: 0,
                max: 1,
                step: 0.01,
                value: 1,
                callback: value => {
                    compositeMaterial.uniforms.uOpacity.value = value;
                }
            }
        ];

        items.forEach(data => {
            this.ui.addPanel(new PanelItem(data));
        });
    }
}

const BlurDirectionX = new Vector2(1, 0);
const BlurDirectionY = new Vector2(0, 1);

class RenderManager {
    static init(renderer, scene, camera) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;

        // Gaussian blur
        this.blurAmount = 10;

        // Unreal bloom
        this.luminosityThreshold = 0.1;
        this.luminositySmoothing = 1;
        this.bloomStrength = 0.3;
        this.bloomRadius = 0.2;

        this.enabled = true;

        this.initRenderer();
    }

    static initRenderer() {
        const { screenTriangle } = WorldController;

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screen = new Mesh(screenTriangle);
        this.screen.frustumCulled = false;

        // Render targets
        this.renderTargetA = new WebGLRenderTarget(1, 1, {
            depthBuffer: false
        });

        this.renderTargetB = this.renderTargetA.clone();

        this.renderTargetBright = this.renderTargetA.clone();
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal.push(this.renderTargetA.clone());
            this.renderTargetsVertical.push(this.renderTargetA.clone());
        }

        this.renderTargetA.depthBuffer = true;

        // Gaussian blur materials
        this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
        this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

        this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
        this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

        // Luminosity high pass material
        this.luminosityMaterial = new LuminosityMaterial();
        this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
        this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

        // Separable Gaussian blur materials
        this.blurMaterials = [];

        const kernelSizeArray = [3, 5, 7, 9, 11];

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
        }

        // Unreal bloom composite material
        this.bloomCompositeMaterial = new BloomCompositeMaterial();
        this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
        this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
        this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
        this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
        this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
        this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

        // Composite materials
        this.sceneCompositeMaterial = new SceneCompositeMaterial();
        this.compositeMaterial = new CompositeMaterial();
    }

    static bloomFactors() {
        const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

        for (let i = 0, l = this.nMips; i < l; i++) {
            const factor = bloomFactors[i];
            bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
        }

        return bloomFactors;
    }

    // Public methods

    static resize = (width, height, dpr) => {
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(width, height);

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.renderTargetA.setSize(width, height);
        this.renderTargetB.setSize(width, height);

        // Gaussian blur
        this.hBlurMaterial.uniforms.uResolution.value.set(width, height);
        this.vBlurMaterial.uniforms.uResolution.value.set(width, height);

        // Unreal bloom
        width = Math.round(width / 2);
        height = Math.round(height / 2);

        this.renderTargetBright.setSize(width, height);

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.renderTargetsHorizontal[i].setSize(width, height);
            this.renderTargetsVertical[i].setSize(width, height);

            this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

            width = Math.round(width / 2);
            height = Math.round(height / 2);
        }
    };

    static update = () => {
        const renderer = this.renderer;
        const scene = this.scene;
        const camera = this.camera;

        if (!this.enabled) {
            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
            return;
        }

        const renderTargetA = this.renderTargetA;
        const renderTargetB = this.renderTargetB;
        const renderTargetBright = this.renderTargetBright;
        const renderTargetsHorizontal = this.renderTargetsHorizontal;
        const renderTargetsVertical = this.renderTargetsVertical;

        // Scene pass
        renderer.setRenderTarget(renderTargetA);
        renderer.render(scene, camera);

        // Extract bright areas
        this.luminosityMaterial.uniforms.tMap.value = renderTargetA.texture;
        this.screen.material = this.luminosityMaterial;
        renderer.setRenderTarget(renderTargetBright);
        renderer.render(this.screen, this.screenCamera);

        // Blur all the mips progressively
        let inputRenderTarget = renderTargetBright;

        for (let i = 0, l = this.nMips; i < l; i++) {
            this.screen.material = this.blurMaterials[i];

            this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
            renderer.setRenderTarget(renderTargetsHorizontal[i]);
            renderer.render(this.screen, this.screenCamera);

            this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
            this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
            renderer.setRenderTarget(renderTargetsVertical[i]);
            renderer.render(this.screen, this.screenCamera);

            inputRenderTarget = renderTargetsVertical[i];
        }

        // Composite all the mips
        this.screen.material = this.bloomCompositeMaterial;
        renderer.setRenderTarget(renderTargetsHorizontal[0]);
        renderer.render(this.screen, this.screenCamera);

        // Scene composite pass
        this.sceneCompositeMaterial.uniforms.tScene.value = renderTargetA.texture;
        this.sceneCompositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
        this.screen.material = this.sceneCompositeMaterial;
        renderer.setRenderTarget(renderTargetB);
        renderer.render(this.screen, this.screenCamera);

        // Two pass Gaussian blur (horizontal and vertical)
        const blurAmount = MathUtils.clamp(MathUtils.inverseLerp(0.5, 0, this.compositeMaterial.uniforms.uOpacity.value), 0, 1);

        if (blurAmount) {
            this.hBlurMaterial.uniforms.tMap.value = renderTargetB.texture;
            this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount * blurAmount;
            this.screen.material = this.hBlurMaterial;
            renderer.setRenderTarget(renderTargetA);
            renderer.render(this.screen, this.screenCamera);

            this.vBlurMaterial.uniforms.tMap.value = renderTargetA.texture;
            this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount * blurAmount;
            this.screen.material = this.vBlurMaterial;
            renderer.setRenderTarget(renderTargetB);
            renderer.render(this.screen, this.screenCamera);
        }

        // Composite pass (render to screen)
        this.compositeMaterial.uniforms.tScene.value = renderTargetB.texture;
        this.screen.material = this.compositeMaterial;
        renderer.setRenderTarget(null);
        renderer.render(this.screen, this.screenCamera);
    };

    static animateOut = callback => {
        clearTween(this.compositeMaterial.uniforms.uOpacity);
        this.compositeMaterial.uniforms.uOpacity.value = 1;
        tween(this.compositeMaterial.uniforms.uOpacity, { value: 0 }, 1000, 'linear', callback);
    };

    static animateIn = callback => {
        clearTween(this.compositeMaterial.uniforms.uOpacity);
        this.compositeMaterial.uniforms.uOpacity.value = 0;
        tween(this.compositeMaterial.uniforms.uOpacity, { value: 1 }, 1000, 'linear', callback);
    };
}

class WorldController {
    static init() {
        this.initWorld();
        this.initLights();
        this.initLoaders();
        this.initEnvironment();

        this.addListeners();
    }

    static initWorld() {
        this.renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            antialias: true
        });

        // Output canvas
        this.element = this.renderer.domElement;

        // Disable color management
        ColorManagement.enabled = false;
        this.renderer.outputColorSpace = LinearSRGBColorSpace;

        // 3D scene
        this.scene = new Scene();
        this.scene.background = new Color(0x060606);
        this.camera = new PerspectiveCamera(30);
        this.camera.near = 0.5;
        this.camera.far = 40;
        this.camera.position.z = 8;
        this.camera.lookAt(this.scene.position);

        // Global geometries
        this.screenTriangle = getFullscreenTriangle();

        // Global uniforms
        this.resolution = { value: new Vector2() };
        this.texelSize = { value: new Vector2() };
        this.aspect = { value: 1 };
        this.time = { value: 0 };
        this.frame = { value: 0 };

        // Global settings
        this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
    }

    static initLights() {
        this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

        const light = new DirectionalLight(0xffffff, 2);
        light.position.set(0.6, 0.5, 1);
        this.scene.add(light);
    }

    static initLoaders() {
        this.textureLoader = new TextureLoader();
        this.textureLoader.setPath('/examples/assets/textures/');

        this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
        this.environmentLoader.setPath('/examples/assets/textures/env/');
    }

    static async initEnvironment() {
        this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
        this.scene.environmentIntensity = 1.2;
    }

    static addListeners() {
        this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
    }

    // Event handlers

    static onTouchStart = e => {
        e.preventDefault();
    };

    // Public methods

    static resize = (width, height, dpr) => {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        width = Math.round(width * dpr);
        height = Math.round(height * dpr);

        this.resolution.value.set(width, height);
        this.texelSize.value.set(1 / width, 1 / height);
        this.aspect.value = width / height;
    };

    static update = (time, delta, frame) => {
        this.time.value = time;
        this.frame.value = frame;
    };

    static ready = () => Promise.all([
        this.textureLoader.ready(),
        this.environmentLoader.ready()
    ]);

    // Global handlers

    static getTexture = (path, callback) => this.textureLoader.load(path, callback);

    static loadTexture = path => this.textureLoader.loadAsync(path);

    static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
}

class App {
    static async init() {
        this.initThread();
        this.initLoader();
        this.initStage();
        this.initWorld();

        await this.loadData();

        this.initRouter();
        this.initViews();
        this.initControllers();

        this.addListeners();
        this.onResize();

        await SceneController.ready();
        await WorldController.ready();

        this.initPanel();

        this.animateIn();
    }

    static initThread() {
        ImageBitmapLoaderThread.init();
    }

    static initLoader() {
        this.assetLoader = new AssetLoader();
        this.assetLoader.setPath('/examples/three/transitions/');
    }

    static initStage() {
        Stage.init();
        Stage.css({ opacity: 0 });
    }

    static initWorld() {
        WorldController.init();
        Stage.add(WorldController.element);
    }

    static async loadData() {
        const data = await this.assetLoader.loadData('data.json');

        Data.init(data);
    }

    static initRouter() {
        Data.pages.forEach(page => {
            router.add(page.path, Page, page);
        });

        // Landing and 404 page
        const home = Data.pages[0]; // Dark Planet

        router.add('/', Page, home);
        router.add('404', Page, home);

        router.init({
            path: basePath,
            scrollRestoration: 'auto'
        });
    }

    static initViews() {
        this.view = new SceneView();
        WorldController.scene.add(this.view);

        this.ui = new UI({ fps: true, breakpoint });
        this.ui.container = new UIContainer();
        this.ui.add(this.ui.container);
        Stage.add(this.ui);
    }

    static initControllers() {
        const { renderer, scene, camera } = WorldController;

        SceneController.init(this.view);
        RenderManager.init(renderer, scene, camera);
    }

    static initPanel() {
        PanelController.init(this.ui);
    }

    static addListeners() {
        window.addEventListener('resize', this.onResize);
        ticker.add(this.onUpdate);
    }

    // Event handlers

    static onResize = () => {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const dpr = window.devicePixelRatio;

        WorldController.resize(width, height, dpr);
        SceneController.resize();
        RenderManager.resize(width, height, dpr);
    };

    static onUpdate = (time, delta, frame) => {
        WorldController.update(time, delta, frame);
        SceneController.update(time);
        RenderManager.update(time, delta, frame);
        this.ui.update();
    };

    // Public methods

    static animateIn = () => {
        SceneController.animateIn();
        RenderManager.animateIn();
        this.ui.animateIn();
        this.ui.container.animateIn();

        Stage.tween({ opacity: 1 }, 1000, 'linear', () => {
            Stage.css({ opacity: '' });
        });
    };
}

App.init();



---
File: /examples/three/3d_abstract_cube.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Abstract Cube — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Reflector, ReflectorDudvMaterial, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class AbstractCube extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new BoxGeometry();

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                normalMap.anisotropy = anisotropy;
                ormMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 0.35,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1),
                    flatShading: true
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.rotation.x = MathUtils.degToRad(-45);
                mesh.rotation.z = MathUtils.degToRad(-45);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = () => {
                this.mesh.rotation.y -= 0.005;
            };

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector({ blurIterations: 6 });
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 6);

                const material = new ReflectorDudvMaterial({
                    map,
                    reflectivity: 0.5
                });
                material.uniforms.tReflect = { value: this.reflector.renderTarget.texture };
                material.uniforms.tReflectBlur = this.reflector.renderTargetUniform;
                material.uniforms.uMatrix = this.reflector.textureMatrixUniform;

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -0.86;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.abstractCube = new AbstractCube();
                this.add(this.abstractCube);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            update = () => {
                this.abstractCube.update();
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.abstractCube.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_backdrop.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Backdrop — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        :root {
            --bg-color: #efefef;
            --ui-color: #000;
            --ui-color-triplet: 0 0 0;
        }
    </style>

    <script type="module">
        import { AmbientLight, BasicShadowMap, BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Easing, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, LightPanelController, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OrbitControls, OrthographicCamera, Panel, PanelItem, PerspectiveCamera, PlaneGeometry, RawShaderMaterial, Scene, SoftShadows, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, ticker } from '../../build/alien.three.js';

        // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/ACESFilmicToneMappingShader.js by WestLangley
        // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/GammaCorrectionShader.js by WestLangley

        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
        import encodings from '../../src/shaders/modules/encodings/encodings.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        uBloomDistortion: { value: 1.5 },
                        uToneMapping: { value: false },
                        uExposure: { value: 1 },
                        uGamma: { value: true }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform float uBloomDistortion;
                        uniform bool uToneMapping;
                        uniform float uExposure;
                        uniform bool uGamma;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${rgbshift}
                        ${encodings}

                        void main() {
                            FragColor = texture(tScene, vUv);

                            float angle = length(vUv - 0.5);
                            float amount = 0.001 * uBloomDistortion;

                            FragColor.rgb += getRGB(tBloom, vUv, angle, amount).rgb;

                            if (uToneMapping) {
                                FragColor.rgb *= uExposure;

                                FragColor = vec4(ACESFilmicToneMapping(FragColor.rgb), FragColor.a);
                            }

                            if (uGamma) {
                                FragColor = vec4(linearToSRGB(FragColor.rgb), FragColor.a);
                            }
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class Sphere extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const geometry = new IcosahedronGeometry(0.6, 12);

                const material = new MeshStandardMaterial({
                    color: 0xefefef,
                    metalness: 0.6,
                    roughness: 0.9,
                    dithering: true
                });

                const mesh = new Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.add(mesh);
            }
        }

        // Based on https://github.com/pmndrs/drei/blob/master/src/core/Backdrop.tsx

        class Backdrop extends Group {
            constructor({
                floor = 1,
                segments = 20,
                receiveShadow = true
            } = {}) {
                super();

                this.floor = floor;
                this.segments = segments;
                this.receiveShadow = receiveShadow;

                this.offset = this.segments / this.segments / 2;

                this.initMesh();
            }

            initMesh() {
                const geometry = new PlaneGeometry(1, 1, this.segments, this.segments);
                const position = geometry.attributes.position;

                let i = 0;

                for (let x = 0; x < this.segments + 1; x++) {
                    for (let y = 0; y < this.segments + 1; y++) {
                        position.setXYZ(
                            i++,
                            x / this.segments - this.offset + (x === 0 ? -this.floor : 0),
                            y / this.segments - this.offset,
                            Easing.easeInExpo(x / this.segments)
                        );
                    }
                }

                position.needsUpdate = true;
                geometry.computeVertexNormals();

                const material = new MeshStandardMaterial({
                    color: 0xefefef,
                    metalness: 0.6,
                    roughness: 0.9,
                    dithering: true
                });

                const mesh = new Mesh(geometry, material);
                mesh.position.set(0, -0.86, -2);
                mesh.rotation.set(-Math.PI / 2, 0, Math.PI / 2);
                mesh.scale.set(5, 15, 5);
                mesh.receiveShadow = this.receiveShadow;
                this.add(mesh);
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initViews();
            }

            initViews() {
                this.backdrop = new Backdrop();
                this.add(this.backdrop);

                this.sphere = new Sphere();
                this.add(this.sphere);
            }
        }

        class PanelController {
            static init(renderer, scene, ui) {
                this.renderer = renderer;
                this.scene = scene;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const postOptions = {
                    Off: false,
                    Post: true
                };

                const toneMappingOptions = {
                    Off: false,
                    Tone: true
                };

                const gammaOptions = {
                    Off: false,
                    Gamma: true
                };

                const postItems = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: toneMappingOptions,
                        value: getKeyByValue(toneMappingOptions, compositeMaterial.uniforms.uToneMapping.value),
                        callback: value => {
                            compositeMaterial.uniforms.uToneMapping.value = toneMappingOptions[value];
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uExposure.value,
                        callback: value => {
                            compositeMaterial.uniforms.uExposure.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: gammaOptions,
                        value: getKeyByValue(gammaOptions, compositeMaterial.uniforms.uGamma.value),
                        callback: value => {
                            compositeMaterial.uniforms.uGamma.value = gammaOptions[value];
                        }
                    }
                ];

                const item = new PanelItem({ name: 'FPS' });
                this.ui.addPanel(item);

                LightPanelController.init(this.scene, this.ui);

                const items = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: (value, item) => {
                            if (!item.hasContent()) {
                                const postPanel = new Panel();
                                postPanel.animateIn(true);

                                postItems.forEach(data => {
                                    postPanel.add(new PanelItem(data));
                                });

                                item.setContent(postPanel);
                            }

                            RenderManager.enabled = postOptions[value];

                            if (RenderManager.enabled) {
                                item.toggleContent(true);
                            } else {
                                item.toggleContent(false);
                            }
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }

            // Public methods

            static update = () => {
                if (!this.ui) {
                    return;
                }

                LightPanelController.update();
            };
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.75;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initShadows();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0xefefef);
                this.camera = new PerspectiveCamera(35);
                this.camera.near = 1;
                this.camera.far = 3000;
                this.camera.position.set(0, 0.5, 6);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initShadows() {
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = BasicShadowMap;

                SoftShadows.init({
                    size: 0.003,
                    frustum: 3.75,
                    near: 9.5,
                    samples: 3,
                    rings: 2
                });
            }

            static initLights() {
                this.scene.add(new AmbientLight(0xffffff, 0.2));

                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const directionalLight1 = new DirectionalLight(0xffffff, 0.8);
                directionalLight1.position.set(5, 5, 5);
                directionalLight1.castShadow = true;
                directionalLight1.shadow.mapSize.width = 1024;
                directionalLight1.shadow.mapSize.height = 1024;
                directionalLight1.shadow.camera.near = 0.1;
                directionalLight1.shadow.camera.far = 20;
                this.scene.add(directionalLight1);

                const directionalLight2 = new DirectionalLight();
                directionalLight2.position.set(-3, 4, 1);
                directionalLight2.castShadow = true;
                directionalLight2.shadow.mapSize.width = 1024;
                directionalLight2.shadow.mapSize.height = 1024;
                directionalLight2.shadow.camera.near = 0.1;
                directionalLight2.shadow.camera.far = 20;
                this.scene.add(directionalLight2);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.6;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await WorldController.ready();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { renderer, scene } = WorldController;

                PanelController.init(renderer, scene, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                PanelController.update();
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_black_holes.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Black Holes — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BlurMaterial, Color, ColorManagement, CopyMaterial, DepthMaterial, DisplayOptions, DrawBuffers, EnvironmentTextureLoader, Fluid, GLSL3, Group, IcosahedronGeometry, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshMatcapMaterial, MeshStandardMaterial, NearestFilter, NoBlending, NormalMaterial, OrbitControls, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeAddMaterial, SphereGeometry, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, VolumetricLightMaterial, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);
        const isOrbit = /[?&]orbit/.test(location.search);

        const layers = {
            default: 0,
            buffers: 1,
            motion: 2,
            light: 3
        };

        const params = {
            animate: true,
            speed: 40
        };

        const colors = {
            backgroundColor: 0x01020b,
            lightColor: 0x323850
        };

        // Based on https://github.com/PavelDoGreat/WebGL-Fluid-Simulation
        // Based on https://oframe.github.io/ogl/examples/?src=post-fluid-distortion.html by gordonnl

        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        tAdd: { value: null },
                        tFluid: { value: null },
                        uBloomDistortion: { value: 1.5 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform sampler2D tAdd;
                        uniform sampler2D tFluid;
                        uniform float uBloomDistortion;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${rgbshift}
                        ${dither}

                        void main() {
                            vec3 fluid = texture(tFluid, vUv).rgb;
                            vec2 uv = vUv - fluid.rg * 0.0002;

                            FragColor = texture(tScene, uv);

                            float angle = length(vUv - 0.5);
                            float amount = 0.001 * uBloomDistortion;

                            FragColor.rgb += getRGB(tBloom, uv, angle, amount).rgb;

                            FragColor.rgb += texture(tAdd, uv).rgb;

                            FragColor.rgb = dither(FragColor.rgb);
                            FragColor.a = 1.0;
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class MotionBlurCompositeMaterial extends RawShaderMaterial {
            constructor() {
                const { getTexture } = WorldController;

                const texture = getTexture('blue_noise.png');
                texture.wrapS = RepeatWrapping;
                texture.wrapT = RepeatWrapping;
                texture.magFilter = NearestFilter;
                texture.minFilter = NearestFilter;
                texture.generateMipmaps = false;

                super({
                    glslVersion: GLSL3,
                    defines: {
                        SAMPLES: 7
                    },
                    uniforms: {
                        tMap: { value: null },
                        tVelocity: { value: null },
                        tBlueNoise: { value: texture },
                        uBlueNoiseResolution: { value: new Vector2(256, 256) }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tMap;
                        uniform sampler2D tVelocity;
                        uniform sampler2D tBlueNoise;
                        uniform vec2 uBlueNoiseResolution;

                        in vec2 vUv;

                        out vec4 FragColor;

                        void main() {
                            vec2 vel = texture(tVelocity, vUv).xy;

                            if (dot(vel, vec2(1.0)) == 0.0) {
                                discard;
                            }

                            float jitterValue = texture(tBlueNoise, gl_FragCoord.xy / uBlueNoiseResolution).r;
                            vec2 jitterOffset = vel * vec2(jitterValue) / float(SAMPLES);

                            vec4 result;

                            vec2 startUv = clamp(vUv - vel * 0.5 + jitterOffset, 0.0, 1.0);
                            vec2 endUv = clamp(vUv + vel * 0.5 + jitterOffset, 0.0, 1.0);

                            for (int i = 0; i < SAMPLES; i++) {
                                vec2 sampleUv = mix(startUv, endUv, float(i) / float(SAMPLES));
                                result += texture(tMap, sampleUv);
                            }

                            result /= float(SAMPLES);

                            FragColor = result;

                            /* if (dot(vel, vec2(1.0)) == 0.0) {
                                FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                            } else {
                                FragColor = vec4(0.0, 1.0, 0.0, 1.0);
                            } */
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        // https://www.youtube.com/watch?v=uD4izuDMUQA&t=996s by melodysheep

        class LighterBlackHole extends Group {
            constructor() {
                super();

                this.frameRotation = 0;
                this.position.x = 3;
                this.position.z = 3;
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.5, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                let material;

                if (isDebug) {
                    material = new MeshStandardMaterial({
                        color: new Color().offsetHSL(0, 0, -0.65),
                        emissive: new Color(0xff0000),
                        metalness: 1.7,
                        roughness: 1,
                        map,
                        metalnessMap: ormMap,
                        roughnessMap: ormMap,
                        aoMap: ormMap,
                        aoMapIntensity: 1,
                        normalMap,
                        normalScale: new Vector2(3, 3)
                    });
                } else {
                    material = new MeshStandardMaterial({
                        color: new Color(0x000000),
                        metalness: 1.7,
                        roughness: 1,
                        map,
                        metalnessMap: ormMap,
                        roughnessMap: ormMap,
                        aoMap: ormMap,
                        aoMapIntensity: 1,
                        normalMap,
                        normalScale: new Vector2(3, 3)
                    });
                }

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.layers.enable(layers.buffers);
                mesh.layers.enable(layers.motion);
                this.add(mesh);
            }

            // Public methods

            update = () => {
                this.frameRotation -= 0.01 * params.speed;
                this.position.x = 3 * Math.sin(this.frameRotation);
                this.position.z = 3 * Math.cos(this.frameRotation);
            };

            ready = () => this.initMesh();
        }

        class VeryHeavyBlackHole extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { scene, anisotropy, loadTexture, loadEnvironmentTexture } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, envMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadEnvironmentTexture('jewelry_black_contrast.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(colors.lightColor).offsetHSL(0, 0, -0.2),
                    metalness: 9,
                    roughness: 0.9,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3),
                    envMap,
                    envMapIntensity: 18
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Match scene environment rotation
                material.envMapRotation.x = scene.environmentRotation.x;
                material.envMapRotation.y = scene.environmentRotation.y;

                const mesh = new Mesh(geometry, material);
                mesh.layers.enable(layers.buffers);
                mesh.layers.enable(layers.light);
                this.add(mesh);

                this.material = material;
            }

            // Public methods

            update = () => {
                this.material.envMapRotation.z -= 0.00005 * params.speed;
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.sphere = new VeryHeavyBlackHole();
                this.add(this.sphere);

                this.ball = new LighterBlackHole();
                this.add(this.ball);
            }

            // Public methods

            resize = () => {
            };

            update = () => {
                this.sphere.update();
                this.ball.update();
            };

            ready = () => Promise.all([
                this.sphere.ready(),
                this.ball.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;

                this.animatedOneFramePast = false;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                if (params.animate || !this.animatedOneFramePast) {
                    this.view.update();

                    this.animatedOneFramePast = !params.animate;
                }
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { drawBuffers, fluid, vlMaterial, luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const animateOptions = {
                    Off: false,
                    Animate: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: DisplayOptions,
                        value: getKeyByValue(DisplayOptions, RenderManager.display),
                        callback: value => {
                            RenderManager.display = DisplayOptions[value];
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Speed',
                        min: 0,
                        max: 100,
                        step: 0.1,
                        value: params.speed,
                        callback: value => {
                            params.speed = value;
                        }
                    },
                    {
                        type: 'list',
                        list: animateOptions,
                        value: getKeyByValue(animateOptions, params.animate),
                        callback: value => {
                            params.animate = animateOptions[value];
                            drawBuffers.saveState = params.animate;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Interp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: drawBuffers.interpolateGeometry,
                        callback: value => {
                            drawBuffers.interpolateGeometry = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smear',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: drawBuffers.smearIntensity,
                        callback: value => {
                            drawBuffers.smearIntensity = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Iterate',
                        min: 0,
                        max: 10,
                        step: 1,
                        value: fluid.iterations,
                        callback: value => {
                            fluid.iterations = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.densityDissipation,
                        callback: value => {
                            fluid.densityDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Velocity',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.velocityDissipation,
                        callback: value => {
                            fluid.velocityDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Pressure',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.pressureDissipation,
                        callback: value => {
                            fluid.pressureDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Curl',
                        min: 0,
                        max: 50,
                        step: 0.1,
                        value: fluid.curlStrength,
                        callback: value => {
                            fluid.curlStrength = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.radius,
                        callback: value => {
                            fluid.radius = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Decay',
                        min: 0.6,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDecay.value,
                        callback: value => {
                            vlMaterial.uniforms.uDecay.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDensity.value,
                        callback: value => {
                            vlMaterial.uniforms.uDensity.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Weight',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uWeight.value,
                        callback: value => {
                            vlMaterial.uniforms.uWeight.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.width = 1;
                this.height = 1;

                // Volumetric light
                this.lightPosition = new Vector3();
                this.vlExposure = 0.3;
                this.vlDecay = 1;
                this.vlDensity = 1;
                this.vlWeight = 1;
                this.vlClamp = 1;
                this.blurResolutionScale = 0.25;
                this.blurAmount = 2.5;

                // Fluid simulation
                this.lastMouse = new Vector2();

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                // Debug
                DisplayOptions.Light = 8;
                this.display = DisplayOptions.Default;

                this.enabled = true;

                this.initRenderer();

                this.addListeners();
            }

            static initRenderer() {
                const { screenTriangle, aspect, textureLoader, getTexture } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Clear colors
                this.clearColor = new Color(0, 0, 0);
                this.currentClearColor = new Color();

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();
                this.renderTargetC = this.renderTargetA.clone();

                this.renderTargetBlurA = this.renderTargetA.clone();
                this.renderTargetBlurB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetC.depthBuffer = true;
                this.renderTargetBlurA.depthBuffer = true;

                // Fluid simulation
                this.fluid = new Fluid(this.renderer, {
                    iterations: 0,
                    radius: 0.01
                });
                this.fluid.splatMaterial.uniforms.uAspect = aspect;

                // G-Buffer
                this.drawBuffers = new DrawBuffers(this.renderer, this.scene, this.camera, layers.buffers, {
                    smearIntensity: 2,
                    cameraBlur: false
                });

                // Motion blur composite material
                this.motionBlurCompositeMaterial = new MotionBlurCompositeMaterial(textureLoader, {
                    blueNoisePath: 'blue_noise.png'
                });
                this.motionBlurCompositeMaterial.uniforms.tVelocity.value = this.drawBuffers.renderTarget.textures[1];

                // Occlusion materials
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });
                this.backgroundMaterial = new MeshBasicMaterial({ color: this.scene.background });

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Volumetric light material
                this.vlMaterial = new VolumetricLightMaterial();
                this.vlMaterial.uniforms.uExposure.value = this.vlExposure;
                this.vlMaterial.uniforms.uDecay.value = this.vlDecay;
                this.vlMaterial.uniforms.uDensity.value = this.vlDensity;
                this.vlMaterial.uniforms.uWeight.value = this.vlWeight;
                this.vlMaterial.uniforms.uClamp.value = this.vlClamp;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite materials
                this.sceneCompositeMaterial = new SceneCompositeAddMaterial();

                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.tFluid = this.fluid.uniform;
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;

                // Debug materials
                this.matcap1Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/040full.jpg') });
                this.matcap2Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/defaultwax.jpg') });
                this.normalMaterial = new NormalMaterial();
                this.depthMaterial = new DepthMaterial();
                this.copyMaterial = new CopyMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static setLightPosition() {
                const position = this.lightPosition.clone();
                const vector = position.project(this.camera);
                const x = (vector.x + 1) / 2;
                const y = (vector.y + 1) / 2;

                this.vlMaterial.uniforms.uLightPosition.value.set(x, y);
            }

            static rendererState() {
                this.currentOverrideMaterial = this.scene.overrideMaterial;
                this.currentBackground = this.scene.background;
                this.renderer.getClearColor(this.currentClearColor);
                this.currentClearAlpha = this.renderer.getClearAlpha();
            }

            static restoreRendererState() {
                this.scene.overrideMaterial = this.currentOverrideMaterial;
                this.scene.background = this.currentBackground;
                this.renderer.setClearColor(this.currentClearColor, this.currentClearAlpha);
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                const event = {
                    x: clientX,
                    y: clientY
                };

                // First input
                if (!this.lastMouse.isInit) {
                    this.lastMouse.isInit = true;
                    this.lastMouse.copy(event);
                }

                const deltaX = event.x - this.lastMouse.x;
                const deltaY = event.y - this.lastMouse.y;

                this.lastMouse.copy(event);

                // Add if the mouse is moving
                if (Math.abs(deltaX) || Math.abs(deltaY)) {
                    // Update fluid simulation inputs
                    this.fluid.splats.push({
                        // Get mouse value in 0 to 1 range, with Y flipped
                        x: event.x / this.width,
                        y: 1 - event.y / this.height,
                        dx: deltaX * 5,
                        dy: deltaY * -5
                    });
                }
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.width = width;
                this.height = height;

                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);
                this.renderTargetC.setSize(width, height);

                this.drawBuffers.setSize(width, height);

                // Gaussian blur
                const blurWidth = Math.round(width * this.blurResolutionScale);
                const blurHeight = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(blurWidth, blurHeight);
                this.renderTargetBlurB.setSize(blurWidth, blurHeight);

                this.hBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);
                this.vBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetC = this.renderTargetC;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Renderer state
                this.rendererState();

                // Perform all of the fluid simulation renders
                this.fluid.update();

                // G-Buffer layer
                camera.layers.set(layers.buffers);

                this.drawBuffers.update();

                if (this.display === DisplayOptions.Velocity) {
                    // Debug pass (render to screen)
                    this.copyMaterial.uniforms.tMap.value = this.drawBuffers.renderTarget.textures[1];
                    this.screen.material = this.copyMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                }

                // Scene layer
                camera.layers.set(layers.default);

                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);
                // this.restoreRendererState();
                // return;

                // Motion layer
                scene.background = null;

                scene.overrideMaterial = this.backgroundMaterial;
                renderer.setRenderTarget(renderTargetC);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = this.currentOverrideMaterial;

                camera.layers.set(layers.motion);

                renderer.render(scene, camera);
                // this.restoreRendererState();
                // return;

                // Light layer
                camera.layers.set(layers.default);

                scene.overrideMaterial = this.blackoutMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = this.currentOverrideMaterial;

                camera.layers.set(layers.light);

                renderer.render(scene, camera);
                // this.restoreRendererState();
                // return;

                // Composite pass with the fluid simulation
                this.compositeMaterial.uniforms.tScene.value = renderTargetBlurA.texture;
                this.compositeMaterial.uniforms.tBloom.value = null;
                this.compositeMaterial.uniforms.tAdd.value = null;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Six pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Volumetric light pass
                this.vlMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.setLightPosition();
                this.screen.material = this.vlMaterial;

                if (this.display === DisplayOptions.Light) {
                    // Debug pass (render to screen)
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                } else {
                    renderer.setRenderTarget(renderTargetBlurA);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Post-processing
                camera.layers.set(layers.default);

                scene.background = null;
                renderer.setClearColor(this.clearColor, 1);

                // Debug override material passes (render to screen)
                if (this.display === DisplayOptions.Depth) {
                    scene.overrideMaterial = this.depthMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Geometry) {
                    scene.overrideMaterial = this.normalMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Matcap1) {
                    scene.overrideMaterial = this.matcap1Material;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Matcap2) {
                    scene.overrideMaterial = this.matcap2Material;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                }

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Motion blur pass
                this.motionBlurCompositeMaterial.uniforms.tMap.value = renderTargetC.texture;
                this.screen.material = this.motionBlurCompositeMaterial;
                renderer.render(this.screen, this.screenCamera);
                // this.restoreRendererState();
                // return;

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;

                if (this.display === DisplayOptions.Luma) {
                    // Debug pass (render to screen)
                    this.screen.material = this.blackoutMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.screen.material = this.luminosityMaterial;
                    this.screen.material.blending = AdditiveBlending;
                    renderer.render(this.screen, this.screenCamera);
                    this.screen.material.blending = NoBlending;
                    this.restoreRendererState();
                    return;
                } else {
                    this.screen.material = this.luminosityMaterial;
                    renderer.setRenderTarget(renderTargetBright);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;

                if (this.display === DisplayOptions.Bloom) {
                    // Debug pass (render to screen)
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                } else {
                    renderer.setRenderTarget(renderTargetsHorizontal[0]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Composite pass with the fluid simulation (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTargetB.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.compositeMaterial.uniforms.tAdd.value = renderTargetBlurA.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Restore renderer settings
                this.restoreRendererState();
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(colors.backgroundColor);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentRotation.x = MathUtils.degToRad(-45);
                this.scene.environmentRotation.y = MathUtils.degToRad(-25);
                this.scene.environmentIntensity = 1.2;
            }

            static initControls() {
                if (!isOrbit) {
                    return;
                }

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                if (this.controls && this.controls.enabled) {
                    this.controls.update();
                }
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_camera_wobble.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Camera Wobble — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Fog, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Reflector, RepeatWrapping, SVGLoader, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, Wobble, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { camera, loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.position.set(0, 1.4, -11);
                group.scale.y *= -1;
                group.lookAt(camera.position);

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/polished_concrete_basecolor.jpg'),
                    loadTexture('pbr/polished_concrete_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/polished_concrete_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const uniforms = {
                    mirror: { value: 0 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture2D(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new Triangle();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.last = new Vector2();
                this.delta = new Vector2();
                this.mouse.set(document.documentElement.clientWidth / 2, document.documentElement.clientHeight / 2);
                this.last.copy(this.mouse);

                // Motion control
                this.group = new Group();
                this.rotateGroup = new Group();
                this.innerGroup = new Group();
                this.rotateGroup.add(this.innerGroup);
                this.group.add(this.rotateGroup);
                this.group.matrixAutoUpdate = false;
                this.rotateGroup.matrixAutoUpdate = false;
                this.innerGroup.matrixAutoUpdate = false;

                // Flip direction
                this.rotateGroup.rotation.y = Math.PI;

                // Start position
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.group.position.copy(this.camera.position);
                this.origin.copy(this.group.position);

                this.rotation = 0;
                this.rotateAngle = MathUtils.degToRad(10);
                this.lerpSpeed = 0.02;
                this.lerpSpeed2 = 0.07;
                this.enabled = false;

                this.wobble = new Wobble(this.innerGroup.position);

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.set(clientX, clientY);
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.group.position.z = this.camera.position.z;
                this.origin.z = this.group.position.z;

                this.group.lookAt(this.lookAt);
            };

            static update = time => {
                if (!this.enabled) {
                    return;
                }

                this.delta.subVectors(this.mouse, this.last);
                this.last.copy(this.mouse);

                const directionX = MathUtils.mapLinear(this.mouse.x, 0, document.documentElement.clientWidth, -1, 1);
                const directionY = MathUtils.mapLinear(this.mouse.y, 0, document.documentElement.clientHeight, 1, -1);

                this.target.x = this.origin.x + this.targetXY.x * directionX;
                this.target.y = this.origin.y + this.targetXY.y * directionY;
                this.target.z = this.origin.z;

                this.group.position.lerp(this.target, this.lerpSpeed);
                this.group.lookAt(this.lookAt);

                const rotateStrength = MathUtils.mapLinear(Math.abs(this.delta.x) / document.documentElement.clientWidth, 0, 0.02, 0, 1);
                this.rotation += (this.rotateAngle * rotateStrength * Math.sign(this.delta.x) - this.rotation) * this.lerpSpeed;
                this.rotateGroup.rotation.z += (this.rotation - this.rotateGroup.rotation.z) * this.lerpSpeed2;

                this.wobble.update(time);

                this.updateCamera();
            };

            static updateCamera = () => {
                this.group.updateMatrix();
                this.rotateGroup.updateMatrix();
                this.innerGroup.updateMatrix();
                this.group.updateMatrixWorld();
                this.innerGroup.matrixWorld.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update(time);
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_crystal_gltf_basis_draco.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Crystal — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1:wght@400;700">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        // npx @gltf-transform/cli etc1s crystal.glb crystal-basis.glb
        // npx @gltf-transform/cli draco crystal-basis.glb crystal-basis-draco.glb

        import { BloomCompositeMaterial, Color, ColorManagement, DRACOLoader, DirectionalLight, EnvironmentTextureLoader, GLTFLoader, Group, HemisphereLight, KTX2Loader, LightOptions, LightPanelController, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshPhysicalMaterial, OrbitControls, OrthographicCamera, Panel, PanelItem, PerspectiveCamera, PhysicalMaterialPanel, Scene, SceneCompositeDistortionMaterial, ScenePanel, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByLight, getKeyByValue, ticker } from '../../build/alien.three.js';

        class Crystal extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { anisotropy, loadGLTF } = WorldController;

                // Sketchfab model
                // https://sbtron.github.io/makeglb/
                const model = await loadGLTF('crystal-basis-draco.glb');
                model.scale.setScalar(0.01);
                // model.updateMatrixWorld(); // Needed for Point3D

                // Crystal mesh
                // https://threejs.org/docs/index.html#api/en/core/Object3D.getObjectByName
                // const avatar = gltf.scene.getObjectByName('avatar');
                const mesh = model.children[0].children[0].children[0].children[0].children[0];
                mesh.geometry.center(); // Also needed for Point3D
                mesh.position.y = 50;
                mesh.rotation.y = MathUtils.degToRad(200);

                // Textures
                mesh.material.map.anisotropy = anisotropy;
                mesh.material.normalMap.anisotropy = anisotropy;
                mesh.material.metalnessMap.anisotropy = anisotropy;
                mesh.material.roughnessMap.anisotropy = anisotropy;

                const material = new MeshPhysicalMaterial();
                material.color = mesh.material.color;
                material.metalness = mesh.material.metalness;
                material.roughness = mesh.material.roughness;
                material.map = mesh.material.map;
                material.normalMap = mesh.material.normalMap;
                material.metalnessMap = mesh.material.metalnessMap;
                material.roughnessMap = mesh.material.roughnessMap;
                material.side = mesh.material.side;
                material.transparent = mesh.material.transparent;
                material.opacity = mesh.material.opacity;
                material.transmission = 0.95;
                material.ior = 1.5;
                material.thickness = 5;
                // material.forceSinglePass = true;
                mesh.material.dispose();
                mesh.material = material;

                this.add(model);

                this.mesh = mesh;
            }

            // Public methods

            update = () => {
                this.mesh.rotation.y += 0.005;
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.crystal = new Crystal();
                this.add(this.crystal);
            }

            // Public methods

            update = () => {
                this.crystal.update();
            };

            ready = () => Promise.all([
                this.crystal.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PostPanel extends Panel {
            constructor() {
                super();

                this.initPanel();
            }

            initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const postOptions = {
                    Off: false,
                    On: true
                };

                const postItems = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                const items = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        name: 'Post',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: (value, item) => {
                            if (!item.hasContent()) {
                                const postPanel = new Panel();
                                postPanel.animateIn(true);

                                postItems.forEach(data => {
                                    postPanel.add(new PanelItem(data));
                                });

                                item.setContent(postPanel);
                            }

                            RenderManager.enabled = postOptions[value];

                            if (RenderManager.enabled) {
                                item.toggleContent(true);
                            } else {
                                item.toggleContent(false);
                            }
                        }
                    }
                ];

                items.forEach(data => {
                    this.add(new PanelItem(data));
                });
            }
        }

        class PanelController {
            static init(renderer, scene, camera, view, ui) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;
                this.ui = ui;

                this.lights = [];

                this.initControllers();
                this.initPanel();
            }

            static initControllers() {
                LightPanelController.init(this.scene);
            }

            static initPanel() {
                const { crystal } = this.view;

                const sceneOptions = {
                    Scene: ScenePanel,
                    Post: PostPanel
                };

                this.scene.traverse(object => {
                    if (object.isLight) {
                        const key = getKeyByLight(LightOptions, object);

                        sceneOptions[key] = [object, LightOptions[key][1]];

                        this.lights.push(object);
                    }
                });

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'content',
                        callback: (value, item) => {
                            const materialPanel = new PhysicalMaterialPanel(crystal.mesh);
                            materialPanel.animateIn(true);

                            item.setContent(materialPanel);
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'TRS',
                        min: 0.01,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.transmissionResolutionScale,
                        callback: value => {
                            this.renderer.transmissionResolutionScale = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: sceneOptions,
                        value: 'Scene',
                        callback: (value, item) => {
                            switch (value) {
                                case 'Scene':
                                case 'Post': {
                                    const ScenePanel = sceneOptions[value];

                                    const scenePanel = new ScenePanel(this.scene, this.ui);
                                    scenePanel.animateIn(true);

                                    item.setContent(scenePanel);
                                    break;
                                }
                                default: {
                                    const [light, LightPanel] = sceneOptions[value];

                                    const lightPanel = new LightPanel(LightPanelController, light);
                                    lightPanel.animateIn(true);

                                    item.setContent(lightPanel);
                                    break;
                                }
                            }
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Renderer settings
                this.transmissionResolutionScale = 1;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Renderer settings
                this.renderer.transmissionResolutionScale = this.transmissionResolutionScale;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.set(0, 6, 8);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 0.2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');

                this.ktx2Loader = new KTX2Loader();
                this.ktx2Loader.setTranscoderPath('https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/');
                this.ktx2Loader.detectSupport(this.renderer);

                this.dracoLoader = new DRACOLoader();
                this.dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');

                this.gltfLoader = new GLTFLoader();
                this.gltfLoader.setPath('../assets/gltf/');
                this.gltfLoader.setKTX2Loader(this.ktx2Loader);
                this.gltfLoader.setDRACOLoader(this.dracoLoader);
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentRotation.z = MathUtils.degToRad(100);
                this.scene.environmentIntensity = 5;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static loadGLTF = async path => {
                const gltf = await this.gltfLoader.loadAsync(path);
                const model = gltf.scene;
                await this.renderer.compileAsync(model, this.camera, this.scene);
                return model;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({
                    fps: true,
                    info: {
                        content: '<a href="https://sketchfab.com/3d-models/crystal-6bac0beae27748899ef260a8bac3e4a8" target="_blank" rel="noopener">Crystal</a> by <a href="https://sketchfab.com/LM3D" target="_blank" rel="noopener">Luciano O. Mollo</a>'
                    }
                });
                this.ui.info.css({
                    pointerEvents: 'auto',
                    webkitUserSelect: 'auto',
                    userSelect: 'auto'
                });
                this.ui.info.animateIn();
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { renderer, scene, camera } = WorldController;

                PanelController.init(renderer, scene, camera, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update(time);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_crystal_gltf.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Crystal — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1:wght@400;700">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, GLTFLoader, Group, HemisphereLight, LightOptions, LightPanelController, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshPhysicalMaterial, OrbitControls, OrthographicCamera, Panel, PanelItem, PerspectiveCamera, PhysicalMaterialPanel, Scene, SceneCompositeDistortionMaterial, ScenePanel, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByLight, getKeyByValue, ticker } from '../../build/alien.three.js';

        class Crystal extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { anisotropy, loadGLTF } = WorldController;

                // Sketchfab model
                // https://sbtron.github.io/makeglb/
                const model = await loadGLTF('crystal.glb');
                model.scale.setScalar(0.01);
                // model.updateMatrixWorld(); // Needed for Point3D

                // Crystal mesh
                // https://threejs.org/docs/index.html#api/en/core/Object3D.getObjectByName
                // const avatar = gltf.scene.getObjectByName('avatar');
                const mesh = model.children[0].children[0].children[0].children[0].children[0];
                mesh.geometry.center(); // Also needed for Point3D
                mesh.position.y = 50;
                mesh.rotation.y = MathUtils.degToRad(200);

                // Textures
                mesh.material.map.anisotropy = anisotropy;
                mesh.material.normalMap.anisotropy = anisotropy;
                mesh.material.metalnessMap.anisotropy = anisotropy;
                mesh.material.roughnessMap.anisotropy = anisotropy;

                const material = new MeshPhysicalMaterial();
                material.color = mesh.material.color;
                material.metalness = mesh.material.metalness;
                material.roughness = mesh.material.roughness;
                material.map = mesh.material.map;
                material.normalMap = mesh.material.normalMap;
                material.metalnessMap = mesh.material.metalnessMap;
                material.roughnessMap = mesh.material.roughnessMap;
                material.side = mesh.material.side;
                material.transparent = mesh.material.transparent;
                material.opacity = mesh.material.opacity;
                material.transmission = 0.95;
                material.ior = 1.5;
                material.thickness = 5;
                // material.forceSinglePass = true;
                mesh.material.dispose();
                mesh.material = material;

                this.add(model);

                this.mesh = mesh;
            }

            // Public methods

            update = () => {
                this.mesh.rotation.y += 0.005;
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.crystal = new Crystal();
                this.add(this.crystal);
            }

            // Public methods

            update = () => {
                this.crystal.update();
            };

            ready = () => Promise.all([
                this.crystal.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PostPanel extends Panel {
            constructor() {
                super();

                this.initPanel();
            }

            initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const postOptions = {
                    Off: false,
                    On: true
                };

                const postItems = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                const items = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        name: 'Post',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: (value, item) => {
                            if (!item.hasContent()) {
                                const postPanel = new Panel();
                                postPanel.animateIn(true);

                                postItems.forEach(data => {
                                    postPanel.add(new PanelItem(data));
                                });

                                item.setContent(postPanel);
                            }

                            RenderManager.enabled = postOptions[value];

                            if (RenderManager.enabled) {
                                item.toggleContent(true);
                            } else {
                                item.toggleContent(false);
                            }
                        }
                    }
                ];

                items.forEach(data => {
                    this.add(new PanelItem(data));
                });
            }
        }

        class PanelController {
            static init(renderer, scene, camera, view, ui) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;
                this.ui = ui;

                this.lights = [];

                this.initControllers();
                this.initPanel();
            }

            static initControllers() {
                LightPanelController.init(this.scene);
            }

            static initPanel() {
                const { crystal } = this.view;

                const sceneOptions = {
                    Scene: ScenePanel,
                    Post: PostPanel
                };

                this.scene.traverse(object => {
                    if (object.isLight) {
                        const key = getKeyByLight(LightOptions, object);

                        sceneOptions[key] = [object, LightOptions[key][1]];

                        this.lights.push(object);
                    }
                });

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'content',
                        callback: (value, item) => {
                            const materialPanel = new PhysicalMaterialPanel(crystal.mesh);
                            materialPanel.animateIn(true);

                            item.setContent(materialPanel);
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'TRS',
                        min: 0.01,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.transmissionResolutionScale,
                        callback: value => {
                            this.renderer.transmissionResolutionScale = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: sceneOptions,
                        value: 'Scene',
                        callback: (value, item) => {
                            switch (value) {
                                case 'Scene':
                                case 'Post': {
                                    const ScenePanel = sceneOptions[value];

                                    const scenePanel = new ScenePanel(this.scene, this.ui);
                                    scenePanel.animateIn(true);

                                    item.setContent(scenePanel);
                                    break;
                                }
                                default: {
                                    const [light, LightPanel] = sceneOptions[value];

                                    const lightPanel = new LightPanel(LightPanelController, light);
                                    lightPanel.animateIn(true);

                                    item.setContent(lightPanel);
                                    break;
                                }
                            }
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Renderer settings
                this.transmissionResolutionScale = 1;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Renderer settings
                this.renderer.transmissionResolutionScale = this.transmissionResolutionScale;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.set(0, 6, 8);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 0.2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');

                this.gltfLoader = new GLTFLoader();
                this.gltfLoader.setPath('../assets/gltf/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentRotation.z = MathUtils.degToRad(100);
                this.scene.environmentIntensity = 5;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static loadGLTF = async path => {
                const gltf = await this.gltfLoader.loadAsync(path);
                const model = gltf.scene;
                await this.renderer.compileAsync(model, this.camera, this.scene);
                return model;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({
                    fps: true,
                    info: {
                        content: '<a href="https://sketchfab.com/3d-models/crystal-6bac0beae27748899ef260a8bac3e4a8" target="_blank" rel="noopener">Crystal</a> by <a href="https://sketchfab.com/LM3D" target="_blank" rel="noopener">Luciano O. Mollo</a>'
                    }
                });
                this.ui.info.css({
                    pointerEvents: 'auto',
                    webkitUserSelect: 'auto',
                    userSelect: 'auto'
                });
                this.ui.info.animateIn();
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { renderer, scene, camera } = WorldController;

                PanelController.init(renderer, scene, camera, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update(time);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_cubecamera_rainbow.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>CubeCamera Rainbow — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BackSide, BlurMaterial, Color, ColorManagement, CubeCamera, GLSL3, Group, IcosahedronGeometry, ImageBitmapLoaderThread, LinearMipmapLinearFilter, LinearSRGBColorSpace, MathUtils, Mesh, MeshBasicMaterial, NoBlending, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, Scene, SphereGeometry, Sprite, SpriteMaterial, TextureLoader, UI, Vector2, Vector3, WebGLCubeRenderTarget, WebGLRenderTarget, WebGLRenderer, Wobble, getFullscreenTriangle, getKeyByValue, ticker, tween } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const colors = {
            backgroundColor: 0x030627,
            lightColor: 0xff8dfc,
            particleColor: 0x8080ff
        };

        // https://twitter.com/pschroen/status/1405600020284444674

        // Based on https://github.com/yuichiroharai/glsl-y-hsv
        // Based on https://github.com/spite/codevember-2016

        import hsv2rgbSmooth from '../../src/shaders/modules/hsv/hsv2rgbSmooth.glsl.js';
        import rgb2hsv from '../../src/shaders/modules/hsv/rgb2hsv.glsl.js';
        import noise from '../../src/shaders/modules/noise/noise2d.glsl.js';
        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
        import blendOverlay from '../../src/shaders/modules/blending/overlay.glsl.js';
        import blendSoftLight from '../../src/shaders/modules/blending/soft-light.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                const { getTexture, scene } = WorldController;

                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        tLensDirt: { value: getTexture('lens_dirt.jpg') },
                        uLightColor: { value: new Color(colors.lightColor) },
                        uColor: { value: scene.background },
                        uRGBAmount: { value: 0.2 },
                        uBloomReduction: { value: 0.07 },
                        uBloomBoost: { value: 0.4 },
                        uBloomClamp: { value: 1 },
                        uHue: { value: 0 },
                        uReduction: { value: 1.2 },
                        uBoost: { value: 1 },
                        uLensDirt: { value: true },
                        uDebug: { value: isDebug },
                        uResolution: { value: new Vector2() },
                        uTime: { value: 0 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform sampler2D tLensDirt;
                        uniform vec3 uLightColor;
                        uniform vec3 uColor;
                        uniform float uRGBAmount;
                        uniform float uBloomReduction;
                        uniform float uBloomBoost;
                        uniform float uBloomClamp;
                        uniform float uHue;
                        uniform float uReduction;
                        uniform float uBoost;
                        uniform bool uLensDirt;
                        uniform bool uDebug;
                        uniform vec2 uResolution;
                        uniform float uTime;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${hsv2rgbSmooth}
                        ${rgb2hsv}
                        ${noise}
                        ${rgbshift}
                        ${blendOverlay}
                        ${blendSoftLight}

                        void main() {
                            float center = length(vUv - 0.5);

                            vec3 rgb = uColor;
                            vec3 hsv = rgb2hsv(rgb);
                            hsv.x += vUv.x + uHue;

                            rgb = hsv2rgbSmooth(hsv);

                            // Linear gradient
                            vec4 color = vec4(mix(rgb, vec3(0.0), smoothstep(0.0, 0.6, vUv.y)), 1.0);

                            color += getRGB(tScene, vUv, 0.1, 0.002 * uRGBAmount);

                            vec4 bloom = texture(tBloom, vUv);
                            bloom.r = max(0.0, bloom.r - uBloomReduction);
                            bloom.g = max(0.0, bloom.g - uBloomReduction);
                            bloom.b = max(0.0, bloom.b - uBloomReduction);
                            bloom.rgb *= uBloomBoost;
                            bloom = clamp(bloom, 0.0, uBloomClamp);

                            color.rgb += bloom.rgb;

                            // Blend overlay noise lighting
                            float noise = noise(vUv + uTime * 0.06);
                            float amount = smoothstep(0.2, 0.7, center) * noise;

                            if (uDebug) {
                                color += vec4(vec3(1.0, 0.0, 0.0), 1.0) * amount;
                            } else {
                                color = blendOverlay(color, vec4(uLightColor, 1.0), amount);
                            }

                            // Blend overlay vignetting
                            float vignette = uBoost - center * uReduction;

                            vec4 base = color;
                            vec4 blend = vec4(vec3(vignette), 1.0);

                            color = blendOverlay(base, blend, 1.0);

                            // Blend soft light background color
                            base = color;
                            blend = vec4(rgb, 1.0);

                            color = blendSoftLight(base, blend, 0.8);

                            // Dirt lens texture
                            if (uLensDirt) {
                                vec2 vUv2 = vUv;

                                float aspectRatio2 = 1.0;
                                float aspectRatio = uResolution.x / uResolution.y;

                                if (aspectRatio2 > aspectRatio) {
                                    float widthRatio = aspectRatio / aspectRatio2;
                                    vUv2.x = vUv.x * widthRatio;
                                    vUv2.x += 0.5 * (1.0 - widthRatio);
                                    vUv2.y = vUv.y;
                                } else {
                                    float heightRatio = aspectRatio2 / aspectRatio;
                                    vUv2.x = vUv.x;
                                    vUv2.y = vUv.y * heightRatio;
                                    vUv2.y += 0.5 * (1.0 - heightRatio);
                                }

                                color.rgb += smoothstep(0.0, 0.4, bloom.rgb) * texture(tLensDirt, vUv2).rgb;
                            }

                            FragColor = color;
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class Sphere extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { cubeRenderTarget } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Chrome material
                const material = new MeshBasicMaterial({
                    envMap: cubeRenderTarget.texture
                });

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class Stars extends Group {
            constructor(numParticles) {
                super();

                this.numParticles = numParticles;

                this.sprites = [];
                this.nearScale = 0.3;

                this.initSprites();
            }

            initSprites() {
                const { getTexture, hue, resolution } = WorldController;

                const material = new SpriteMaterial({
                    map: getTexture('particle2.png'),
                    color: new Color(colors.particleColor),
                    transparent: true,
                    blending: AdditiveBlending,
                    depthWrite: false
                });

                material.onBeforeCompile = shader => {
                    shader.uniforms.hue = hue;
                    shader.uniforms.resolution = resolution;

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float hue;
                        uniform vec2 resolution;

                        ${hsv2rgbSmooth}
                        ${rgb2hsv}

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'outgoingLight = diffuseColor.rgb;',
                        /* glsl */ `
                        vec2 position = (gl_FragCoord.xy / resolution);

                        vec3 hsv = rgb2hsv(diffuseColor.rgb);
                        hsv.x += position.x + hue;

                        outgoingLight = hsv2rgbSmooth(hsv);
                        `
                    );
                };

                for (let i = 0; i < this.numParticles; i++) {
                    const distance = MathUtils.randFloat(10, 40);

                    const sprite = new Sprite(material);
                    sprite.position.x = Math.random() * 2 - 1;
                    sprite.position.y = Math.random() * 2 - 1;
                    sprite.position.z = Math.random() * 2 - 1;
                    sprite.position.normalize();
                    sprite.position.multiplyScalar(distance);
                    sprite.scale.set(0.3, 0.3, 1);

                    sprite.random = Math.random();

                    sprite.origin = new Vector3();
                    sprite.near = new Vector3();
                    sprite.origin.copy(sprite.position);
                    sprite.near.copy(sprite.origin).multiplyScalar(this.nearScale);

                    sprite.wobble = new Wobble(sprite.origin);
                    sprite.wobble.scale = 0.3;

                    this.add(sprite);
                    this.sprites.push(sprite);
                }
            }

            // Public methods

            update = (time, near) => {
                this.sprites.forEach(sprite => {
                    if (near) {
                        sprite.wobble.origin.copy(sprite.wobble.position);
                        // sprite.wobble.update(sprite.random + time);
                        sprite.wobble.update(time * sprite.random);
                        sprite.position.copy(sprite.near.copy(sprite.origin).multiplyScalar(this.nearScale));
                    } else {
                        sprite.position.copy(sprite.origin);
                    }
                });
            };
        }

        class Space extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(40, 3);

                const map = await loadTexture('space.jpg');

                const material = new MeshBasicMaterial({
                    map,
                    side: BackSide,
                    transparent: true,
                    opacity: 0.05
                });

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initRenderer();
                this.initViews();
            }

            initRenderer() {
                const { renderer, scene, cubeCamera } = WorldController;

                this.renderer = renderer;
                this.scene = scene;
                this.cubeCamera = cubeCamera;
            }

            initViews() {
                this.space = new Space();
                this.add(this.space);

                this.stars = new Stars(2000);
                this.add(this.stars);

                this.sphere = new Sphere();
                this.add(this.sphere);
            }

            // Public methods

            update = time => {
                this.sphere.visible = false;
                this.stars.update(time, true);
                this.cubeCamera.update(this.renderer, this.scene);
                this.stars.update(time, false);
                this.sphere.visible = true;
            };

            ready = () => this.space.ready();
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
            };

            static update = time => {
                this.view.update(time);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { hBlurMaterial, vBlurMaterial, compositeMaterial } = RenderManager;

                const postOptions = {
                    Off: false,
                    Post: true
                };

                const debugOptions = {
                    Off: false,
                    Debug: true
                };

                const dirtOptions = {
                    Off: false,
                    Dirt: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: value => {
                            RenderManager.enabled = postOptions[value];
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uRGBAmount.value,
                        callback: value => {
                            compositeMaterial.uniforms.uRGBAmount.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Reduce',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uReduction.value,
                        callback: value => {
                            compositeMaterial.uniforms.uReduction.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Boost',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uBoost.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBoost.value = value;
                        }
                    },
                    {
                        type: 'list',
                        list: debugOptions,
                        value: getKeyByValue(debugOptions, compositeMaterial.uniforms.uDebug.value),
                        callback: value => {
                            compositeMaterial.uniforms.uDebug.value = debugOptions[value];
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Blur',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: hBlurMaterial.uniforms.uBlurAmount.value,
                        callback: value => {
                            hBlurMaterial.uniforms.uBlurAmount.value = value;
                            vBlurMaterial.uniforms.uBlurAmount.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Reduce',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uBloomReduction.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomReduction.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Boost',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomBoost.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomBoost.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uBloomClamp.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomClamp.value = value;
                        }
                    },
                    {
                        type: 'list',
                        list: dirtOptions,
                        value: getKeyByValue(dirtOptions, compositeMaterial.uniforms.uLensDirt.value),
                        callback: value => {
                            compositeMaterial.uniforms.uLensDirt.value = dirtOptions[value];
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.blurResolutionScale = 0.25;
                this.blurAmount = 1.5;
                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, hue, resolution, time } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBlurA = this.renderTarget.clone();
                this.renderTargetBlurB = this.renderTarget.clone();

                this.renderTarget.depthBuffer = true;

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.uHue = hue;
                this.compositeMaterial.uniforms.uResolution = resolution;
                this.compositeMaterial.uniforms.uTime = time;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                width = Math.round(width * this.blurResolutionScale);
                height = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(width, height);
                this.renderTargetBlurB.setSize(width, height);

                this.hBlurMaterial.uniforms.uResolution.value.set(width, height);
                this.vBlurMaterial.uniforms.uResolution.value.set(width, height);
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.target = new Vector2();

                // Motion control
                this.group = new Group();
                this.innerGroup = new Group();
                this.group.add(this.innerGroup);
                this.group.matrixAutoUpdate = false;
                this.innerGroup.matrixAutoUpdate = false;

                // Start position
                this.innerGroup.position.copy(this.camera.position);

                this.rotation = 0.0002;
                this.lerpSpeed = 0.05;
                this.multiplier = 1;
                this.enabled = false;
                this.prevent = true;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (this.prevent) {
                    return;
                }

                this.mouse.x = clientX - this.halfWidth;
                this.mouse.y = clientY - this.halfHeight;

                this.target.x = MathUtils.degToRad(-360) + this.mouse.x * this.rotation * this.multiplier;
                this.target.y = this.mouse.y * this.rotation * this.multiplier;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                this.halfWidth = width / 2;
                this.halfHeight = height / 2;

                if (width < height) {
                    this.camera.position.z = 10;
                    this.multiplier = 2;
                } else {
                    this.camera.position.z = 8;
                    this.multiplier = 1;
                }

                this.innerGroup.position.z = this.camera.position.z;
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.group.rotation.x += (this.target.y - this.group.rotation.x) * this.lerpSpeed;
                this.group.rotation.y += (this.target.x - this.group.rotation.y) * this.lerpSpeed;

                this.updateCamera();
            };

            static updateCamera = () => {
                this.group.updateMatrix();
                this.innerGroup.updateMatrix();
                this.group.updateMatrixWorld();
                this.innerGroup.matrixWorld.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
            };

            static animateIn = () => {
                this.enabled = true;

                tween(this.target, { x: MathUtils.degToRad(-360) }, 4200, 'easeInOutQuart', () => {
                    this.prevent = false;
                });
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(colors.backgroundColor);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 50;
                this.camera.position.z = 8;
                this.camera.zoom = 0.8;
                this.camera.lookAt(this.scene.position);

                // Cube render target
                this.cubeRenderTarget = new WebGLCubeRenderTarget(512, {
                    minFilter: LinearMipmapLinearFilter,
                    generateMipmaps: true
                });

                // Cube camera
                this.cubeCamera = new CubeCamera(this.camera.near, this.camera.far, this.cubeRenderTarget);
                this.scene.add(this.cubeCamera);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Initial background color
                this.color = {};
                this.scene.background.getHSL(this.color);

                // Global uniforms
                this.hue = { value: this.color.h };
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.hue.value += 0.0005;

                this.scene.background.setHSL(this.hue.value, this.color.s, this.color.l);

                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update(time);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_cubecamera.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>CubeCamera — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BackSide, BlurMaterial, Color, ColorManagement, CubeCamera, GLSL3, Group, IcosahedronGeometry, ImageBitmapLoaderThread, LinearMipmapLinearFilter, LinearSRGBColorSpace, MathUtils, Mesh, MeshBasicMaterial, NoBlending, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, Scene, SphereGeometry, Sprite, SpriteMaterial, TextureLoader, UI, Vector2, Vector3, WebGLCubeRenderTarget, WebGLRenderTarget, WebGLRenderer, Wobble, getFullscreenTriangle, getKeyByValue, ticker, tween } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const colors = {
            backgroundColor: 0x030627,
            lightColor: 0xff8dfc,
            particleColor: 0x8080ff
        };

        // https://twitter.com/pschroen/status/1405600020284444674

        // Based on https://github.com/spite/codevember-2016

        import noise from '../../src/shaders/modules/noise/noise2d.glsl.js';
        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
        import blendOverlay from '../../src/shaders/modules/blending/overlay.glsl.js';
        import blendSoftLight from '../../src/shaders/modules/blending/soft-light.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                const { getTexture } = WorldController;

                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        tLensDirt: { value: getTexture('lens_dirt.jpg') },
                        uLightColor: { value: new Color(colors.lightColor) },
                        uColor: { value: new Color(colors.backgroundColor) },
                        uRGBAmount: { value: 0.2 },
                        uBloomReduction: { value: 0.07 },
                        uBloomBoost: { value: 0.4 },
                        uBloomClamp: { value: 1 },
                        uReduction: { value: 1.2 },
                        uBoost: { value: 1 },
                        uLensDirt: { value: true },
                        uDebug: { value: isDebug },
                        uResolution: { value: new Vector2() },
                        uTime: { value: 0 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform sampler2D tLensDirt;
                        uniform vec3 uLightColor;
                        uniform vec3 uColor;
                        uniform float uRGBAmount;
                        uniform float uBloomReduction;
                        uniform float uBloomBoost;
                        uniform float uBloomClamp;
                        uniform float uReduction;
                        uniform float uBoost;
                        uniform bool uLensDirt;
                        uniform bool uDebug;
                        uniform vec2 uResolution;
                        uniform float uTime;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${noise}
                        ${rgbshift}
                        ${blendOverlay}
                        ${blendSoftLight}

                        void main() {
                            float center = length(vUv - 0.5);

                            // Linear gradient
                            vec4 color = vec4(mix(uColor, vec3(0.0), smoothstep(0.0, 0.6, vUv.y)), 1.0);

                            color += getRGB(tScene, vUv, 0.1, 0.002 * uRGBAmount);

                            vec4 bloom = texture(tBloom, vUv);
                            bloom.r = max(0.0, bloom.r - uBloomReduction);
                            bloom.g = max(0.0, bloom.g - uBloomReduction);
                            bloom.b = max(0.0, bloom.b - uBloomReduction);
                            bloom.rgb *= uBloomBoost;
                            bloom = clamp(bloom, 0.0, uBloomClamp);

                            color.rgb += bloom.rgb;

                            // Blend overlay noise lighting
                            float noise = noise(vUv + uTime * 0.06);
                            float amount = smoothstep(0.2, 0.7, center) * noise;

                            if (uDebug) {
                                color += vec4(vec3(1.0, 0.0, 0.0), 1.0) * amount;
                            } else {
                                color = blendOverlay(color, vec4(uLightColor, 1.0), amount);
                            }

                            // Blend overlay vignetting
                            float vignette = uBoost - center * uReduction;

                            vec4 base = color;
                            vec4 blend = vec4(vec3(vignette), 1.0);

                            color = blendOverlay(base, blend, 1.0);

                            // Blend soft light background color
                            base = color;
                            blend = vec4(uColor, 1.0);

                            color = blendSoftLight(base, blend, 0.8);

                            // Dirt lens texture
                            if (uLensDirt) {
                                vec2 vUv2 = vUv;

                                float aspectRatio2 = 1.0;
                                float aspectRatio = uResolution.x / uResolution.y;

                                if (aspectRatio2 > aspectRatio) {
                                    float widthRatio = aspectRatio / aspectRatio2;
                                    vUv2.x = vUv.x * widthRatio;
                                    vUv2.x += 0.5 * (1.0 - widthRatio);
                                    vUv2.y = vUv.y;
                                } else {
                                    float heightRatio = aspectRatio2 / aspectRatio;
                                    vUv2.x = vUv.x;
                                    vUv2.y = vUv.y * heightRatio;
                                    vUv2.y += 0.5 * (1.0 - heightRatio);
                                }

                                color.rgb += smoothstep(0.0, 0.4, bloom.rgb) * texture(tLensDirt, vUv2).rgb;
                            }

                            FragColor = color;
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class Sphere extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { cubeRenderTarget } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Chrome material
                const material = new MeshBasicMaterial({
                    envMap: cubeRenderTarget.texture
                });

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class Stars extends Group {
            constructor(numParticles) {
                super();

                this.numParticles = numParticles;

                this.sprites = [];
                this.nearScale = 0.3;

                this.initSprites();
            }

            initSprites() {
                const { getTexture } = WorldController;

                const material = new SpriteMaterial({
                    map: getTexture('particle2.png'),
                    color: new Color(colors.particleColor),
                    transparent: true,
                    blending: AdditiveBlending,
                    depthWrite: false
                });

                for (let i = 0; i < this.numParticles; i++) {
                    const distance = MathUtils.randFloat(10, 40);

                    const sprite = new Sprite(material);
                    sprite.position.x = Math.random() * 2 - 1;
                    sprite.position.y = Math.random() * 2 - 1;
                    sprite.position.z = Math.random() * 2 - 1;
                    sprite.position.normalize();
                    sprite.position.multiplyScalar(distance);
                    sprite.scale.set(0.3, 0.3, 1);

                    sprite.random = Math.random();

                    sprite.origin = new Vector3();
                    sprite.near = new Vector3();
                    sprite.origin.copy(sprite.position);
                    sprite.near.copy(sprite.origin).multiplyScalar(this.nearScale);

                    sprite.wobble = new Wobble(sprite.origin);
                    sprite.wobble.scale = 0.3;

                    this.add(sprite);
                    this.sprites.push(sprite);
                }
            }

            // Public methods

            update = (time, near) => {
                this.sprites.forEach(sprite => {
                    if (near) {
                        sprite.wobble.origin.copy(sprite.wobble.position);
                        // sprite.wobble.update(sprite.random + time);
                        sprite.wobble.update(time * sprite.random);
                        sprite.position.copy(sprite.near.copy(sprite.origin).multiplyScalar(this.nearScale));
                    } else {
                        sprite.position.copy(sprite.origin);
                    }
                });
            };
        }

        class Space extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(40, 3);

                const map = await loadTexture('space.jpg');

                const material = new MeshBasicMaterial({
                    map,
                    side: BackSide,
                    transparent: true,
                    opacity: 0.05
                });

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initRenderer();
                this.initViews();
            }

            initRenderer() {
                const { renderer, scene, cubeCamera } = WorldController;

                this.renderer = renderer;
                this.scene = scene;
                this.cubeCamera = cubeCamera;
            }

            initViews() {
                this.space = new Space();
                this.add(this.space);

                this.stars = new Stars(2000);
                this.add(this.stars);

                this.sphere = new Sphere();
                this.add(this.sphere);
            }

            // Public methods

            update = time => {
                this.sphere.visible = false;
                this.stars.update(time, true);
                this.cubeCamera.update(this.renderer, this.scene);
                this.stars.update(time, false);
                this.sphere.visible = true;
            };

            ready = () => this.space.ready();
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
            };

            static update = time => {
                this.view.update(time);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { hBlurMaterial, vBlurMaterial, compositeMaterial } = RenderManager;

                const postOptions = {
                    Off: false,
                    Post: true
                };

                const debugOptions = {
                    Off: false,
                    Debug: true
                };

                const dirtOptions = {
                    Off: false,
                    Dirt: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: value => {
                            RenderManager.enabled = postOptions[value];
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uRGBAmount.value,
                        callback: value => {
                            compositeMaterial.uniforms.uRGBAmount.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Reduce',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uReduction.value,
                        callback: value => {
                            compositeMaterial.uniforms.uReduction.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Boost',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uBoost.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBoost.value = value;
                        }
                    },
                    {
                        type: 'list',
                        list: debugOptions,
                        value: getKeyByValue(debugOptions, compositeMaterial.uniforms.uDebug.value),
                        callback: value => {
                            compositeMaterial.uniforms.uDebug.value = debugOptions[value];
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Blur',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: hBlurMaterial.uniforms.uBlurAmount.value,
                        callback: value => {
                            hBlurMaterial.uniforms.uBlurAmount.value = value;
                            vBlurMaterial.uniforms.uBlurAmount.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Reduce',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uBloomReduction.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomReduction.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Boost',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomBoost.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomBoost.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uBloomClamp.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomClamp.value = value;
                        }
                    },
                    {
                        type: 'list',
                        list: dirtOptions,
                        value: getKeyByValue(dirtOptions, compositeMaterial.uniforms.uLensDirt.value),
                        callback: value => {
                            compositeMaterial.uniforms.uLensDirt.value = dirtOptions[value];
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.blurResolutionScale = 0.25;
                this.blurAmount = 1.5;
                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution, time } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBlurA = this.renderTarget.clone();
                this.renderTargetBlurB = this.renderTarget.clone();

                this.renderTarget.depthBuffer = true;

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.uResolution = resolution;
                this.compositeMaterial.uniforms.uTime = time;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                width = Math.round(width * this.blurResolutionScale);
                height = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(width, height);
                this.renderTargetBlurB.setSize(width, height);

                this.hBlurMaterial.uniforms.uResolution.value.set(width, height);
                this.vBlurMaterial.uniforms.uResolution.value.set(width, height);
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.target = new Vector2();

                // Motion control
                this.group = new Group();
                this.innerGroup = new Group();
                this.group.add(this.innerGroup);
                this.group.matrixAutoUpdate = false;
                this.innerGroup.matrixAutoUpdate = false;

                // Start position
                this.innerGroup.position.copy(this.camera.position);

                this.rotation = 0.0002;
                this.lerpSpeed = 0.05;
                this.multiplier = 1;
                this.enabled = false;
                this.prevent = true;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (this.prevent) {
                    return;
                }

                this.mouse.x = clientX - this.halfWidth;
                this.mouse.y = clientY - this.halfHeight;

                this.target.x = MathUtils.degToRad(-360) + this.mouse.x * this.rotation * this.multiplier;
                this.target.y = this.mouse.y * this.rotation * this.multiplier;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                this.halfWidth = width / 2;
                this.halfHeight = height / 2;

                if (width < height) {
                    this.camera.position.z = 10;
                    this.multiplier = 2;
                } else {
                    this.camera.position.z = 8;
                    this.multiplier = 1;
                }

                this.innerGroup.position.z = this.camera.position.z;
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.group.rotation.x += (this.target.y - this.group.rotation.x) * this.lerpSpeed;
                this.group.rotation.y += (this.target.x - this.group.rotation.y) * this.lerpSpeed;

                this.updateCamera();
            };

            static updateCamera = () => {
                this.group.updateMatrix();
                this.innerGroup.updateMatrix();
                this.group.updateMatrixWorld();
                this.innerGroup.matrixWorld.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
            };

            static animateIn = () => {
                this.enabled = true;

                tween(this.target, { x: MathUtils.degToRad(-360) }, 4200, 'easeInOutQuart', () => {
                    this.prevent = false;
                });
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(colors.backgroundColor);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 50;
                this.camera.position.z = 8;
                this.camera.zoom = 0.8;
                this.camera.lookAt(this.scene.position);

                // Cube render target
                this.cubeRenderTarget = new WebGLCubeRenderTarget(512, {
                    minFilter: LinearMipmapLinearFilter,
                    generateMipmaps: true
                });

                // Cube camera
                this.cubeCamera = new CubeCamera(this.camera.near, this.camera.far, this.cubeRenderTarget);
                this.scene.add(this.cubeCamera);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update(time);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_cubemap_uv.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Cubemap UV — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BasicMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, Group, ImageBitmapLoaderThread, LinearSRGBColorSpace, Mesh, OrbitControls, PerspectiveCamera, Scene, TextureLoader, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        /*

        Instructions to export buffer geometry from Cinema 4D

        1) Select Model mode from the toolbar and select the object you would like to export.

        2) Load the UV grid texture from the assets directory into the Material Manager.

        3) Double-click on the UV grid Material and turn off Reflectance.

        4) Drag the UV grid Material to your object.

        5) Apply the "Set UVW from Projection" Material Tag, click the gear icon to change settings.

        If "Set UVW from Projection" is greyed-out you need to "Make Editable".

        6) We're going to export a local space object with the axis and coordinates at the centre of the object.

        If you need to centre the axis, from the Tools Axis menu, "Center Axis to".
        And set the world space coordinates of the object to 0 by setting the "Position" to 0 cm.

        7) The default size of objects in three.js is much smaller than the default in Cinema 4D.

        If you need to reduce the size, for example, a default sized cube in Cinema 4D is 200 cm.
        And units in three.js are normalized at 1 cm, so in this case you would set the "Size" to 2 cm.
        Alternatively, you can set the "Scale" to 0.01. Note that "Size" and "Scale" are different.
        You can find the "Size" of your object in the Coordinate Manager.

        8) From the Objects' File menu, export the selected object as an OBJ file, Default settings are fine.

        9) Open the three.js editor, create a new scene and import the OBJ file:
        https://threejs.org/editor/

        10) Click the plus sign (+) next to your object and select the first child object.

        11) Finally, re-export the object again with "Export Geometry".

        12) Outputs a .json with the required position, normal and uv attributes.

        Note you can only export one UV at a time.
        If you want to use uv1 you'll need to re-export with the other UV in slot 1.
        And then manually copy-paste the uv attribute into the .json as the uv1 attribute.

        13) Repeat for each of your objects.

        */

        class Cube extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('cube.json');

                // Use second set of UVs for cubemap row layout
                // https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Cubemaps/CreatingCubemaps/
                geometry.attributes.uv = geometry.attributes.uv1;

                this.geometry = geometry;
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                const map = await loadTexture('cubemap.jpg');
                map.anisotropy = anisotropy;

                this.material = new BasicMaterial({ map });
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.cube = new Cube();
                this.add(this.cube);
            }

            // Public methods

            animateIn = () => {
                this.visible = true;
            };

            ready = () => Promise.all([
                this.cube.ready()
            ]);
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLoaders();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await this.view.ready();
                this.view.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_graph_tracking.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Graph Tracking — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, LinearSRGBColorSpace, LuminosityMaterial, MapControls, MathUtils, Mesh, MeshStandardMaterial, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, Point3D, RadialGraphCanvas, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        class AbstractCube extends Group {
            constructor() {
                super();

                this.position.x = 2.5;
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new BoxGeometry();

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                normalMap.anisotropy = anisotropy;
                ormMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    name: 'Abstract Cube',
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 0.7,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1),
                    flatShading: true,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.rotation.x = MathUtils.degToRad(-45);
                mesh.rotation.z = MathUtils.degToRad(-45);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = () => {
                this.mesh.rotation.y -= 0.005;
            };

            ready = () => this.initMesh();
        }

        class FloatingCrystal extends Group {
            constructor() {
                super();

                this.position.y = 0.7;
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new OctahedronGeometry();

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 2);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 2);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 2);

                const material = new MeshStandardMaterial({
                    name: 'Floating Crystal',
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 0.7,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1),
                    flatShading: true,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.scale.set(0.5, 1, 0.5);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = time => {
                this.mesh.position.y = Math.sin(time) * 0.1;
                this.mesh.rotation.y += 0.01;
            };

            ready = () => this.initMesh();
        }

        class DarkPlanet extends Group {
            constructor() {
                super();

                this.position.x = -2.5;

                // 25 degree tilt like Mars
                this.rotation.z = MathUtils.degToRad(25);
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.6, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    name: 'Dark Planet',
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3),
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = () => {
                // Counter clockwise rotation
                this.mesh.rotation.y += 0.005;
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.darkPlanet = new DarkPlanet();
                this.add(this.darkPlanet);

                this.floatingCrystal = new FloatingCrystal();
                this.add(this.floatingCrystal);

                this.abstractCube = new AbstractCube();
                this.add(this.abstractCube);
            }

            // Public methods

            update = time => {
                this.darkPlanet.update(time);
                this.floatingCrystal.update(time);
                this.abstractCube.update(time);
            };

            ready = () => Promise.all([
                this.darkPlanet.ready(),
                this.floatingCrystal.ready(),
                this.abstractCube.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
            };

            static update = time => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update(time);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class ScenePanelController {
            static init(view) {
                this.view = view;

                this.initPanel();
            }

            static initPanel() {
                const { darkPlanet, floatingCrystal, abstractCube } = this.view;

                const objects = [darkPlanet, floatingCrystal, abstractCube];

                objects.forEach(object => {
                    object.graph = new RadialGraphCanvas({
                        value: Array.from({ length: 10 }, () => Math.random()),
                        start: -45,
                        graphHeight: 40,
                        precision: 2,
                        lookupPrecision: 200
                    });

                    object.point = new Point3D(object.mesh, {
                        type: 'localhost',
                        graph: object.graph
                    });
                    object.add(object.point);

                    const items = [
                        {
                            type: 'divider'
                        },
                        {
                            type: 'link',
                            value: 'Update',
                            callback: () => {
                                object.graph.setArray(Array.from({ length: 10 }, () => Math.random()));
                            }
                        }
                    ];

                    items.forEach(data => {
                        object.point.addPanel(new PanelItem(data));
                    });
                });

                // Shrink tracker mesh to better match the visual size of the object
                floatingCrystal.point.mesh.scale.multiply(new Vector3(0.6, 1, 0.6));
                abstractCube.point.mesh.scale.multiplyScalar(0.9);
            }
        }

        class PanelController {
            static init(renderer, scene, camera, view, ui) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;
                this.ui = ui;

                this.initControllers();
                this.initPanel();
            }

            static initControllers() {
                Point3D.init(this.renderer, this.scene, this.camera, {
                    container: this.ui,
                    debug: isDebug
                });

                ScenePanelController.init(this.view);
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }

            // Public methods

            static update = time => {
                if (!this.ui) {
                    return;
                }

                Point3D.update(time);
            };
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.set(0, 6, 8);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
                this.textureLoader.cache = true;

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initControls() {
                this.controls = new MapControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { renderer, scene, camera } = WorldController;

                PanelController.init(renderer, scene, camera, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update(time);
                RenderManager.update(time, delta, frame);
                PanelController.update(time);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_infinite_stars_rgbshift.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Infinite Stars with RGB shift Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BoxGeometry, BufferGeometry, Color, ColorManagement, CopyMaterial, Float32BufferAttribute, GLSL3, Group, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, NoBlending, OrbitControls, OrthographicCamera, PanelItem, PerspectiveCamera, Points, RawShaderMaterial, Scene, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        // Based on https://github.com/OGRECave/ogre/blob/master/Samples/Media/materials/programs/GLSL/Radial_Blur_FP.glsl
        // Based on https://stackoverflow.com/questions/4579020/how-do-i-use-a-glsl-shader-to-apply-a-radial-blur-to-an-entire-scene

        import blur from '../../src/shaders/modules/blur/radial-blur8-rgbshift.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: null },
                        uBlurDist: { value: 1 },
                        uBlurAmount: { value: 2.2 },
                        uRGBAmount: { value: 2.2 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tMap;
                        uniform float uBlurDist;
                        uniform float uBlurAmount;
                        uniform float uRGBAmount;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${blur}

                        void main() {
                            vec2 dir = 0.5 - vUv;
                            float dist = length(dir);
                            dist = clamp(smoothstep(0.2, 0.7, dist), 0.0, 1.0);
                            float angle = atan(dir.y, dir.x);
                            float amount = 0.002 * dist * uRGBAmount;

                            FragColor = radialBlurRGB(tMap, vUv, 0.1 * dist * uBlurDist, uBlurAmount, angle, amount);
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class Stars extends Group {
            constructor(numParticles, blockSize, wireframeColor) {
                super();

                this.numParticles = numParticles;
                this.blockSize = blockSize;
                this.wireframeColor = wireframeColor;

                this.initPoints();
            }

            initPoints() {
                const { camera, getTexture, resolution, time } = WorldController;

                const vertices = [];

                for (let i = 0; i < this.numParticles; i++) {
                    vertices[i * 3 + 0] = MathUtils.randFloatSpread(this.blockSize / 2);
                    vertices[i * 3 + 1] = MathUtils.randFloatSpread(this.blockSize / 2);
                    vertices[i * 3 + 2] = -this.blockSize / 2 + MathUtils.randFloatSpread(this.blockSize);
                }

                const geometry = new BufferGeometry();
                geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));

                const material = new RawShaderMaterial({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: getTexture('particle2.png') },
                        uScale: { value: window.devicePixelRatio / 2 },
                        uAlpha: { value: 1 },
                        uCameraNear: { value: camera.near },
                        uCameraFar: { value: this.blockSize },
                        uResolution: resolution,
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;

                        uniform mat4 modelMatrix;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;

                        uniform float uScale;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform float uTime;

                        out float vFade;

                        void main() {
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

                            gl_PointSize = uScale * (150.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;

                            vec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                            float linearDepth = 1.0 / (uCameraFar - uCameraNear);
                            float linearPos = length(cameraPosition - worldPosition) * linearDepth;

                            vFade = 1.0 - linearPos * 0.75;
                            vFade *= smoothstep(0.09, 0.13, linearPos);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tMap;
                        uniform float uAlpha;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform vec2 uResolution;

                        in float vFade;

                        out vec4 FragColor;

                        void main() {
                            FragColor = texture(tMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
                            FragColor.a *= vFade;
                            FragColor.a *= uAlpha;
                        }
                    `,
                    transparent: true,
                    blending: AdditiveBlending,
                    depthTest: false,
                    depthWrite: false
                });

                const points = new Points(geometry, material);
                this.add(points);

                this.material = material;

                if (isDebug) {
                    const wireframe = new Mesh(
                        new BoxGeometry(this.blockSize / 2, this.blockSize / 2, this.blockSize),
                        new MeshBasicMaterial({
                            color: this.wireframeColor,
                            wireframe: true
                        })
                    );
                    wireframe.position.set(0, 0, -this.blockSize / 2);
                    this.add(wireframe);
                }
            }
        }

        class InfiniteStars extends Group {
            constructor(camera, numParticles, blockSize, zSpeed) {
                super();

                this.camera = camera;
                this.numParticles = numParticles;
                this.blockSize = blockSize;
                this.zSpeed = zSpeed / 100;

                this.wireframeColors = [
                    0xff0000,
                    0x00ff00,
                    0x0000ff
                ];

                this.initStars();
            }

            initStars() {
                for (let i = 0; i < 3; i++) {
                    const stars = new Stars(this.numParticles, this.blockSize, this.wireframeColors[i]);
                    stars.position.z = i * -this.blockSize;
                    this.add(stars);
                }
            }

            update() {
                this.position.z += this.zSpeed;

                for (let i = 0; i < 3; i++) {
                    const stars = this.children[i];
                    const z = this.position.z + stars.position.z;

                    if (z > this.blockSize * 2) {
                        stars.position.z -= this.blockSize * 3;
                    }
                }
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            async initMesh() {
            }
        }

        class PanelController {
            static init(stars, ui) {
                this.stars = stars;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Speed',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: this.stars.zSpeed * 100,
                        callback: value => {
                            this.stars.zSpeed = value / 100;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, stars) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.stars = stars;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Blend it additively
                this.bloomCompositeMaterial.blending = AdditiveBlending;

                // Stars scene
                this.starsScene = new Scene();
                this.starsScene.add(this.stars);

                // Copy material
                this.copyMaterial = new CopyMaterial();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.screen, this.screenCamera);

                // Stars scene
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.starsScene, camera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLoaders();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = isDebug ? 40 * 4 : 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                const { camera } = WorldController;

                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.stars = new InfiniteStars(camera, 1000, 40, isDebug ? 0.4 * 16 : 0.4);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera, this.stars);
            }

            static initPanel() {
                PanelController.init(this.stars, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                this.stars.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_input_manager.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Input Manager — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, LinearSRGBColorSpace, LuminosityMaterial, MapControls, MathUtils, Mesh, MeshStandardMaterial, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, Raycaster, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class AbstractCube extends Group {
            constructor() {
                super();

                this.position.x = 2.5;
            }

            async initMesh() {
                const geometry = new BoxGeometry();

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 0.7,
                    flatShading: true
                });

                const mesh = new Mesh(geometry, material);
                mesh.rotation.x = MathUtils.degToRad(-45);
                mesh.rotation.z = MathUtils.degToRad(-45);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Event handlers

            onHover = ({ type }) => {
                console.log('AbstractCube', type);
                // if (type === 'over') {
                // } else {
                // }
            };

            onClick = () => {
                console.log('AbstractCube', 'click');
                // open('https://alien.js.org/');
            };

            // Public methods

            update = () => {
                this.mesh.rotation.y -= 0.005;
            };

            ready = () => this.initMesh();
        }

        class FloatingCrystal extends Group {
            constructor() {
                super();

                this.position.y = 0.7;
            }

            async initMesh() {
                const geometry = new OctahedronGeometry();

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 0.7,
                    flatShading: true
                });

                const mesh = new Mesh(geometry, material);
                mesh.scale.set(0.5, 1, 0.5);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Event handlers

            onHover = ({ type }) => {
                console.log('FloatingCrystal', type);
                // if (type === 'over') {
                // } else {
                // }
            };

            onClick = () => {
                console.log('FloatingCrystal', 'click');
                // open('https://alien.js.org/');
            };

            // Public methods

            update = time => {
                this.mesh.position.y = Math.sin(time) * 0.1;
                this.mesh.rotation.y += 0.01;
            };

            ready = () => this.initMesh();
        }

        class DarkPlanet extends Group {
            constructor() {
                super();

                this.position.x = -2.5;

                // 25 degree tilt like Mars
                this.rotation.z = MathUtils.degToRad(25);
            }

            async initMesh() {
                const geometry = new IcosahedronGeometry(0.6, 12);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 1
                });

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Event handlers

            onHover = ({ type }) => {
                console.log('DarkPlanet', type);
                // if (type === 'over') {
                // } else {
                // }
            };

            onClick = () => {
                console.log('DarkPlanet', 'click');
                // open('https://alien.js.org/');
            };

            // Public methods

            update = () => {
                // Counter clockwise rotation
                this.mesh.rotation.y += 0.005;
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.darkPlanet = new DarkPlanet();
                this.add(this.darkPlanet);

                this.floatingCrystal = new FloatingCrystal();
                this.add(this.floatingCrystal);

                this.abstractCube = new AbstractCube();
                this.add(this.abstractCube);
            }

            addListeners() {
                InputManager.add(this.darkPlanet, this.floatingCrystal, this.abstractCube);
            }

            removeListeners() {
                InputManager.remove(this.darkPlanet, this.floatingCrystal, this.abstractCube);
            }

            // Public methods

            update = time => {
                this.darkPlanet.update(time);
                this.floatingCrystal.update(time);
                this.abstractCube.update(time);
            };

            animateIn = () => {
                this.addListeners();
            };

            ready = () => Promise.all([
                this.darkPlanet.ready(),
                this.floatingCrystal.ready(),
                this.abstractCube.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static update = time => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update(time);
            };

            static animateIn = () => {
                this.view.animateIn();

                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class InputManager {
            static init(camera) {
                this.camera = camera;

                this.raycaster = new Raycaster();

                this.objects = [];
                this.mouse = new Vector2(-1, -1);
                this.delta = new Vector2();
                this.coords = new Vector2(-2, 2);
                this.hover = null;
                this.click = null;
                this.lastTime = 0;
                this.lastMouse = new Vector2();
                this.raycastInterval = 1 / 10; // 10 frames per second
                this.lastRaycast = 0;
                this.enabled = true;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointerdown', this.onPointerDown);
                window.addEventListener('pointermove', this.onPointerMove);
                window.addEventListener('pointerup', this.onPointerUp);
            }

            static removeListeners() {
                window.removeEventListener('pointerdown', this.onPointerDown);
                window.removeEventListener('pointermove', this.onPointerMove);
                window.removeEventListener('pointerup', this.onPointerUp);
            }

            // Event handlers

            static onPointerDown = e => {
                if (!this.enabled) {
                    return;
                }

                this.lastTime = performance.now();
                this.lastMouse.set(e.clientX, e.clientY);

                this.onPointerMove(e);

                if (this.hover) {
                    this.click = this.hover;
                }
            };

            static onPointerMove = e => {
                if (!this.enabled) {
                    return;
                }

                if (e) {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                    this.coords.x = (this.mouse.x / document.documentElement.clientWidth) * 2 - 1;
                    this.coords.y = 1 - (this.mouse.y / document.documentElement.clientHeight) * 2;
                }

                this.raycaster.setFromCamera(this.coords, this.camera);

                const intersection = this.raycaster.intersectObjects(this.objects);

                if (intersection.length) {
                    let object = intersection[0].object;

                    if (object.parent.isGroup) {
                        object = object.parent;
                    }

                    if (!this.hover) {
                        this.hover = object;
                        this.hover.onHover({ type: 'over' });
                        document.body.style.cursor = 'pointer';
                    } else if (this.hover !== object) {
                        this.hover.onHover({ type: 'out' });
                        this.hover = object;
                        this.hover.onHover({ type: 'over' });
                        document.body.style.cursor = 'pointer';
                    }
                } else if (this.hover) {
                    this.hover.onHover({ type: 'out' });
                    this.hover = null;
                    document.body.style.cursor = '';
                }

                this.delta.subVectors(this.mouse, this.lastMouse);
            };

            static onPointerUp = () => {
                if (!this.enabled) {
                    return;
                }

                if (performance.now() - this.lastTime > 250 || this.delta.length() > 50) {
                    this.click = null;
                    return;
                }

                if (this.click && this.click === this.hover) {
                    this.click.onClick();
                }

                this.click = null;
            };

            // Public methods

            static update = time => {
                if (!navigator.maxTouchPoints && time - this.lastRaycast > this.raycastInterval) {
                    this.onPointerMove();
                    this.lastRaycast = time;
                }
            };

            static add = (...objects) => {
                this.objects.push(...objects);
            };

            static remove = (...objects) => {
                objects.forEach(object => {
                    const index = this.objects.indexOf(object);

                    if (~index) {
                        this.objects.splice(index, 1);
                    }

                    if (object.parent.isGroup) {
                        object = object.parent;
                    }

                    if (object === this.hover) {
                        this.hover.onHover({ type: 'out' });
                        this.hover = null;
                        document.body.style.cursor = '';
                    }
                });
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.set(0, 6, 8);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initControls() {
                this.controls = new MapControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                InputManager.init(camera);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update(time);
                InputManager.update(time);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_panel_tracking.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Panel Tracking — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BasicShadowMap, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, LinearSRGBColorSpace, LuminosityMaterial, MapControls, MathUtils, Mesh, MeshStandardMaterial, OctahedronGeometry, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Point3D, Reflector, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, ShadowMaterial, StandardMaterialPanel, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        class AbstractCube extends Group {
            constructor() {
                super();

                this.position.x = 2.5;
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new BoxGeometry();

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                normalMap.anisotropy = anisotropy;
                ormMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    name: 'Abstract Cube',
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 0.7,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1),
                    flatShading: true,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.rotation.x = MathUtils.degToRad(-45);
                mesh.rotation.z = MathUtils.degToRad(-45);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = () => {
                this.mesh.rotation.y -= 0.005;
            };

            ready = () => this.initMesh();
        }

        class FloatingCrystal extends Group {
            constructor() {
                super();

                this.position.y = 0.7;
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new OctahedronGeometry();

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 2);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 2);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 2);

                const material = new MeshStandardMaterial({
                    name: 'Floating Crystal',
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 0.7,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1),
                    flatShading: true,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.scale.set(0.5, 1, 0.5);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = time => {
                this.mesh.position.y = Math.sin(time) * 0.1;
                this.mesh.rotation.y += 0.01;
            };

            ready = () => this.initMesh();
        }

        class DarkPlanet extends Group {
            constructor() {
                super();

                this.position.x = -2.5;

                // 25 degree tilt like Mars
                this.rotation.z = MathUtils.degToRad(25);
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.6, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    name: 'Dark Planet',
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3),
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = () => {
                // Counter clockwise rotation
                this.mesh.rotation.y += 0.005;
            };

            ready = () => this.initMesh();
        }

        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector({ blurIterations: 6 });
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 3);

                const material = new ShadowMaterial({
                    toneMapped: false
                });

                material.onBeforeCompile = shader => {
                    map.updateMatrix();

                    shader.uniforms.map = { value: map };
                    shader.uniforms.reflectMap = { value: this.reflector.renderTarget.texture };
                    shader.uniforms.reflectMapBlur = this.reflector.renderTargetUniform;
                    shader.uniforms.uvTransform = { value: map.matrix };
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat3 uvTransform;
                        uniform mat4 textureMatrix;

                        out vec2 vUv;
                        out vec4 vCoord;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vUv = (uvTransform * vec3(uv, 1)).xy;
                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D map;
                        uniform sampler2D reflectMap;
                        uniform sampler2D reflectMapBlur;

                        in vec2 vUv;
                        in vec4 vCoord;

                        ${dither}

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );',
                        /* glsl */ `
                        vec2 reflectionUv = vCoord.xy / vCoord.w;

                        vec4 dudv = texture(map, vUv);
                        vec4 color = texture(reflectMap, reflectionUv);

                        vec4 blur;

                        blur = texture(reflectMapBlur, reflectionUv + dudv.rg / 256.0);
                        color = mix(color, blur, smoothstep(1.0, 0.1, dudv.g));

                        blur = texture(reflectMapBlur, reflectionUv);
                        color = mix(color, blur, smoothstep(0.5, 1.0, dudv.r));

                        gl_FragColor = color * mix(0.3, 0.55, dudv.g);

                        gl_FragColor.rgb -= (1.0 - getShadowMask()) * 0.025;

                        gl_FragColor.rgb = dither(gl_FragColor.rgb);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -0.86;
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.darkPlanet = new DarkPlanet();
                this.add(this.darkPlanet);

                this.floatingCrystal = new FloatingCrystal();
                this.add(this.floatingCrystal);

                this.abstractCube = new AbstractCube();
                this.add(this.abstractCube);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            update = time => {
                this.darkPlanet.update(time);
                this.floatingCrystal.update(time);
                this.abstractCube.update(time);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.darkPlanet.ready(),
                this.floatingCrystal.ready(),
                this.abstractCube.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = time => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update(time);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class ScenePanelController {
            static init(view) {
                this.view = view;

                this.initPanel();
            }

            static initPanel() {
                const { darkPlanet, floatingCrystal, abstractCube } = this.view;

                const objects = [darkPlanet, floatingCrystal, abstractCube];

                objects.forEach(object => {
                    object.point = new Point3D(object.mesh);
                    object.add(object.point);

                    const items = [
                        {
                            type: 'content',
                            callback: (value, item) => {
                                const materialPanel = new StandardMaterialPanel(object.mesh);
                                materialPanel.animateIn(true);

                                item.setContent(materialPanel);
                            }
                        }
                    ];

                    items.forEach(data => {
                        object.point.addPanel(new PanelItem(data));
                    });
                });

                // Shrink tracker mesh to better match the visual size of the object
                floatingCrystal.point.mesh.scale.multiply(new Vector3(0.6, 1, 0.6));
                abstractCube.point.mesh.scale.multiplyScalar(0.9);
            }
        }

        class PanelController {
            static init(renderer, scene, camera, view, ui) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;
                this.ui = ui;

                this.initControllers();
                this.initPanel();
            }

            static initControllers() {
                Point3D.init(this.renderer, this.scene, this.camera, {
                    container: this.ui,
                    debug: isDebug
                });

                ScenePanelController.init(this.view);
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }

            // Public methods

            static update = time => {
                if (!this.ui) {
                    return;
                }

                Point3D.update(time);
            };
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // Shadows
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = BasicShadowMap;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.set(0, 6, 8);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                light.castShadow = true;
                light.shadow.mapSize.width = 2048;
                light.shadow.mapSize.height = 2048;
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
                this.textureLoader.setOptions({
                    preserveData: true
                });
                this.textureLoader.cache = true;

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initControls() {
                this.controls = new MapControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { renderer, scene, camera } = WorldController;

                PanelController.init(renderer, scene, camera, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update(time);
                RenderManager.update(time, delta, frame);
                PanelController.update(time);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_penrose_triangle.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Penrose Triangle — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BoxGeometry, BufferGeometry, Color, ColorManagement, DirectionalLight, Float32BufferAttribute, Group, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PlaneGeometry, Scene, SceneCompositeDistortionMaterial, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        const breakpoint = 1000;

        // Based on https://codepen.io/zachgoldstein/pen/LXRXVw

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const material = new MeshStandardMaterial({ metalness: 1 });

                // Penrose triangle geometry
                const bottomBox = new BoxGeometry(50, 50, 300);
                const bottomMesh = new Mesh(bottomBox, material);
                this.add(bottomMesh);

                const upBox = new BoxGeometry(50, 250, 50);
                const upMesh = new Mesh(upBox, material);
                upMesh.position.set(0, 150, 125);
                this.add(upMesh);

                const topBox = new BoxGeometry(150, 50, 50);
                const topMesh = new Mesh(topBox, material);
                topMesh.position.set(100, 250, 125);
                this.add(topMesh);

                const topPlane = new PlaneGeometry(50, 50);
                const topPlaneMesh = new Mesh(topPlane, material);
                topPlaneMesh.position.set(200, 275, 125);
                topPlaneMesh.rotation.x = MathUtils.degToRad(-90);
                this.add(topPlaneMesh);

                const topTri = new BufferGeometry();
                topTri.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 50, 0, 0, 0, 50, 0], 3));
                topTri.setAttribute('uv', new Float32BufferAttribute([0, 0, 1, 0, 0, 1], 2));
                topTri.computeVertexNormals();
                const topTriMesh = new Mesh(topTri, material);
                topTriMesh.position.set(175, 275, 150);
                topTriMesh.scale.y = -1;
                this.add(topTriMesh);

                // Centre
                this.position.y = -62.5;
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // Isometric scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new OrthographicCamera();
                this.camera.near = 0;
                this.camera.far = 3000;
                this.camera.zoom = 1;
                this.camera.position.set(500, 500, 500);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                const light = new DirectionalLight(0xffffff, 7);
                light.position.set(60, 100, 20);
                this.scene.add(light);
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.left = -width / 2;
                this.camera.right = width / 2;
                this.camera.top = height / 2;
                this.camera.bottom = -height / 2;

                if (width < breakpoint) {
                    this.camera.zoom = 0.8;
                } else {
                    this.camera.zoom = 1;
                }

                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_physics_gravity_balls_thread.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Physics Gravity Balls — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BlurMaterial, Color, ColorManagement, CopyMaterial, DepthMaterial, DirectionalLight, DisplayOptions, DrawBuffers, DynamicDrawUsage, EnvironmentTextureLoader, EventEmitter, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, InstancedMesh, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Matrix4, Mesh, MeshBasicMaterial, MeshMatcapMaterial, MeshStandardMaterial, MotionBlurCompositeMaterial, NoBlending, NormalMaterial, OimoPhysicsBuffer, OimoPhysicsController, OrthographicCamera, Panel, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, RawShaderMaterial, RepeatWrapping, Scene, ShaderChunk, TextureLoader, Thread, UI, UnrealBloomBlurMaterial, Vector2, Vector3, VolumetricLightLensflareMaterial, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, getViewSize, headsTails, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const count = parseInt(location.search.slice(1), 10) || 100;

        const layers = {
            default: 0,
            buffers: 1,
            occlusion: 2
        };

        const colors = {
            lightColor: 0xf44336
        };

        // Based on https://threejs.org/examples/#webgl_multiple_rendertargets by takahirox
        // Based on https://oframe.github.io/ogl/examples/?src=mrt.html by gordonnl
        // Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/motionBlurPass
        // Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/shader-replacement

        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tColor: { value: null },
                        tNormal: { value: null },
                        tPosition: { value: null },
                        tVelocity: { value: null },
                        tScene: { value: null },
                        tBloom: { value: null },
                        tAdd: { value: null },
                        uDebug: { value: isDebug },
                        uAspect: { value: 1 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tColor;
                        uniform sampler2D tNormal;
                        uniform sampler2D tPosition;
                        uniform sampler2D tVelocity;
                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform sampler2D tAdd;
                        uniform bool uDebug;
                        uniform float uAspect;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${dither}

                        void main() {
                            // Extract data from render targets
                            vec3 color = texture(tColor, vUv).rgb;
                            vec3 normal = texture(tNormal, vUv).rgb;
                            vec4 pos = texture(tPosition, vUv);
                            vec2 vel = texture(tVelocity, vUv).xy;
                            float depth = pos.a;

                            FragColor = texture(tScene, vUv);

                            FragColor.rgb += texture(tBloom, vUv).rgb;

                            FragColor.rgb += texture(tAdd, vUv).rgb;

                            FragColor.rgb = dither(FragColor.rgb);
                            FragColor.a = 1.0;

                            if (uDebug) {
                                // Render raw render targets in corner
                                vec2 uv = gl_FragCoord.xy / vec2(250.0 * uAspect, 250.0);
                                if (uv.y < 1.0 && uv.x < 1.0) {
                                    FragColor.rgb = vec3(texture(tPosition, mod(uv, 1.0)).a);
                                } else if (uv.y < 2.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tVelocity, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 3.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tPosition, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 4.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tScene, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 5.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tBloom, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 6.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tAdd, mod(uv, 1.0)).rgb;
                                }
                            }
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class ScenePhysics extends EventEmitter {
            constructor(shapes) {
                super();

                this.shapes = shapes;

                this.initPhysics();
            }

            initPhysics() {
                this.physics = new OimoPhysicsBuffer({
                    gravity: new Vector3(0, 0, 0)
                });

                this.shapes.forEach(shape => this.physics.add(shape));

                this.physics.add({
                    name: 'mouse',
                    kinematic: true
                });

                this.physics.add({
                    name: 'mouseJoint',
                    type: 'joint',
                    mode: 'universal',
                    body1: 'sphere',
                    body2: 'mouse'
                });
            }

            // Public methods

            step = () => {
                this.physics.step();

                this.emit('buffer', { array: this.physics.array, buffer: [this.physics.array.buffer] });
            };

            update = array => {
                this.physics.array = array;

                this.step();
            };

            add = object => {
                this.physics.add(object);
            };

            remove = name => {
                this.physics.remove(name);
            };

            setGravity = gravity => {
                this.physics.setGravity(gravity);
            };

            setPosition = (name, position) => {
                this.physics.setPosition(name, position);
            };

            setOrientation = (name, orientation) => {
                this.physics.setOrientation(name, orientation);
            };

            setLinearVelocity = (name, linearVelocity) => {
                this.physics.setLinearVelocity(name, linearVelocity);
            };

            setAngularVelocity = (name, angularVelocity) => {
                this.physics.setAngularVelocity(name, angularVelocity);
            };

            applyImpulse = (name, impulse, positionInWorld) => {
                this.physics.applyImpulse(name, impulse, positionInWorld);
            };
        }

        class ScenePhysicsThread {
            constructor() {
                this.startTime = performance.now();

                this.addListeners();
            }

            addListeners() {
                addEventListener('message', this.onMessage);
            }

            // Event handlers

            onMessage = ({ data }) => {
                this[data.message.fn].call(this, data.message);
            };

            onBuffer = ({ array, buffer }) => {
                postMessage({ event: 'buffer', message: { array } }, buffer);
            };

            // Public methods

            init = ({ shapes }) => {
                this.physics = new ScenePhysics(shapes);
                this.physics.on('buffer', this.onBuffer);

                this.physics.step();

                postMessage({ event: 'ready' });
            };

            update = ({ array }) => {
                this.physics.update(array);

                ticker.onTick(performance.now() - this.startTime);
            };

            add = ({ object }) => {
                this.physics.add(object);
            };

            remove = ({ name }) => {
                this.physics.remove(name);
            };

            setGravity = ({ gravity }) => {
                this.physics.setGravity(gravity);
            };

            setPosition = ({ name, position }) => {
                this.physics.setPosition(name, position);
            };

            setOrientation = ({ name, orientation }) => {
                this.physics.setOrientation(name, orientation);
            };

            setLinearVelocity = ({ name, linearVelocity }) => {
                this.physics.setLinearVelocity(name, linearVelocity);
            };

            setAngularVelocity = ({ name, angularVelocity }) => {
                this.physics.setAngularVelocity(name, angularVelocity);
            };

            applyImpulse = ({ name, impulse, positionInWorld }) => {
                this.physics.applyImpulse(name, impulse, positionInWorld);
            };
        }

        class ScenePhysicsController extends OimoPhysicsController {
            constructor() {
                super();

                this.buffer = [];
            }

            init() {
                this.initEngine();

                this.addListeners();
            }

            initEngine() {
                this.thread = new Thread({
                    imports: [
                        ['../../build/alien.three.js', 'EventEmitter', 'OimoPhysicsBuffer', 'RigidBodyType', 'Vector3', 'delayedCall', 'ticker']
                    ],
                    classes: [ScenePhysics],
                    controller: [ScenePhysicsThread, 'void init', 'void update', 'void add', 'void remove', 'void setGravity', 'void setPosition', 'void setOrientation', 'void setLinearVelocity', 'void setAngularVelocity', 'void applyImpulse']
                });

                this.thread.init({ shapes: this.shapes });
            }

            addListeners() {
                this.thread.on('buffer', this.onBuffer);
            }

            // Event handlers

            onBuffer = ({ array }) => {
                this.buffer.push(array);
            };

            // Public methods

            update = () => {
                const array = this.buffer.shift();

                if (array) {
                    this.step(array);

                    this.thread.update({ array, buffer: [array.buffer] });
                }
            };

            addJoint = object => {
                this.thread.add({ object });
            };

            remove = name => {
                this.thread.remove({ name });
            };

            setGravity = gravity => {
                this.thread.setGravity({ gravity });
            };

            setPosition = (name, position) => {
                this.thread.setPosition({ name, position });
            };

            setOrientation = (name, orientation) => {
                this.thread.setOrientation({ name, orientation });
            };

            setLinearVelocity = (object, linearVelocity, index) => {
                const { name } = this.getObjectBody(object, index);

                this.thread.setLinearVelocity({ name, linearVelocity });
            };

            setAngularVelocity = (object, angularVelocity, index) => {
                const { name } = this.getObjectBody(object, index);

                this.thread.setAngularVelocity({ name, angularVelocity });
            };

            applyImpulse = (object, impulse, positionInWorld, index) => {
                const { name } = this.getObjectBody(object, index);

                this.thread.applyImpulse({ name, impulse, positionInWorld });
            };

            ready = () => this.init();
        }

        // https://adinunz.io/translucentPearls/

        // Based on http://lo-th.github.io/Oimo.js/#planet

        class Balls extends Group {
            constructor() {
                super();

                // Physics
                this.name = 'balls';
                this.autoSleep = false;
            }

            async initMesh() {
                const { physics, anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(1, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu
                // Based on https://gist.github.com/mattdesl/2ee82157a86962347dedb6572142df7c

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.05 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 0.8 },
                    thicknessPower: { value: 2 },
                    thicknessScale: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).r;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += material.diffuseColor * directLight.color * scatteringIllu * thicknessAttenuation;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new InstancedMesh(geometry, material, count);
                mesh.instanceMatrix.setUsage(DynamicDrawUsage); // Will be updated every frame
                mesh.layers.enable(layers.buffers);
                this.add(mesh);

                const object = new Group();

                for (let i = 0; i < mesh.count; i++) {
                    object.position.x = MathUtils.randFloat(10, 100) * (headsTails() ? -1 : 1);
                    object.position.y = MathUtils.randFloat(10, 100) * (headsTails() ? -1 : 1);
                    object.position.z = MathUtils.randFloat(10, 100) * (headsTails() ? -1 : 1);

                    object.rotation.x = MathUtils.degToRad(MathUtils.randInt(0, 360));
                    object.rotation.y = MathUtils.degToRad(MathUtils.randInt(0, 360));
                    object.rotation.z = MathUtils.degToRad(MathUtils.randInt(0, 360));

                    object.updateMatrix();

                    mesh.setMatrixAt(i, object.matrix);
                }

                mesh.computeBoundingSphere();

                // Physics
                physics.add(mesh);

                this.uniforms = uniforms;
                this.mesh = mesh;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class Sphere extends Group {
            constructor() {
                super();

                // Physics
                this.name = 'sphere';
                this.autoSleep = false;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 1.9, 4.4, 0);
                this.add(light);
            }

            async initMesh() {
                const { physics, anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(1, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(colors.lightColor),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.2 };
                    shader.uniforms.thicknessPower = { value: 2 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.layers.enable(layers.buffers);
                this.add(mesh);

                // Occlusion mesh
                const occMesh = mesh.clone();
                occMesh.material = new MeshBasicMaterial({ color: colors.lightColor });
                occMesh.layers.set(layers.occlusion);
                this.add(occMesh);

                // Physics
                physics.add(mesh);
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.sphere = new Sphere();
                this.add(this.sphere);

                this.balls = new Balls();
                this.add(this.balls);
            }

            // Public methods

            ready = () => Promise.all([
                this.sphere.ready(),
                this.balls.ready()
            ]);
        }

        class SceneController {
            static init(physics, view) {
                this.physics = physics;
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.lightPosition = new Vector3();

                // Physics
                this.force = new Vector3();
                this.center = new Vector3(0, 0, 0);
                this.object = new Group();
                this.matrix = new Matrix4();

                this.enabled = true;
                this.animatedOneFramePast = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = () => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.sphere.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                if (this.enabled || !this.animatedOneFramePast) {
                    // Mouse light
                    this.lightPosition.x = this.mouse.x * this.halfWidth;
                    this.lightPosition.y = this.mouse.y * this.halfHeight;
                    this.lightPosition.z = this.view.sphere.position.z;

                    this.physics.setPosition('mouse', this.lightPosition.toArray());

                    // Physics
                    for (let i = 0; i < this.view.balls.mesh.count; i++) {
                        const { position, quaternion, scale } = this.object;

                        this.view.balls.mesh.getMatrixAt(i, this.matrix);
                        this.matrix.decompose(position, quaternion, scale);

                        this.force.copy(position).negate().normalize().multiplyScalar(0.1);
                        this.physics.applyImpulse(this.view.balls.mesh, this.force.toArray(), this.center.toArray(), i);
                    }

                    this.physics.update();

                    this.animatedOneFramePast = !this.enabled;
                }
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = async () => {
                await this.view.ready();
                await this.physics.ready();
            };
        }

        class PanelController {
            static init(physics, view, ui) {
                this.physics = physics;
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { drawBuffers, vlMaterial, luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const physics = this.physics;
                const { balls } = this.view;

                const gravity = new Vector3(0, 0, 0);

                const physicsOptions = {
                    Off: false,
                    Physics: true
                };

                const defaultOptions = {
                    Off: false,
                    Targets: true
                };

                const defaultItems = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: defaultOptions,
                        value: getKeyByValue(defaultOptions, compositeMaterial.uniforms.uDebug.value),
                        callback: value => {
                            compositeMaterial.uniforms.uDebug.value = defaultOptions[value];
                        }
                    }
                ];

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: DisplayOptions,
                        value: getKeyByValue(DisplayOptions, RenderManager.display),
                        callback: (value, item) => {
                            if (!item.hasContent()) {
                                const defaultPanel = new Panel();
                                defaultPanel.animateIn(true);

                                defaultItems.forEach(data => {
                                    defaultPanel.add(new PanelItem(data));
                                });

                                item.setContent(defaultPanel);
                            }

                            RenderManager.display = DisplayOptions[value];

                            if (RenderManager.display === DisplayOptions.Default) {
                                item.toggleContent(true);
                            } else {
                                item.toggleContent(false);
                            }
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: physicsOptions,
                        value: getKeyByValue(physicsOptions, SceneController.enabled),
                        callback: value => {
                            SceneController.enabled = physicsOptions[value];
                            drawBuffers.saveState = SceneController.enabled;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Gravity',
                        min: -10,
                        max: 10,
                        step: 0.1,
                        value: -gravity.y,
                        callback: value => {
                            gravity.y = -value;
                            physics.setGravity(gravity.toArray());
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Interp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: drawBuffers.interpolateGeometry,
                        callback: value => {
                            drawBuffers.interpolateGeometry = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smear',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: drawBuffers.smearIntensity,
                        callback: value => {
                            drawBuffers.smearIntensity = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Decay',
                        min: 0.6,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDecay.value,
                        callback: value => {
                            vlMaterial.uniforms.uDecay.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDensity.value,
                        callback: value => {
                            vlMaterial.uniforms.uDensity.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Weight',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uWeight.value,
                        callback: value => {
                            vlMaterial.uniforms.uWeight.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Scale X',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: vlMaterial.uniforms.uLensflareScale.value.x,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareScale.value.x = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale Y',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: vlMaterial.uniforms.uLensflareScale.value.y,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareScale.value.y = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uLensflareExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uLensflareClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: balls.uniforms.thicknessDistortion.value,
                        callback: value => {
                            balls.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: balls.uniforms.thicknessAmbient.value,
                        callback: value => {
                            balls.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: balls.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            balls.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: balls.uniforms.thicknessPower.value,
                        callback: value => {
                            balls.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: balls.uniforms.thicknessScale.value,
                        callback: value => {
                            balls.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, view) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;

                // Volumetric light and lens flare
                this.lightPosition = new Vector3();
                this.vlExposure = 0.1;
                this.vlDecay = 1;
                this.vlDensity = 1;
                this.vlWeight = 0.4;
                this.vlClamp = 1;
                this.lensflareScale = new Vector2(2.5, 2.5);
                this.lensflareExposure = 0.02;
                this.lensflareClamp = 1;
                this.blurResolutionScale = 0.25;
                this.blurAmount = 2.5;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                // Debug
                DisplayOptions.Light = 8;
                this.display = DisplayOptions.Default;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution, aspect, textureLoader, getTexture } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Clear colors
                this.clearColor = new Color(0, 0, 0);
                this.currentClearColor = new Color();

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBlurA = this.renderTargetA.clone();
                this.renderTargetBlurB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetBlurA.depthBuffer = true;

                // G-Buffer
                this.drawBuffers = new DrawBuffers(this.renderer, this.scene, this.camera, layers.buffers, {
                    cameraBlur: false
                });

                // Motion blur composite material
                this.motionBlurCompositeMaterial = new MotionBlurCompositeMaterial(textureLoader, {
                    blueNoisePath: 'blue_noise.png'
                });
                this.motionBlurCompositeMaterial.uniforms.tVelocity.value = this.drawBuffers.renderTarget.textures[1];

                // Occlusion material
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Volumetric light material
                this.vlMaterial = new VolumetricLightLensflareMaterial();
                this.vlMaterial.uniforms.uExposure.value = this.vlExposure;
                this.vlMaterial.uniforms.uDecay.value = this.vlDecay;
                this.vlMaterial.uniforms.uDensity.value = this.vlDensity;
                this.vlMaterial.uniforms.uWeight.value = this.vlWeight;
                this.vlMaterial.uniforms.uClamp.value = this.vlClamp;
                this.vlMaterial.uniforms.uLensflareScale.value = this.lensflareScale;
                this.vlMaterial.uniforms.uLensflareExposure.value = this.lensflareExposure;
                this.vlMaterial.uniforms.uLensflareClamp.value = this.lensflareClamp;
                this.vlMaterial.uniforms.uResolution = resolution;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.uAspect = aspect;

                // Debug materials
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });
                this.matcap1Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/040full.jpg') });
                this.matcap2Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/defaultwax.jpg') });
                this.normalMaterial = new NormalMaterial();
                this.normalMaterialInstanced = new NormalMaterial({ instancing: true });
                this.depthMaterial = new DepthMaterial();
                this.depthMaterialInstanced = new DepthMaterial({ instancing: true });
                this.copyMaterial = new CopyMaterial();

                // Based on https://github.com/mrdoob/three.js/issues/26732#issuecomment-1741276120 by donmccurdy
                this.originalMaterials = new Map();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static setLightPosition() {
                this.lightPosition.copy(this.view.sphere.position).project(this.camera);

                const x = (this.lightPosition.x + 1) / 2;
                const y = (this.lightPosition.y + 1) / 2;

                this.vlMaterial.uniforms.uLightPosition.value.set(x, y);
            }

            static rendererState() {
                this.currentOverrideMaterial = this.scene.overrideMaterial;
                this.currentBackground = this.scene.background;
                this.renderer.getClearColor(this.currentClearColor);
                this.currentClearAlpha = this.renderer.getClearAlpha();
            }

            static restoreRendererState() {
                this.scene.overrideMaterial = this.currentOverrideMaterial;
                this.scene.background = this.currentBackground;
                this.renderer.setClearColor(this.currentClearColor, this.currentClearAlpha);

                // Restore original materials
                for (const [object, material] of this.originalMaterials.entries()) {
                    object.material = material;
                }
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                this.drawBuffers.setSize(width, height);

                // Gaussian blur
                const blurWidth = Math.round(width * this.blurResolutionScale);
                const blurHeight = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(blurWidth, blurHeight);
                this.renderTargetBlurB.setSize(blurWidth, blurHeight);

                this.hBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);
                this.vBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Renderer state
                this.rendererState();

                // G-Buffer layer
                camera.layers.set(layers.buffers);

                this.drawBuffers.update();

                if (this.display === DisplayOptions.Velocity) {
                    // Debug pass (render to screen)
                    this.copyMaterial.uniforms.tMap.value = this.drawBuffers.renderTarget.textures[1];
                    this.screen.material = this.copyMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                }

                // Scene layer
                camera.layers.set(layers.default);

                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Occlusion layer
                scene.background = null;

                scene.overrideMaterial = this.blackoutMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = this.currentOverrideMaterial;

                camera.layers.set(layers.occlusion);

                renderer.render(scene, camera);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Volumetric light pass
                this.vlMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.setLightPosition();
                this.screen.material = this.vlMaterial;

                if (this.display === DisplayOptions.Light) {
                    // Debug pass (render to screen)
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                } else {
                    renderer.setRenderTarget(renderTargetBlurB);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Post-processing
                camera.layers.set(layers.default);

                renderer.setClearColor(this.clearColor, 1);

                // Debug override material passes (render to screen)
                if (this.display === DisplayOptions.Depth) {
                    scene.traverseVisible(object => {
                        if (object.material) {
                            this.originalMaterials.set(object, object.material);

                            if (object.isInstancedMesh) {
                                object.material = this.depthMaterialInstanced;
                            } else {
                                object.material = this.depthMaterial;
                            }
                        }
                    });

                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);

                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Geometry) {
                    scene.traverseVisible(object => {
                        if (object.material) {
                            this.originalMaterials.set(object, object.material);

                            if (object.isInstancedMesh) {
                                object.material = this.normalMaterialInstanced;
                            } else {
                                object.material = this.normalMaterial;
                            }
                        }
                    });

                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);

                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Matcap1) {
                    scene.overrideMaterial = this.matcap1Material;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Matcap2) {
                    scene.overrideMaterial = this.matcap2Material;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                }

                // Motion blur pass
                this.motionBlurCompositeMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.motionBlurCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;

                if (this.display === DisplayOptions.Luma) {
                    // Debug pass (render to screen)
                    this.screen.material = this.blackoutMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.screen.material = this.luminosityMaterial;
                    this.screen.material.blending = AdditiveBlending;
                    renderer.render(this.screen, this.screenCamera);
                    this.screen.material.blending = NoBlending;
                    this.restoreRendererState();
                    return;
                } else {
                    this.screen.material = this.luminosityMaterial;
                    renderer.setRenderTarget(renderTargetBright);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;

                if (this.display === DisplayOptions.Bloom) {
                    // Debug pass (render to screen)
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                } else {
                    renderer.setRenderTarget(renderTargetsHorizontal[0]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tPosition.value = this.drawBuffers.renderTarget.textures[0];
                this.compositeMaterial.uniforms.tVelocity.value = this.drawBuffers.renderTarget.textures[1];
                this.compositeMaterial.uniforms.tScene.value = renderTargetB.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.compositeMaterial.uniforms.tAdd.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Restore renderer settings
                this.restoreRendererState();
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.targetXY.x = 1;
                } else {
                    this.targetXY.x = 2;
                }
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initPhysics();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(35);
                this.camera.near = 1;
                this.camera.far = 3000;
                this.camera.position.z = 40;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.quad = new PlaneGeometry(1, 1);
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initPhysics() {
                this.physics = new ScenePhysicsController();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();

                Thread.count--; // Make room for the physics thread
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera, physics } = WorldController;

                CameraController.init(camera);
                SceneController.init(physics, this.view);
                RenderManager.init(renderer, scene, camera, this.view);
            }

            static initPanel() {
                const { physics } = WorldController;

                PanelController.init(physics, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_physics_gravity_balls.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Physics Gravity Balls — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BlurMaterial, Color, ColorManagement, CopyMaterial, DepthMaterial, DirectionalLight, DisplayOptions, DrawBuffers, DynamicDrawUsage, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, InstancedMesh, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Matrix4, Mesh, MeshBasicMaterial, MeshMatcapMaterial, MeshStandardMaterial, MotionBlurCompositeMaterial, NoBlending, NormalMaterial, OimoPhysics, OrthographicCamera, Panel, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, RawShaderMaterial, RepeatWrapping, RigidBodyConfig, RigidBodyType, Scene, ShaderChunk, TextureLoader, UI, UniversalJointConfig, UnrealBloomBlurMaterial, Vector2, Vector3, VolumetricLightLensflareMaterial, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, getViewSize, headsTails, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const count = parseInt(location.search.slice(1), 10) || 100;

        const layers = {
            default: 0,
            buffers: 1,
            occlusion: 2
        };

        const colors = {
            lightColor: 0xf44336
        };

        // Based on https://threejs.org/examples/#webgl_multiple_rendertargets by takahirox
        // Based on https://oframe.github.io/ogl/examples/?src=mrt.html by gordonnl
        // Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/motionBlurPass
        // Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/shader-replacement

        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tColor: { value: null },
                        tNormal: { value: null },
                        tPosition: { value: null },
                        tVelocity: { value: null },
                        tScene: { value: null },
                        tBloom: { value: null },
                        tAdd: { value: null },
                        uDebug: { value: isDebug },
                        uAspect: { value: 1 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tColor;
                        uniform sampler2D tNormal;
                        uniform sampler2D tPosition;
                        uniform sampler2D tVelocity;
                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform sampler2D tAdd;
                        uniform bool uDebug;
                        uniform float uAspect;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${dither}

                        void main() {
                            // Extract data from render targets
                            vec3 color = texture(tColor, vUv).rgb;
                            vec3 normal = texture(tNormal, vUv).rgb;
                            vec4 pos = texture(tPosition, vUv);
                            vec2 vel = texture(tVelocity, vUv).xy;
                            float depth = pos.a;

                            FragColor = texture(tScene, vUv);

                            FragColor.rgb += texture(tBloom, vUv).rgb;

                            FragColor.rgb += texture(tAdd, vUv).rgb;

                            FragColor.rgb = dither(FragColor.rgb);
                            FragColor.a = 1.0;

                            if (uDebug) {
                                // Render raw render targets in corner
                                vec2 uv = gl_FragCoord.xy / vec2(250.0 * uAspect, 250.0);
                                if (uv.y < 1.0 && uv.x < 1.0) {
                                    FragColor.rgb = vec3(texture(tPosition, mod(uv, 1.0)).a);
                                } else if (uv.y < 2.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tVelocity, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 3.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tPosition, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 4.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tScene, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 5.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tBloom, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 6.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tAdd, mod(uv, 1.0)).rgb;
                                }
                            }
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        // https://adinunz.io/translucentPearls/

        // Based on http://lo-th.github.io/Oimo.js/#planet

        class Balls extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { physics, anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(1, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu
                // Based on https://gist.github.com/mattdesl/2ee82157a86962347dedb6572142df7c

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.05 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 0.8 },
                    thicknessPower: { value: 2 },
                    thicknessScale: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).r;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += material.diffuseColor * directLight.color * scatteringIllu * thicknessAttenuation;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new InstancedMesh(geometry, material, count);
                mesh.instanceMatrix.setUsage(DynamicDrawUsage); // Will be updated every frame
                mesh.layers.enable(layers.buffers);
                this.add(mesh);

                const object = new Group();

                for (let i = 0; i < mesh.count; i++) {
                    object.position.x = MathUtils.randFloat(10, 100) * (headsTails() ? -1 : 1);
                    object.position.y = MathUtils.randFloat(10, 100) * (headsTails() ? -1 : 1);
                    object.position.z = MathUtils.randFloat(10, 100) * (headsTails() ? -1 : 1);

                    object.rotation.x = MathUtils.degToRad(MathUtils.randInt(0, 360));
                    object.rotation.y = MathUtils.degToRad(MathUtils.randInt(0, 360));
                    object.rotation.z = MathUtils.degToRad(MathUtils.randInt(0, 360));

                    object.updateMatrix();

                    mesh.setMatrixAt(i, object.matrix);
                }

                mesh.computeBoundingSphere();

                // Physics
                physics.add(mesh, { autoSleep: false });

                this.uniforms = uniforms;
                this.mesh = mesh;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class Sphere extends Group {
            constructor() {
                super();

                // Physics
                this.name = 'sphere';
                this.autoSleep = false;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 1.9, 4.4, 0);
                this.add(light);
            }

            async initMesh() {
                const { physics, anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(1, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(colors.lightColor),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.2 };
                    shader.uniforms.thicknessPower = { value: 2 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.layers.enable(layers.buffers);
                this.add(mesh);

                // Occlusion mesh
                const occMesh = mesh.clone();
                occMesh.material = new MeshBasicMaterial({ color: colors.lightColor });
                occMesh.layers.set(layers.occlusion);
                this.add(occMesh);

                // Physics
                physics.add(mesh);

                const body = new RigidBodyConfig();
                body.type = RigidBodyType.KINEMATIC;
                physics.add(body);

                const joint = new UniversalJointConfig();
                joint.rigidBody1 = physics.get(this);
                joint.rigidBody2 = physics.get(body);
                physics.add(joint);

                this.body = body;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.sphere = new Sphere();
                this.add(this.sphere);

                this.balls = new Balls();
                this.add(this.balls);
            }

            // Public methods

            ready = () => Promise.all([
                this.sphere.ready(),
                this.balls.ready()
            ]);
        }

        class SceneController {
            static init(physics, view) {
                this.physics = physics;
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.lightPosition = new Vector3();

                // Physics
                this.force = new Vector3();
                this.center = new Vector3(0, 0, 0);
                this.object = new Group();
                this.matrix = new Matrix4();

                this.enabled = true;
                this.animatedOneFramePast = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = () => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.sphere.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                if (this.enabled || !this.animatedOneFramePast) {
                    // Mouse light
                    this.lightPosition.x = this.mouse.x * this.halfWidth;
                    this.lightPosition.y = this.mouse.y * this.halfHeight;
                    this.lightPosition.z = this.view.sphere.position.z;

                    this.physics.setPosition(this.view.sphere.body, this.lightPosition);

                    // Physics
                    for (let i = 0; i < this.view.balls.mesh.count; i++) {
                        const { position, quaternion, scale } = this.object;

                        this.view.balls.mesh.getMatrixAt(i, this.matrix);
                        this.matrix.decompose(position, quaternion, scale);

                        this.force.copy(position).negate().normalize().multiplyScalar(0.1);
                        this.physics.applyImpulse(this.view.balls.mesh, this.force, this.center, i);
                    }

                    this.physics.step();

                    this.animatedOneFramePast = !this.enabled;
                }
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(physics, view, ui) {
                this.physics = physics;
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { drawBuffers, vlMaterial, luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const physics = this.physics;
                const { balls } = this.view;

                const gravity = this.physics.getGravity();

                const physicsOptions = {
                    Off: false,
                    Physics: true
                };

                const defaultOptions = {
                    Off: false,
                    Targets: true
                };

                const defaultItems = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: defaultOptions,
                        value: getKeyByValue(defaultOptions, compositeMaterial.uniforms.uDebug.value),
                        callback: value => {
                            compositeMaterial.uniforms.uDebug.value = defaultOptions[value];
                        }
                    }
                ];

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: DisplayOptions,
                        value: getKeyByValue(DisplayOptions, RenderManager.display),
                        callback: (value, item) => {
                            if (!item.hasContent()) {
                                const defaultPanel = new Panel();
                                defaultPanel.animateIn(true);

                                defaultItems.forEach(data => {
                                    defaultPanel.add(new PanelItem(data));
                                });

                                item.setContent(defaultPanel);
                            }

                            RenderManager.display = DisplayOptions[value];

                            if (RenderManager.display === DisplayOptions.Default) {
                                item.toggleContent(true);
                            } else {
                                item.toggleContent(false);
                            }
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: physicsOptions,
                        value: getKeyByValue(physicsOptions, SceneController.enabled),
                        callback: value => {
                            SceneController.enabled = physicsOptions[value];
                            drawBuffers.saveState = SceneController.enabled;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Gravity',
                        min: -10,
                        max: 10,
                        step: 0.1,
                        value: -gravity.y,
                        callback: value => {
                            gravity.y = -value;
                            physics.setGravity(gravity);
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Interp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: drawBuffers.interpolateGeometry,
                        callback: value => {
                            drawBuffers.interpolateGeometry = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smear',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: drawBuffers.smearIntensity,
                        callback: value => {
                            drawBuffers.smearIntensity = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Decay',
                        min: 0.6,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDecay.value,
                        callback: value => {
                            vlMaterial.uniforms.uDecay.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDensity.value,
                        callback: value => {
                            vlMaterial.uniforms.uDensity.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Weight',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uWeight.value,
                        callback: value => {
                            vlMaterial.uniforms.uWeight.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Scale X',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: vlMaterial.uniforms.uLensflareScale.value.x,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareScale.value.x = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale Y',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: vlMaterial.uniforms.uLensflareScale.value.y,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareScale.value.y = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uLensflareExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uLensflareClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: balls.uniforms.thicknessDistortion.value,
                        callback: value => {
                            balls.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: balls.uniforms.thicknessAmbient.value,
                        callback: value => {
                            balls.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: balls.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            balls.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: balls.uniforms.thicknessPower.value,
                        callback: value => {
                            balls.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: balls.uniforms.thicknessScale.value,
                        callback: value => {
                            balls.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, view) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;

                // Volumetric light and lens flare
                this.lightPosition = new Vector3();
                this.vlExposure = 0.1;
                this.vlDecay = 1;
                this.vlDensity = 1;
                this.vlWeight = 0.4;
                this.vlClamp = 1;
                this.lensflareScale = new Vector2(2.5, 2.5);
                this.lensflareExposure = 0.02;
                this.lensflareClamp = 1;
                this.blurResolutionScale = 0.25;
                this.blurAmount = 2.5;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                // Debug
                DisplayOptions.Light = 8;
                this.display = DisplayOptions.Default;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution, aspect, textureLoader, getTexture } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Clear colors
                this.clearColor = new Color(0, 0, 0);
                this.currentClearColor = new Color();

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBlurA = this.renderTargetA.clone();
                this.renderTargetBlurB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetBlurA.depthBuffer = true;

                // G-Buffer
                this.drawBuffers = new DrawBuffers(this.renderer, this.scene, this.camera, layers.buffers, {
                    cameraBlur: false
                });

                // Motion blur composite material
                this.motionBlurCompositeMaterial = new MotionBlurCompositeMaterial(textureLoader, {
                    blueNoisePath: 'blue_noise.png'
                });
                this.motionBlurCompositeMaterial.uniforms.tVelocity.value = this.drawBuffers.renderTarget.textures[1];

                // Occlusion material
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Volumetric light material
                this.vlMaterial = new VolumetricLightLensflareMaterial();
                this.vlMaterial.uniforms.uExposure.value = this.vlExposure;
                this.vlMaterial.uniforms.uDecay.value = this.vlDecay;
                this.vlMaterial.uniforms.uDensity.value = this.vlDensity;
                this.vlMaterial.uniforms.uWeight.value = this.vlWeight;
                this.vlMaterial.uniforms.uClamp.value = this.vlClamp;
                this.vlMaterial.uniforms.uLensflareScale.value = this.lensflareScale;
                this.vlMaterial.uniforms.uLensflareExposure.value = this.lensflareExposure;
                this.vlMaterial.uniforms.uLensflareClamp.value = this.lensflareClamp;
                this.vlMaterial.uniforms.uResolution = resolution;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.uAspect = aspect;

                // Debug materials
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });
                this.matcap1Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/040full.jpg') });
                this.matcap2Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/defaultwax.jpg') });
                this.normalMaterial = new NormalMaterial();
                this.normalMaterialInstanced = new NormalMaterial({ instancing: true });
                this.depthMaterial = new DepthMaterial();
                this.depthMaterialInstanced = new DepthMaterial({ instancing: true });
                this.copyMaterial = new CopyMaterial();

                // Based on https://github.com/mrdoob/three.js/issues/26732#issuecomment-1741276120 by donmccurdy
                this.originalMaterials = new Map();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static setLightPosition() {
                this.lightPosition.copy(this.view.sphere.position).project(this.camera);

                const x = (this.lightPosition.x + 1) / 2;
                const y = (this.lightPosition.y + 1) / 2;

                this.vlMaterial.uniforms.uLightPosition.value.set(x, y);
            }

            static rendererState() {
                this.currentOverrideMaterial = this.scene.overrideMaterial;
                this.currentBackground = this.scene.background;
                this.renderer.getClearColor(this.currentClearColor);
                this.currentClearAlpha = this.renderer.getClearAlpha();
            }

            static restoreRendererState() {
                this.scene.overrideMaterial = this.currentOverrideMaterial;
                this.scene.background = this.currentBackground;
                this.renderer.setClearColor(this.currentClearColor, this.currentClearAlpha);

                // Restore original materials
                for (const [object, material] of this.originalMaterials.entries()) {
                    object.material = material;
                }
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                this.drawBuffers.setSize(width, height);

                // Gaussian blur
                const blurWidth = Math.round(width * this.blurResolutionScale);
                const blurHeight = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(blurWidth, blurHeight);
                this.renderTargetBlurB.setSize(blurWidth, blurHeight);

                this.hBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);
                this.vBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Renderer state
                this.rendererState();

                // G-Buffer layer
                camera.layers.set(layers.buffers);

                this.drawBuffers.update();

                if (this.display === DisplayOptions.Velocity) {
                    // Debug pass (render to screen)
                    this.copyMaterial.uniforms.tMap.value = this.drawBuffers.renderTarget.textures[1];
                    this.screen.material = this.copyMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                }

                // Scene layer
                camera.layers.set(layers.default);

                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Occlusion layer
                scene.background = null;

                scene.overrideMaterial = this.blackoutMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = this.currentOverrideMaterial;

                camera.layers.set(layers.occlusion);

                renderer.render(scene, camera);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Volumetric light pass
                this.vlMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.setLightPosition();
                this.screen.material = this.vlMaterial;

                if (this.display === DisplayOptions.Light) {
                    // Debug pass (render to screen)
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                } else {
                    renderer.setRenderTarget(renderTargetBlurB);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Post-processing
                camera.layers.set(layers.default);

                scene.background = null;
                renderer.setClearColor(this.clearColor, 1);

                // Debug override material passes (render to screen)
                if (this.display === DisplayOptions.Depth) {
                    scene.traverseVisible(object => {
                        if (object.material) {
                            this.originalMaterials.set(object, object.material);

                            if (object.isInstancedMesh) {
                                object.material = this.depthMaterialInstanced;
                            } else {
                                object.material = this.depthMaterial;
                            }
                        }
                    });

                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);

                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Geometry) {
                    scene.traverseVisible(object => {
                        if (object.material) {
                            this.originalMaterials.set(object, object.material);

                            if (object.isInstancedMesh) {
                                object.material = this.normalMaterialInstanced;
                            } else {
                                object.material = this.normalMaterial;
                            }
                        }
                    });

                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);

                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Matcap1) {
                    scene.overrideMaterial = this.matcap1Material;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Matcap2) {
                    scene.overrideMaterial = this.matcap2Material;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                }

                // Motion blur pass
                this.motionBlurCompositeMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.motionBlurCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;

                if (this.display === DisplayOptions.Luma) {
                    // Debug pass (render to screen)
                    this.screen.material = this.blackoutMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.screen.material = this.luminosityMaterial;
                    this.screen.material.blending = AdditiveBlending;
                    renderer.render(this.screen, this.screenCamera);
                    this.screen.material.blending = NoBlending;
                    this.restoreRendererState();
                    return;
                } else {
                    this.screen.material = this.luminosityMaterial;
                    renderer.setRenderTarget(renderTargetBright);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;

                if (this.display === DisplayOptions.Bloom) {
                    // Debug pass (render to screen)
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                } else {
                    renderer.setRenderTarget(renderTargetsHorizontal[0]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tPosition.value = this.drawBuffers.renderTarget.textures[0];
                this.compositeMaterial.uniforms.tVelocity.value = this.drawBuffers.renderTarget.textures[1];
                this.compositeMaterial.uniforms.tScene.value = renderTargetB.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.compositeMaterial.uniforms.tAdd.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Restore renderer settings
                this.restoreRendererState();
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.targetXY.x = 1;
                } else {
                    this.targetXY.x = 2;
                }
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initPhysics();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(35);
                this.camera.near = 1;
                this.camera.far = 3000;
                this.camera.position.z = 40;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.quad = new PlaneGeometry(1, 1);
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initPhysics() {
                this.physics = new OimoPhysics({
                    gravity: new Vector3(0, 0, 0)
                });
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera, physics } = WorldController;

                CameraController.init(camera);
                SceneController.init(physics, this.view);
                RenderManager.init(renderer, scene, camera, this.view);
            }

            static initPanel() {
                const { physics } = WorldController;

                PanelController.init(physics, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_physics_instancing_thread.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Physics Instancing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BasicShadowMap, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, DirectionalLight, DynamicDrawUsage, EnvironmentTextureLoader, EventEmitter, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, InstancedMesh, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Matrix4, Mesh, MeshBasicMaterial, MeshStandardMaterial, OimoPhysicsBuffer, OimoPhysicsController, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, Reflector, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, ShaderChunk, ShadowMaterial, SphereGeometry, TextureLoader, Thread, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, getViewSize, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const colors = {
            lightColor: 0xf44336
        };

        class ScenePhysics extends EventEmitter {
            constructor(shapes) {
                super();

                this.shapes = shapes;

                this.initPhysics();
            }

            initPhysics() {
                this.physics = new OimoPhysicsBuffer();

                this.shapes.forEach(shape => this.physics.add(shape));
            }

            // Public methods

            step = () => {
                this.physics.step();

                this.emit('buffer', { array: this.physics.array, buffer: [this.physics.array.buffer] });
            };

            update = array => {
                this.physics.array = array;

                this.step();
            };

            setGravity = gravity => {
                this.physics.setGravity(gravity);
            };

            setPosition = (name, position) => {
                this.physics.setPosition(name, position);
            };

            setOrientation = (name, orientation) => {
                this.physics.setOrientation(name, orientation);
            };

            setLinearVelocity = (name, linearVelocity) => {
                this.physics.setLinearVelocity(name, linearVelocity);
            };

            setAngularVelocity = (name, angularVelocity) => {
                this.physics.setAngularVelocity(name, angularVelocity);
            };
        }

        class ScenePhysicsThread {
            constructor() {
                this.startTime = performance.now();

                this.addListeners();
            }

            addListeners() {
                addEventListener('message', this.onMessage);
            }

            // Event handlers

            onMessage = ({ data }) => {
                this[data.message.fn].call(this, data.message);
            };

            onBuffer = ({ array, buffer }) => {
                postMessage({ event: 'buffer', message: { array } }, buffer);
            };

            // Public methods

            init = ({ shapes }) => {
                this.physics = new ScenePhysics(shapes);
                this.physics.on('buffer', this.onBuffer);

                this.physics.step();

                postMessage({ event: 'ready' });
            };

            update = ({ array }) => {
                this.physics.update(array);

                ticker.onTick(performance.now() - this.startTime);
            };

            setGravity = ({ gravity }) => {
                this.physics.setGravity(gravity);
            };

            setPosition = ({ name, position }) => {
                this.physics.setPosition(name, position);
            };

            setOrientation = ({ name, orientation }) => {
                this.physics.setOrientation(name, orientation);
            };

            setLinearVelocity = ({ name, linearVelocity }) => {
                this.physics.setLinearVelocity(name, linearVelocity);
            };

            setAngularVelocity = ({ name, angularVelocity }) => {
                this.physics.setAngularVelocity(name, angularVelocity);
            };
        }

        class ScenePhysicsController extends OimoPhysicsController {
            constructor() {
                super();

                this.buffer = [];
            }

            init() {
                this.initEngine();

                this.addListeners();
            }

            initEngine() {
                this.thread = new Thread({
                    imports: [
                        ['../../build/alien.three.js', 'EventEmitter', 'OimoPhysicsBuffer', 'Vector3', 'delayedCall', 'ticker']
                    ],
                    classes: [ScenePhysics],
                    controller: [ScenePhysicsThread, 'void init', 'void update', 'void setGravity', 'void setPosition', 'void setOrientation', 'void setLinearVelocity', 'void setAngularVelocity']
                });

                this.thread.init({ shapes: this.shapes });
            }

            addListeners() {
                this.thread.on('buffer', this.onBuffer);
            }

            // Event handlers

            onBuffer = ({ array }) => {
                this.buffer.push(array);
            };

            // Public methods

            update = () => {
                const array = this.buffer.shift();

                if (array) {
                    this.step(array);

                    this.thread.update({ array, buffer: [array.buffer] });
                }
            };

            setGravity = gravity => {
                this.thread.setGravity({ gravity });
            };

            setPosition = (object, position, index) => {
                const { name } = this.getObjectBody(object, index);

                this.thread.setPosition({ name, position });
            };

            setOrientation = (object, orientation, index) => {
                const { name } = this.getObjectBody(object, index);

                this.thread.setOrientation({ name, orientation });
            };

            setLinearVelocity = (object, linearVelocity, index) => {
                const { name } = this.getObjectBody(object, index);

                this.thread.setLinearVelocity({ name, linearVelocity });
            };

            setAngularVelocity = (object, angularVelocity, index) => {
                const { name } = this.getObjectBody(object, index);

                this.thread.setAngularVelocity({ name, angularVelocity });
            };

            ready = () => this.init();
        }

        class MouseLight extends Group {
            constructor() {
                super();

                this.position.z = 0;

                this.initLight();

                if (isDebug) {
                    this.initDebug();
                }
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 0.9, 4.4, 0);
                this.add(light);
            }

            initDebug() {
                const geometry = new SphereGeometry(0.125, 1, 1);

                const material = new MeshBasicMaterial({
                    color: 0xff0000,
                    wireframe: true
                });

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class Floor extends Group {
            constructor(light) {
                super();

                this.mouseLight = light;

                this.position.y = -2.5;

                // Physics
                this.name = 'floor';
                this.size = new Vector3(100, 5, 100);
                this.density = 0;
                this.autoSleep = false;

                this.initReflector();
            }

            initReflector() {
                const { light } = WorldController;

                this.light = light;

                this.reflector = new Reflector({ blurIterations: 6 });
            }

            async initMesh() {
                const { physics, loadTexture } = WorldController;

                const geometry = new PlaneGeometry(this.size.x, this.size.z);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 3);

                const material = new ShadowMaterial({
                    toneMapped: false
                });

                material.onBeforeCompile = shader => {
                    map.updateMatrix();

                    shader.uniforms.map = { value: map };
                    shader.uniforms.reflectMap = { value: this.reflector.renderTarget.texture };
                    shader.uniforms.reflectMapBlur = this.reflector.renderTargetUniform;
                    shader.uniforms.uvTransform = { value: map.matrix };
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat3 uvTransform;
                        uniform mat4 textureMatrix;

                        out vec2 vUv;
                        out vec4 vCoord;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vUv = (uvTransform * vec3(uv, 1)).xy;
                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D map;
                        uniform sampler2D reflectMap;
                        uniform sampler2D reflectMapBlur;

                        in vec2 vUv;
                        in vec4 vCoord;

                        ${dither}

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );',
                        /* glsl */ `
                        vec2 reflectionUv = vCoord.xy / vCoord.w;

                        vec4 dudv = texture(map, vUv);
                        vec4 color = texture(reflectMap, reflectionUv);

                        vec4 blur;

                        blur = texture(reflectMapBlur, reflectionUv + dudv.rg / 256.0);
                        color = mix(color, blur, smoothstep(1.0, 0.1, dudv.g));

                        blur = texture(reflectMapBlur, reflectionUv);
                        color = mix(color, blur, smoothstep(0.5, 1.0, dudv.r));

                        gl_FragColor = color * mix(0.3, 0.55, dudv.g);

                        gl_FragColor.rgb -= (1.0 - getShadowMask()) * 0.025;

                        gl_FragColor.rgb = dither(gl_FragColor.rgb);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = 2.494; // 5 / 2 - 0.006
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.light.position.y *= -1;
                    this.mouseLight.position.y *= -1;
                    this.reflector.update(renderer, scene, camera);
                    this.light.position.y *= -1;
                    this.mouseLight.position.y *= -1;
                    this.visible = true;
                };

                this.add(mesh);

                // Physics mesh
                const floor = new Mesh(new BoxGeometry(this.size.x, this.size.y, this.size.z));
                floor.geometry.setDrawRange(0, 0); // Avoid rendering geometry
                this.add(floor);

                physics.add(floor);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.light = new MouseLight();
                this.add(this.light);

                this.floor = new Floor(this.light);
                this.add(this.floor);
            }

            async initMesh() {
                const { physics, anisotropy, loadTexture } = WorldController;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                normalMap.anisotropy = anisotropy;
                ormMap.anisotropy = anisotropy;
                thicknessMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.8 };
                    shader.uniforms.thicknessPower = { value: 20 };
                    shader.uniforms.thicknessScale = { value: 2 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        // ShaderChunk.lights_fragment_begin.replaceAll(
                        ShaderChunk.lights_fragment_begin.replace(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                // Based on https://threejs.org/examples/#physics_oimo_instancing by VBT-YTokan

                const matrix = new Matrix4();

                // Boxes
                const geometryBox = new BoxGeometry(0.1, 0.1, 0.1);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometryBox.attributes.uv1 = geometryBox.attributes.uv;

                const boxes = new InstancedMesh(geometryBox, material, 100);
                boxes.instanceMatrix.setUsage(DynamicDrawUsage); // Will be updated every frame
                boxes.castShadow = true;
                boxes.receiveShadow = true;
                this.add(boxes);

                for (let i = 0; i < boxes.count; i++) {
                    matrix.setPosition(Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5);
                    boxes.setMatrixAt(i, matrix);
                }

                boxes.computeBoundingSphere();

                physics.add(boxes, { autoSleep: false });

                // Spheres
                const geometrySphere = new IcosahedronGeometry(0.075, 3);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometrySphere.attributes.uv1 = geometrySphere.attributes.uv;

                const spheres = new InstancedMesh(geometrySphere, material, 100);
                spheres.instanceMatrix.setUsage(DynamicDrawUsage); // Will be updated every frame
                spheres.castShadow = true;
                spheres.receiveShadow = true;
                this.add(spheres);

                for (let i = 0; i < spheres.count; i++) {
                    matrix.setPosition(Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5);
                    spheres.setMatrixAt(i, matrix);
                }

                spheres.computeBoundingSphere();

                physics.add(spheres, { autoSleep: false });

                this.boxes = boxes;
                this.spheres = spheres;
            }

            // Public methods

            ready = () => Promise.all([
                this.floor.ready(),
                this.initMesh()
            ]);
        }

        class SceneController {
            static init(physics, view) {
                this.physics = physics;
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.target = new Vector2();
                this.lightPosition = new Vector3();
                this.lerpSpeed = 0.25;

                // Physics
                this.position = new Vector3();

                this.enabled = true;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.target.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.target.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.view.floor.resize(width, height);

                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.light.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.enabled || !this.view.visible) {
                    return;
                }

                this.mouse.lerp(this.target, this.lerpSpeed);

                this.lightPosition.x = this.mouse.x * this.halfWidth;
                this.lightPosition.y = 0.5 + this.mouse.y * this.halfHeight;
                this.lightPosition.z = this.view.light.position.z;

                this.view.light.position.copy(this.lightPosition);

                let index = Math.floor(Math.random() * this.view.boxes.count);

                this.position.set(0, Math.random() + 1, 0);
                this.physics.setPosition(this.view.boxes, this.position.toArray(), index);

                index = Math.floor(Math.random() * this.view.spheres.count);

                this.position.set(0, Math.random() + 1, 0);
                this.physics.setPosition(this.view.spheres, this.position.toArray(), index);

                this.physics.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = async () => {
                await this.view.ready();
                await this.physics.ready();
            };
        }

        class PanelController {
            static init(physics, view, ui) {
                this.physics = physics;
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const physics = this.physics;
                const view = this.view;

                const vector3 = new Vector3();
                const gravity = new Vector3(0, -9.81, 0);

                const physicsOptions = {
                    Off: false,
                    Physics: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: physicsOptions,
                        value: getKeyByValue(physicsOptions, SceneController.enabled),
                        callback: value => {
                            SceneController.enabled = physicsOptions[value];

                            // Reset
                            vector3.set(0, 0, 0);
                            const array = vector3.toArray();

                            for (let i = 0, l = view.boxes.count; i < l; i++) {
                                physics.setLinearVelocity(view.boxes, array, i);
                                physics.setAngularVelocity(view.boxes, array, i);
                            }

                            for (let i = 0, l = view.spheres.count; i < l; i++) {
                                physics.setLinearVelocity(view.spheres, array, i);
                                physics.setAngularVelocity(view.spheres, array, i);
                            }

                            // Flush the last frame
                            physics.update();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Gravity',
                        min: -10,
                        max: 10,
                        step: 0.1,
                        value: -gravity.y,
                        callback: value => {
                            gravity.y = -value;
                            physics.setGravity(gravity.toArray());
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initPhysics();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // Shadows
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = BasicShadowMap;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.set(0, 1.5, 5);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                light.castShadow = true;
                light.shadow.mapSize.width = 2048;
                light.shadow.mapSize.height = 2048;
                this.scene.add(light);

                this.light = light;
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initPhysics() {
                this.physics = new ScenePhysicsController();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();

                Thread.count--; // Make room for the physics thread
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera, physics } = WorldController;

                CameraController.init(camera);
                SceneController.init(physics, this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { physics } = WorldController;

                PanelController.init(physics, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_physics_instancing.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Physics Instancing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BasicShadowMap, BloomCompositeMaterial, BoxGeometry, Color, ColorManagement, DirectionalLight, DynamicDrawUsage, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, InstancedMesh, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Matrix4, Mesh, MeshBasicMaterial, MeshStandardMaterial, OimoPhysics, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, Reflector, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, ShaderChunk, ShadowMaterial, SphereGeometry, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, getViewSize, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const colors = {
            lightColor: 0xf44336
        };

        class MouseLight extends Group {
            constructor() {
                super();

                this.position.z = 0;

                this.initLight();

                if (isDebug) {
                    this.initDebug();
                }
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 0.9, 4.4, 0);
                this.add(light);
            }

            initDebug() {
                const geometry = new SphereGeometry(0.125, 1, 1);

                const material = new MeshBasicMaterial({
                    color: 0xff0000,
                    wireframe: true
                });

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class Floor extends Group {
            constructor(light) {
                super();

                this.mouseLight = light;

                this.position.y = -2.5;

                this.initReflector();
            }

            initReflector() {
                const { light } = WorldController;

                this.light = light;

                this.reflector = new Reflector({ blurIterations: 6 });
            }

            async initMesh() {
                const { physics, loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 3);

                const material = new ShadowMaterial({
                    toneMapped: false
                });

                material.onBeforeCompile = shader => {
                    map.updateMatrix();

                    shader.uniforms.map = { value: map };
                    shader.uniforms.reflectMap = { value: this.reflector.renderTarget.texture };
                    shader.uniforms.reflectMapBlur = this.reflector.renderTargetUniform;
                    shader.uniforms.uvTransform = { value: map.matrix };
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat3 uvTransform;
                        uniform mat4 textureMatrix;

                        out vec2 vUv;
                        out vec4 vCoord;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vUv = (uvTransform * vec3(uv, 1)).xy;
                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D map;
                        uniform sampler2D reflectMap;
                        uniform sampler2D reflectMapBlur;

                        in vec2 vUv;
                        in vec4 vCoord;

                        ${dither}

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );',
                        /* glsl */ `
                        vec2 reflectionUv = vCoord.xy / vCoord.w;

                        vec4 dudv = texture(map, vUv);
                        vec4 color = texture(reflectMap, reflectionUv);

                        vec4 blur;

                        blur = texture(reflectMapBlur, reflectionUv + dudv.rg / 256.0);
                        color = mix(color, blur, smoothstep(1.0, 0.1, dudv.g));

                        blur = texture(reflectMapBlur, reflectionUv);
                        color = mix(color, blur, smoothstep(0.5, 1.0, dudv.r));

                        gl_FragColor = color * mix(0.3, 0.55, dudv.g);

                        gl_FragColor.rgb -= (1.0 - getShadowMask()) * 0.025;

                        gl_FragColor.rgb = dither(gl_FragColor.rgb);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = 2.494; // 5 / 2 - 0.006
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.light.position.y *= -1;
                    this.mouseLight.position.y *= -1;
                    this.reflector.update(renderer, scene, camera);
                    this.light.position.y *= -1;
                    this.mouseLight.position.y *= -1;
                    this.visible = true;
                };

                this.add(mesh);

                // Physics mesh
                const floor = new Mesh(new BoxGeometry(100, 5, 100));
                floor.geometry.setDrawRange(0, 0); // Avoid rendering geometry
                this.add(floor);

                physics.add(floor, { density: 0, autoSleep: false });
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.light = new MouseLight();
                this.add(this.light);

                this.floor = new Floor(this.light);
                this.add(this.floor);
            }

            async initMesh() {
                const { physics, anisotropy, loadTexture } = WorldController;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                normalMap.anisotropy = anisotropy;
                ormMap.anisotropy = anisotropy;
                thicknessMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.8 };
                    shader.uniforms.thicknessPower = { value: 20 };
                    shader.uniforms.thicknessScale = { value: 2 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        // ShaderChunk.lights_fragment_begin.replaceAll(
                        ShaderChunk.lights_fragment_begin.replace(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                // Based on https://threejs.org/examples/#physics_oimo_instancing by VBT-YTokan

                const matrix = new Matrix4();

                // Boxes
                const geometryBox = new BoxGeometry(0.1, 0.1, 0.1);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometryBox.attributes.uv1 = geometryBox.attributes.uv;

                const boxes = new InstancedMesh(geometryBox, material, 100);
                boxes.instanceMatrix.setUsage(DynamicDrawUsage); // Will be updated every frame
                boxes.castShadow = true;
                boxes.receiveShadow = true;
                this.add(boxes);

                for (let i = 0; i < boxes.count; i++) {
                    matrix.setPosition(Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5);
                    boxes.setMatrixAt(i, matrix);
                }

                boxes.computeBoundingSphere();

                physics.add(boxes, { autoSleep: false });

                // Spheres
                const geometrySphere = new IcosahedronGeometry(0.075, 3);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometrySphere.attributes.uv1 = geometrySphere.attributes.uv;

                const spheres = new InstancedMesh(geometrySphere, material, 100);
                spheres.instanceMatrix.setUsage(DynamicDrawUsage); // Will be updated every frame
                spheres.castShadow = true;
                spheres.receiveShadow = true;
                this.add(spheres);

                for (let i = 0; i < spheres.count; i++) {
                    matrix.setPosition(Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5);
                    spheres.setMatrixAt(i, matrix);
                }

                spheres.computeBoundingSphere();

                physics.add(spheres, { autoSleep: false });

                this.boxes = boxes;
                this.spheres = spheres;
            }

            // Public methods

            ready = () => Promise.all([
                this.floor.ready(),
                this.initMesh()
            ]);
        }

        class SceneController {
            static init(physics, view) {
                this.physics = physics;
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.target = new Vector2();
                this.lightPosition = new Vector3();
                this.lerpSpeed = 0.25;

                // Physics
                this.position = new Vector3();

                this.enabled = true;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.target.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.target.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.view.floor.resize(width, height);

                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.light.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.enabled || !this.view.visible) {
                    return;
                }

                this.mouse.lerp(this.target, this.lerpSpeed);

                this.lightPosition.x = this.mouse.x * this.halfWidth;
                this.lightPosition.y = 0.5 + this.mouse.y * this.halfHeight;
                this.lightPosition.z = this.view.light.position.z;

                this.view.light.position.copy(this.lightPosition);

                let index = Math.floor(Math.random() * this.view.boxes.count);

                this.position.set(0, Math.random() + 1, 0);
                this.physics.setPosition(this.view.boxes, this.position, index);

                index = Math.floor(Math.random() * this.view.spheres.count);

                this.position.set(0, Math.random() + 1, 0);
                this.physics.setPosition(this.view.spheres, this.position, index);

                this.physics.step();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(physics, view, ui) {
                this.physics = physics;
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const physics = this.physics;
                const view = this.view;

                const vector3 = new Vector3();
                const gravity = this.physics.getGravity();

                const physicsOptions = {
                    Off: false,
                    Physics: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: physicsOptions,
                        value: getKeyByValue(physicsOptions, SceneController.enabled),
                        callback: value => {
                            SceneController.enabled = physicsOptions[value];

                            // Reset
                            vector3.set(0, 0, 0);

                            for (let i = 0, l = view.boxes.count; i < l; i++) {
                                physics.setLinearVelocity(view.boxes, vector3, i);
                                physics.setAngularVelocity(view.boxes, vector3, i);
                            }

                            for (let i = 0, l = view.spheres.count; i < l; i++) {
                                physics.setLinearVelocity(view.spheres, vector3, i);
                                physics.setAngularVelocity(view.spheres, vector3, i);
                            }
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Gravity',
                        min: -10,
                        max: 10,
                        step: 0.1,
                        value: -gravity.y,
                        callback: value => {
                            gravity.y = -value;
                            physics.setGravity(gravity);
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initPhysics();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // Shadows
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = BasicShadowMap;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.set(0, 1.5, 5);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                light.castShadow = true;
                light.shadow.mapSize.width = 2048;
                light.shadow.mapSize.height = 2048;
                this.scene.add(light);

                this.light = light;
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initPhysics() {
                this.physics = new OimoPhysics();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera, physics } = WorldController;

                CameraController.init(camera);
                SceneController.init(physics, this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { physics } = WorldController;

                PanelController.init(physics, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_physics_picking_thread.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Physics Picking — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BasicShadowMap, BloomCompositeMaterial, BoxGeometry, BufferLoader, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, EventEmitter, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshPhongMaterial, MeshStandardMaterial, OimoPhysicsBuffer, OimoPhysicsController, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, Raycaster, Reflector, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, ShaderChunk, ShadowMaterial, Sound3D, SphereGeometry, TextureLoader, Thread, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebAudio, WebGLRenderTarget, WebGLRenderer, delayedCall, getFullscreenTriangle, getKeyByValue, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const colors = {
            lightColor: 0xf44336
        };

        const layers = {
            default: 0,
            picking: 1
        };

        class ScenePhysics extends EventEmitter {
            constructor(shapes) {
                super();

                this.shapes = shapes;

                this.force = new Vector3();
                this.contact = null;

                this.initPhysics();

                this.addListeners();
            }

            initPhysics() {
                this.physics = new OimoPhysicsBuffer();

                this.shapes.forEach(shape => this.physics.add(shape));

                this.physics.add({
                    name: 'mouse',
                    kinematic: true
                });
            }

            addListeners() {
                this.physics.setContactCallback('cube', this.onContact);
            }

            // Event handlers

            onContact = (body/* , name, contact */) => {
                if (this.contact) {
                    return;
                }

                const linearVelocity = body.getLinearVelocity();
                const mass = body.getMass();

                this.force.addScaledVector(linearVelocity, mass);
                this.force.multiplyScalar(0.4);

                const force = this.force.length();

                if (force > 0.3) {
                    this.contact = true;

                    this.emit('contact', { force });

                    delayedCall(250, () => {
                        this.contact = false;
                    });
                } else {
                    this.force.multiplyScalar(0);
                }
            };

            // Public methods

            step = () => {
                this.physics.step();

                this.emit('buffer', { array: this.physics.array, buffer: [this.physics.array.buffer] });
            };

            update = array => {
                this.physics.array = array;

                this.step();
            };

            add = object => {
                this.physics.add(object);
            };

            remove = name => {
                this.physics.remove(name);
            };

            setGravity = gravity => {
                this.physics.setGravity(gravity);
            };

            setPosition = (name, position) => {
                this.physics.setPosition(name, position);
            };

            setOrientation = (name, orientation) => {
                this.physics.setOrientation(name, orientation);
            };

            setLinearVelocity = (name, linearVelocity) => {
                this.physics.setLinearVelocity(name, linearVelocity);
            };

            setAngularVelocity = (name, angularVelocity) => {
                this.physics.setAngularVelocity(name, angularVelocity);
            };
        }

        class ScenePhysicsThread {
            constructor() {
                this.startTime = performance.now();

                this.addListeners();
            }

            addListeners() {
                addEventListener('message', this.onMessage);
            }

            // Event handlers

            onMessage = ({ data }) => {
                this[data.message.fn].call(this, data.message);
            };

            onBuffer = ({ array, buffer }) => {
                postMessage({ event: 'buffer', message: { array } }, buffer);
            };

            onContact = ({ force }) => {
                postMessage({ event: 'contact', message: { force } });
            };

            // Public methods

            init = ({ shapes }) => {
                this.physics = new ScenePhysics(shapes);
                this.physics.on('buffer', this.onBuffer);
                this.physics.on('contact', this.onContact);

                this.physics.step();

                postMessage({ event: 'ready' });
            };

            update = ({ array }) => {
                this.physics.update(array);

                ticker.onTick(performance.now() - this.startTime);
            };

            add = ({ object }) => {
                this.physics.add(object);
            };

            remove = ({ name }) => {
                this.physics.remove(name);
            };

            setGravity = ({ gravity }) => {
                this.physics.setGravity(gravity);
            };

            setPosition = ({ name, position }) => {
                this.physics.setPosition(name, position);
            };

            setOrientation = ({ name, orientation }) => {
                this.physics.setOrientation(name, orientation);
            };

            setLinearVelocity = ({ name, linearVelocity }) => {
                this.physics.setLinearVelocity(name, linearVelocity);
            };

            setAngularVelocity = ({ name, angularVelocity }) => {
                this.physics.setAngularVelocity(name, angularVelocity);
            };
        }

        class ScenePhysicsController extends OimoPhysicsController {
            constructor() {
                super();

                this.buffer = [];
            }

            init() {
                this.initEngine();

                this.addListeners();
            }

            initEngine() {
                this.thread = new Thread({
                    imports: [
                        ['../../build/alien.three.js', 'EventEmitter', 'OimoPhysicsBuffer', 'Vector3', 'delayedCall', 'ticker']
                    ],
                    classes: [ScenePhysics],
                    controller: [ScenePhysicsThread, 'void init', 'void update', 'void add', 'void remove', 'void setGravity', 'void setPosition', 'void setOrientation', 'void setLinearVelocity', 'void setAngularVelocity']
                });

                this.thread.init({ shapes: this.shapes });
            }

            addListeners() {
                this.thread.on('buffer', this.onBuffer);
                this.thread.on('contact', this.onContact);
            }

            // Event handlers

            onBuffer = ({ array }) => {
                this.buffer.push(array);
            };

            onContact = ({ force }) => {
                AudioController.trigger('gong', force);
            };

            // Public methods

            update = () => {
                const array = this.buffer.shift();

                if (array) {
                    this.step(array);

                    this.thread.update({ array, buffer: [array.buffer] });
                }
            };

            addJoint = object => {
                this.thread.add({ object });
            };

            remove = name => {
                this.thread.remove({ name });
            };

            setGravity = gravity => {
                this.thread.setGravity({ gravity });
            };

            setPosition = (name, position) => {
                this.thread.setPosition({ name, position });
            };

            setOrientation = (name, orientation) => {
                this.thread.setOrientation({ name, orientation });
            };

            setLinearVelocity = (name, linearVelocity) => {
                this.thread.setLinearVelocity({ name, linearVelocity });
            };

            setAngularVelocity = (name, angularVelocity) => {
                this.thread.setAngularVelocity({ name, angularVelocity });
            };

            ready = () => this.init();
        }

        class Ball extends Group {
            constructor() {
                super();

                this.position.z = 1;

                // Physics
                this.name = 'ball';
                this.radius = 0.075;
                this.autoSleep = false;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 0.9, 4.4, 0);
                this.add(light);
            }

            async initMesh() {
                const { physics } = WorldController;

                const geometry = new IcosahedronGeometry(this.radius, 3);

                const material = new MeshPhongMaterial({
                    color: new Color(colors.lightColor).offsetHSL(0, 0, -0.3)
                });

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.7 };
                    shader.uniforms.thicknessPower = { value: 1 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * 0.8;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.layers.enable(layers.picking);
                this.add(mesh);

                // Physics
                physics.add(mesh);
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class Cube extends Group {
            constructor() {
                super();

                // Physics
                this.name = 'cube';
                this.size = new Vector3(0.5, 0.5, 0.5);
                this.autoSleep = false;
            }

            async initMesh() {
                const { physics, anisotropy, loadTexture } = WorldController;

                const geometry = new BoxGeometry(this.size.x, this.size.y, this.size.z);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                normalMap.anisotropy = anisotropy;
                ormMap.anisotropy = anisotropy;
                thicknessMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu
                // Based on https://gist.github.com/mattdesl/2ee82157a86962347dedb6572142df7c

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 1 };
                    shader.uniforms.thicknessPower = { value: 20 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).r;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += material.diffuseColor * directLight.color * scatteringIllu * thicknessAttenuation;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.layers.enable(layers.picking);
                this.add(mesh);

                // Physics
                physics.add(mesh);
            }

            // Public methods

            ready = () => this.initMesh();
        }

        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class Floor extends Group {
            constructor() {
                super();

                this.position.y = -3.04;

                // Physics
                this.name = 'floor';
                this.size = new Vector3(100, 5, 100);
                this.density = 0;
                this.autoSleep = false;

                this.initReflector();
            }

            initReflector() {
                const { light } = WorldController;

                this.light = light;

                this.reflector = new Reflector({ blurIterations: 6 });
            }

            async initMesh() {
                const { physics, loadTexture } = WorldController;

                const geometry = new PlaneGeometry(this.size.x, this.size.z);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 6);

                const material = new ShadowMaterial({
                    toneMapped: false
                });

                material.onBeforeCompile = shader => {
                    map.updateMatrix();

                    shader.uniforms.map = { value: map };
                    shader.uniforms.reflectMap = { value: this.reflector.renderTarget.texture };
                    shader.uniforms.reflectMapBlur = this.reflector.renderTargetUniform;
                    shader.uniforms.uvTransform = { value: map.matrix };
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat3 uvTransform;
                        uniform mat4 textureMatrix;

                        out vec2 vUv;
                        out vec4 vCoord;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vUv = (uvTransform * vec3(uv, 1)).xy;
                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D map;
                        uniform sampler2D reflectMap;
                        uniform sampler2D reflectMapBlur;

                        in vec2 vUv;
                        in vec4 vCoord;

                        ${dither}

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );',
                        /* glsl */ `
                        vec2 reflectionUv = vCoord.xy / vCoord.w;

                        vec4 dudv = texture(map, vUv);
                        vec4 color = texture(reflectMap, reflectionUv);

                        vec4 blur;

                        blur = texture(reflectMapBlur, reflectionUv + dudv.rg / 256.0);
                        color = mix(color, blur, smoothstep(1.0, 0.1, dudv.g));

                        blur = texture(reflectMapBlur, reflectionUv);
                        color = mix(color, blur, smoothstep(0.5, 1.0, dudv.r));

                        gl_FragColor = color * mix(0.6, 0.75, dudv.g);

                        gl_FragColor.rgb -= (1.0 - getShadowMask()) * 0.025;

                        gl_FragColor.rgb = dither(gl_FragColor.rgb);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = 2.494; // 5 / 2 - 0.006
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.light.position.y *= -1;
                    this.reflector.update(renderer, scene, camera);
                    this.light.position.y *= -1;
                    this.visible = true;
                };

                this.add(mesh);

                // Physics mesh
                const floor = new Mesh(new BoxGeometry(this.size.x, this.size.y, this.size.z));
                floor.geometry.setDrawRange(0, 0); // Avoid rendering geometry
                this.add(floor);

                physics.add(floor);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.cube = new Cube();
                this.add(this.cube);

                this.ball = new Ball();
                this.add(this.ball);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.cube.ready(),
                this.ball.ready()
            ]);
        }

        class SceneController {
            static init(physics, view) {
                this.physics = physics;
                this.view = view;

                this.enabled = true;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
                if (!this.enabled || !this.view.visible) {
                    return;
                }

                this.physics.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = async () => {
                await this.view.ready();
                await this.physics.ready();
            };
        }

        class AudioController {
            static init(scene, camera, view) {
                this.scene = scene;
                this.camera = camera;
                this.view = view;

                this.addListeners();
            }

            static addListeners() {
                document.addEventListener('visibilitychange', this.onVisibility);
                window.addEventListener('pointerdown', this.onPointerDown);
            }

            // Event handlers

            static onVisibility = () => {
                if (document.hidden) {
                    WebAudio.mute();
                } else {
                    WebAudio.unmute();
                }
            };

            static onPointerDown = () => {
                window.removeEventListener('pointerdown', this.onPointerDown);

                WebAudio.resume();
            };

            // Public methods

            static trigger = (event, force) => {
                switch (event) {
                    case 'gong': {
                        const gong = new Sound3D(this.camera, 'gong');
                        gong.position.copy(this.view.cube.position);
                        gong.quaternion.copy(this.view.cube.quaternion);
                        gong.updateMatrixWorld();

                        let mesh;

                        if (isDebug) {
                            mesh = new Mesh(
                                new SphereGeometry(0.0625),
                                new MeshPhongMaterial({ color: 0x0000ff })
                            );
                            mesh.material.depthTest = false;
                            mesh.material.depthWrite = false;
                            mesh.material.transparent = true;
                            mesh.position.copy(this.view.cube.position);
                            mesh.quaternion.copy(this.view.cube.quaternion);
                            mesh.updateMatrixWorld();
                            this.scene.add(mesh);
                        }

                        const strength = MathUtils.mapLinear(force, 0, 4, 0, 1);
                        gong.sound.gain.set(MathUtils.clamp(strength * 0.5, 0, 1));
                        gong.sound.playbackRate.set(MathUtils.clamp(0.8 + strength * 0.4, 0.8, 1.2));
                        gong.sound.play();

                        delayedCall(6000, () => {
                            gong.destroy();

                            if (mesh) {
                                this.scene.remove(mesh);
                                mesh.material.dispose();
                                mesh.geometry.dispose();
                                mesh = null;
                            }
                        });
                        break;
                    }
                }
            };
        }

        class PanelController {
            static init(physics, ui) {
                this.physics = physics;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const physics = this.physics;

                const vector3 = new Vector3();
                const gravity = new Vector3(0, -9.81, 0);

                const physicsOptions = {
                    Off: false,
                    Physics: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: physicsOptions,
                        value: getKeyByValue(physicsOptions, SceneController.enabled),
                        callback: value => {
                            SceneController.enabled = physicsOptions[value];

                            // Reset
                            vector3.set(0, 0, 0);
                            const array = vector3.toArray();

                            physics.objects.forEach(object => {
                                const { name, position, quaternion } = object;

                                physics.setPosition(name, position.toArray());
                                physics.setOrientation(name, quaternion.toArray());
                                physics.setLinearVelocity(name, array);
                                physics.setAngularVelocity(name, array);
                            });

                            // Flush the last frame
                            physics.update();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Gravity',
                        min: -10,
                        max: 10,
                        step: 0.1,
                        value: -gravity.y,
                        callback: value => {
                            gravity.y = -value;
                            physics.setGravity(gravity.toArray());
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class InputManager {
            static init(scene, camera) {
                this.scene = scene;
                this.camera = camera;

                this.raycaster = new Raycaster();
                this.raycaster.layers.set(layers.picking);

                this.mouse = new Vector2();
                this.hover = null;
                this.selected = null;
                this.isDown = false;
                this.enabled = true;

                this.initMesh();

                this.addListeners();
            }

            static initMesh() {
                const { quad } = WorldController;

                let material;

                if (isDebug) {
                    material = new MeshBasicMaterial({
                        color: 0xff0000,
                        wireframe: true
                    });
                } else {
                    material = new MeshBasicMaterial({ visible: false });
                }

                this.dragPlane = new Mesh(quad, material);
                this.dragPlane.scale.multiplyScalar(200);
                this.dragPlane.layers.enable(layers.picking);
            }

            static addListeners() {
                window.addEventListener('pointerdown', this.onPointerDown);
                window.addEventListener('pointermove', this.onPointerMove);
                window.addEventListener('pointerup', this.onPointerUp);
            }

            // Event handlers

            static onPointerDown = e => {
                if (!this.enabled) {
                    return;
                }

                this.isDown = true;

                this.onPointerMove(e);
            };

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;

                if (this.selected) {
                    this.raycaster.setFromCamera(this.mouse, this.camera);

                    const intersection = this.raycaster.intersectObject(this.dragPlane);

                    if (intersection.length) {
                        const point = intersection[0].point;

                        SceneController.physics.setPosition('mouse', point.toArray());
                    }

                    return;
                }

                this.raycaster.setFromCamera(this.mouse, this.camera);

                const intersection = this.raycaster.intersectObjects(this.scene.children);

                if (intersection.length) {
                    let object = intersection[0].object;

                    if (object.parent.isGroup) {
                        object = object.parent;
                    }

                    if (this.isDown && this.selected !== object) {
                        this.selected = object;

                        const point = intersection[0].point;
                        const array = point.toArray();

                        SceneController.physics.setPosition('mouse', array);

                        SceneController.physics.addJoint({
                            name: 'mouseJoint',
                            type: 'joint',
                            mode: 'spherical',
                            body1: object.name,
                            body2: 'mouse',
                            worldAnchor: array,
                            springDamper: [4, 1]
                        });

                        this.dragPlane.position.copy(point);
                        this.dragPlane.quaternion.copy(this.camera.quaternion);

                        this.scene.add(this.dragPlane);

                        CameraController.enabled = false;

                        document.body.style.cursor = 'move';
                    } else if (this.hover !== object) {
                        this.hover = object;
                        document.body.style.cursor = 'pointer';
                    }
                } else if (this.hover) {
                    this.hover = null;
                    document.body.style.cursor = '';
                }
            };

            static onPointerUp = () => {
                if (!this.enabled) {
                    return;
                }

                if (this.selected) {
                    this.scene.remove(this.dragPlane);

                    SceneController.physics.remove('mouseJoint');

                    this.selected = null;

                    CameraController.enabled = true;
                }

                this.isDown = false;
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.targetXY.x = 1;
                } else {
                    this.targetXY.x = 2;
                }
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initPhysics();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // Shadows
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = BasicShadowMap;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.quad = new PlaneGeometry(1, 1);
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                light.castShadow = true;
                light.shadow.mapSize.width = 2048;
                light.shadow.mapSize.height = 2048;
                this.scene.add(light);

                this.light = light;
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initPhysics() {
                this.physics = new ScenePhysicsController();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initLoader();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await Promise.all([
                    SceneController.ready(),
                    this.loader.ready()
                ]);

                await WorldController.ready();

                this.initAudio();
                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();

                Thread.count--; // Make room for the physics thread
            }

            static initLoader() {
                this.loader = new BufferLoader();
                this.loader.setPath('../assets/sounds/');
                this.loader.loadAll(['gong.mp3']);
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera, physics } = WorldController;

                CameraController.init(camera);
                SceneController.init(physics, this.view);
                InputManager.init(scene, camera);
                RenderManager.init(renderer, scene, camera);
            }

            static initAudio() {
                const { scene, camera } = WorldController;

                WebAudio.init({ sampleRate: 48000 });
                WebAudio.load(this.loader.files);

                AudioController.init(scene, camera, this.view);
            }

            static initPanel() {
                const { physics } = WorldController;

                PanelController.init(physics, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_physics_picking.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Physics Picking — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BasicShadowMap, BloomCompositeMaterial, BoxGeometry, BufferLoader, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshPhongMaterial, MeshStandardMaterial, OimoPhysics, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, Raycaster, Reflector, RepeatWrapping, RigidBodyConfig, RigidBodyType, Scene, SceneCompositeDistortionMaterial, ShaderChunk, ShadowMaterial, Sound3D, SphereGeometry, SphericalJointConfig, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebAudio, WebGLRenderTarget, WebGLRenderer, delayedCall, getFullscreenTriangle, getKeyByValue, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const colors = {
            lightColor: 0xf44336
        };

        const layers = {
            default: 0,
            picking: 1
        };

        class Ball extends Group {
            constructor() {
                super();

                this.position.z = 1;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 0.9, 4.4, 0);
                this.add(light);
            }

            async initMesh() {
                const { physics } = WorldController;

                const geometry = new IcosahedronGeometry(0.075, 3);

                const material = new MeshPhongMaterial({
                    color: new Color(colors.lightColor).offsetHSL(0, 0, -0.3)
                });

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.7 };
                    shader.uniforms.thicknessPower = { value: 1 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * 0.8;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.layers.enable(layers.picking);
                this.add(mesh);

                // Physics
                physics.add(mesh, { autoSleep: false });
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class Cube extends Group {
            constructor() {
                super();

                // Physics
                this.force = new Vector3();
                this.contact = false;
            }

            async initMesh() {
                const { physics, anisotropy, loadTexture } = WorldController;

                const geometry = new BoxGeometry(0.5, 0.5, 0.5);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                normalMap.anisotropy = anisotropy;
                ormMap.anisotropy = anisotropy;
                thicknessMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu
                // Based on https://gist.github.com/mattdesl/2ee82157a86962347dedb6572142df7c

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 1 };
                    shader.uniforms.thicknessPower = { value: 20 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).r;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += material.diffuseColor * directLight.color * scatteringIllu * thicknessAttenuation;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.layers.enable(layers.picking);
                this.add(mesh);

                // Physics
                physics.add(mesh, {
                    autoSleep: false,
                    contactCallback: this.onContact
                });
            }

            // Event handlers

            onContact = (body/* , contact */) => {
                if (this.contact) {
                    return;
                }

                const linearVelocity = body.getLinearVelocity();
                const mass = body.getMass();

                this.force.addScaledVector(linearVelocity, mass);
                this.force.multiplyScalar(0.4);

                const force = this.force.length();

                if (force > 0.3) {
                    this.contact = true;

                    AudioController.trigger('gong', force);

                    delayedCall(250, () => {
                        this.contact = false;
                    });
                } else {
                    this.force.multiplyScalar(0);
                }
            };

            // Public methods

            ready = () => this.initMesh();
        }

        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class Floor extends Group {
            constructor() {
                super();

                this.position.y = -3.04;

                this.initReflector();
            }

            initReflector() {
                const { light } = WorldController;

                this.light = light;

                this.reflector = new Reflector({ blurIterations: 6 });
            }

            async initMesh() {
                const { physics, loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 6);

                const material = new ShadowMaterial({
                    toneMapped: false
                });

                material.onBeforeCompile = shader => {
                    map.updateMatrix();

                    shader.uniforms.map = { value: map };
                    shader.uniforms.reflectMap = { value: this.reflector.renderTarget.texture };
                    shader.uniforms.reflectMapBlur = this.reflector.renderTargetUniform;
                    shader.uniforms.uvTransform = { value: map.matrix };
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat3 uvTransform;
                        uniform mat4 textureMatrix;

                        out vec2 vUv;
                        out vec4 vCoord;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vUv = (uvTransform * vec3(uv, 1)).xy;
                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D map;
                        uniform sampler2D reflectMap;
                        uniform sampler2D reflectMapBlur;

                        in vec2 vUv;
                        in vec4 vCoord;

                        ${dither}

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );',
                        /* glsl */ `
                        vec2 reflectionUv = vCoord.xy / vCoord.w;

                        vec4 dudv = texture(map, vUv);
                        vec4 color = texture(reflectMap, reflectionUv);

                        vec4 blur;

                        blur = texture(reflectMapBlur, reflectionUv + dudv.rg / 256.0);
                        color = mix(color, blur, smoothstep(1.0, 0.1, dudv.g));

                        blur = texture(reflectMapBlur, reflectionUv);
                        color = mix(color, blur, smoothstep(0.5, 1.0, dudv.r));

                        gl_FragColor = color * mix(0.6, 0.75, dudv.g);

                        gl_FragColor.rgb -= (1.0 - getShadowMask()) * 0.025;

                        gl_FragColor.rgb = dither(gl_FragColor.rgb);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = 2.494; // 5 / 2 - 0.006
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.light.position.y *= -1;
                    this.reflector.update(renderer, scene, camera);
                    this.light.position.y *= -1;
                    this.visible = true;
                };

                this.add(mesh);

                // Physics mesh
                const floor = new Mesh(new BoxGeometry(100, 5, 100));
                floor.geometry.setDrawRange(0, 0); // Avoid rendering geometry
                this.add(floor);

                physics.add(floor, { density: 0, autoSleep: false });
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.cube = new Cube();
                this.add(this.cube);

                this.ball = new Ball();
                this.add(this.ball);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.cube.ready(),
                this.ball.ready()
            ]);
        }

        class SceneController {
            static init(physics, view) {
                this.physics = physics;
                this.view = view;

                this.enabled = true;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
                if (!this.enabled || !this.view.visible) {
                    return;
                }

                this.physics.step();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class AudioController {
            static init(scene, camera, view) {
                this.scene = scene;
                this.camera = camera;
                this.view = view;

                this.addListeners();
            }

            static addListeners() {
                document.addEventListener('visibilitychange', this.onVisibility);
                window.addEventListener('pointerdown', this.onPointerDown);
            }

            // Event handlers

            static onVisibility = () => {
                if (document.hidden) {
                    WebAudio.mute();
                } else {
                    WebAudio.unmute();
                }
            };

            static onPointerDown = () => {
                window.removeEventListener('pointerdown', this.onPointerDown);

                WebAudio.resume();
            };

            // Public methods

            static trigger = (event, force) => {
                switch (event) {
                    case 'gong': {
                        const gong = new Sound3D(this.camera, 'gong');
                        gong.position.copy(this.view.cube.position);
                        gong.quaternion.copy(this.view.cube.quaternion);
                        gong.updateMatrixWorld();

                        let mesh;

                        if (isDebug) {
                            mesh = new Mesh(
                                new SphereGeometry(0.0625),
                                new MeshPhongMaterial({ color: 0x0000ff })
                            );
                            mesh.material.depthTest = false;
                            mesh.material.depthWrite = false;
                            mesh.material.transparent = true;
                            mesh.position.copy(this.view.cube.position);
                            mesh.quaternion.copy(this.view.cube.quaternion);
                            mesh.updateMatrixWorld();
                            this.scene.add(mesh);
                        }

                        const strength = MathUtils.mapLinear(force, 0, 4, 0, 1);
                        gong.sound.gain.set(MathUtils.clamp(strength * 0.5, 0, 1));
                        gong.sound.playbackRate.set(MathUtils.clamp(0.8 + strength * 0.4, 0.8, 1.2));
                        gong.sound.play();

                        delayedCall(6000, () => {
                            gong.destroy();

                            if (mesh) {
                                this.scene.remove(mesh);
                                mesh.material.dispose();
                                mesh.geometry.dispose();
                                mesh = null;
                            }
                        });
                        break;
                    }
                }
            };
        }

        class PanelController {
            static init(physics, ui) {
                this.physics = physics;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const physics = this.physics;

                const vector3 = new Vector3();
                const gravity = this.physics.getGravity();

                const physicsOptions = {
                    Off: false,
                    Physics: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: physicsOptions,
                        value: getKeyByValue(physicsOptions, SceneController.enabled),
                        callback: value => {
                            SceneController.enabled = physicsOptions[value];

                            // Reset
                            vector3.set(0, 0, 0);

                            physics.objects.forEach(object => {
                                const { position, quaternion } = object;

                                physics.setPosition(object, position);
                                physics.setOrientation(object, quaternion);
                                physics.setLinearVelocity(object, vector3);
                                physics.setAngularVelocity(object, vector3);
                            });
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Gravity',
                        min: -10,
                        max: 10,
                        step: 0.1,
                        value: -gravity.y,
                        callback: value => {
                            gravity.y = -value;
                            physics.setGravity(gravity);
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class InputManager {
            static init(scene, camera, physics) {
                this.scene = scene;
                this.camera = camera;
                this.physics = physics;

                this.raycaster = new Raycaster();
                this.raycaster.layers.set(layers.picking);

                this.mouse = new Vector2();
                this.hover = null;
                this.selected = null;
                this.body = null;
                this.joint = null;
                this.isDown = false;
                this.enabled = true;

                this.initMesh();

                this.addListeners();
            }

            static initMesh() {
                const { quad } = WorldController;

                let material;

                if (isDebug) {
                    material = new MeshBasicMaterial({
                        color: 0xff0000,
                        wireframe: true
                    });
                } else {
                    material = new MeshBasicMaterial({ visible: false });
                }

                this.dragPlane = new Mesh(quad, material);
                this.dragPlane.scale.multiplyScalar(200);
                this.dragPlane.layers.enable(layers.picking);
            }

            static addListeners() {
                window.addEventListener('pointerdown', this.onPointerDown);
                window.addEventListener('pointermove', this.onPointerMove);
                window.addEventListener('pointerup', this.onPointerUp);
            }

            // Event handlers

            static onPointerDown = e => {
                if (!this.enabled) {
                    return;
                }

                this.isDown = true;

                this.onPointerMove(e);
            };

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;

                if (this.selected) {
                    this.raycaster.setFromCamera(this.mouse, this.camera);

                    const intersection = this.raycaster.intersectObject(this.dragPlane);

                    if (intersection.length) {
                        const point = intersection[0].point;

                        this.physics.setPosition(this.body, point);
                    }

                    return;
                }

                this.raycaster.setFromCamera(this.mouse, this.camera);

                const intersection = this.raycaster.intersectObjects(this.scene.children);

                if (intersection.length) {
                    let object = intersection[0].object;

                    if (object.parent.isGroup) {
                        object = object.parent;
                    }

                    if (this.isDown && this.selected !== object) {
                        const point = intersection[0].point;

                        const body = new RigidBodyConfig();
                        body.type = RigidBodyType.KINEMATIC;
                        body.position.copyFrom(point);
                        this.physics.add(body);

                        const joint = new SphericalJointConfig();
                        joint.rigidBody1 = this.physics.get(object);
                        joint.rigidBody2 = this.physics.get(body);
                        joint.rigidBody1.getLocalPointTo(point, joint.localAnchor1);
                        joint.rigidBody2.getLocalPointTo(point, joint.localAnchor2);
                        joint.springDamper.setSpring(4, 1); // frequency, dampingRatio
                        this.physics.add(joint);

                        this.selected = object;
                        this.body = body;
                        this.joint = joint;

                        this.dragPlane.position.copy(point);
                        this.dragPlane.quaternion.copy(this.camera.quaternion);

                        this.scene.add(this.dragPlane);

                        CameraController.enabled = false;

                        document.body.style.cursor = 'move';
                    } else if (this.hover !== object) {
                        this.hover = object;
                        document.body.style.cursor = 'pointer';
                    }
                } else if (this.hover) {
                    this.hover = null;
                    document.body.style.cursor = '';
                }
            };

            static onPointerUp = () => {
                if (!this.enabled) {
                    return;
                }

                if (this.selected) {
                    this.scene.remove(this.dragPlane);

                    this.physics.remove(this.joint);
                    this.physics.remove(this.body);

                    this.selected = null;

                    CameraController.enabled = true;
                }

                this.isDown = false;
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.targetXY.x = 1;
                } else {
                    this.targetXY.x = 2;
                }
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initPhysics();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // Shadows
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = BasicShadowMap;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.quad = new PlaneGeometry(1, 1);
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                light.castShadow = true;
                light.shadow.mapSize.width = 2048;
                light.shadow.mapSize.height = 2048;
                this.scene.add(light);

                this.light = light;
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initPhysics() {
                this.physics = new OimoPhysics();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initLoader();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await Promise.all([
                    SceneController.ready(),
                    this.loader.ready()
                ]);

                await WorldController.ready();

                this.initAudio();
                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initLoader() {
                this.loader = new BufferLoader();
                this.loader.setPath('../assets/sounds/');
                this.loader.loadAll(['gong.mp3']);
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera, physics } = WorldController;

                CameraController.init(camera);
                SceneController.init(physics, this.view);
                InputManager.init(scene, camera, physics);
                RenderManager.init(renderer, scene, camera);
            }

            static initAudio() {
                const { scene, camera } = WorldController;

                WebAudio.init({ sampleRate: 48000 });
                WebAudio.load(this.loader.files);

                AudioController.init(scene, camera, this.view);
            }

            static initPanel() {
                const { physics } = WorldController;

                PanelController.init(physics, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_polyhedron.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Polyhedron — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PointLight, PointLightHelper, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getViewSize, ticker, tween } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        class MouseLight extends Group {
            constructor() {
                super();

                this.position.z = 2;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(0xffffff, 0.9, 4.4, 0);
                this.add(light);

                if (isDebug) {
                    WorldController.scene.add(new PointLightHelper(light, 0.125));
                }
            }
        }

        class Polyhedron extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('polyhedron.json');

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                this.geometry = geometry;
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                // const material = new MeshBasicMaterial({ map });
                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 0.35,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1),
                    flatShading: true
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                this.material = material;
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.polyhedron = new Polyhedron();
                this.add(this.polyhedron);

                this.light = new MouseLight();
                this.add(this.light);
            }
        }

        class SceneController {
            static init(view) {
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.target = new Vector2();
                this.lightPosition = new Vector3();
                this.lerpSpeed = 0.25;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.target.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.target.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = () => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.light.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.lerp(this.target, this.lerpSpeed);

                this.lightPosition.x = this.mouse.x * this.halfWidth;
                this.lightPosition.y = this.mouse.y * this.halfHeight;
                this.lightPosition.z = this.view.light.position.z;

                this.view.light.position.copy(this.lightPosition);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.polyhedron.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.target = new Vector2();

                // Motion control
                this.group = new Group();
                this.innerGroup = new Group();
                this.group.add(this.innerGroup);
                this.group.matrixAutoUpdate = false;
                this.innerGroup.matrixAutoUpdate = false;

                // Start position
                this.innerGroup.position.copy(this.camera.position);

                this.rotation = 0.0002;
                this.lerpSpeed = 0.05;
                this.multiplier = 1;
                this.enabled = false;
                this.prevent = true;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (this.prevent) {
                    return;
                }

                this.mouse.x = clientX - this.halfWidth;
                this.mouse.y = clientY - this.halfHeight;

                this.target.x = MathUtils.degToRad(-360) + this.mouse.x * this.rotation * this.multiplier;
                this.target.y = this.mouse.y * this.rotation * this.multiplier;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                this.halfWidth = width / 2;
                this.halfHeight = height / 2;

                if (width < height) {
                    this.camera.position.z = 10;
                    this.multiplier = 2;
                } else {
                    this.camera.position.z = 8;
                    this.multiplier = 1;
                }

                this.innerGroup.position.z = this.camera.position.z;
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.group.rotation.x += (this.target.y - this.group.rotation.x) * this.lerpSpeed;
                this.group.rotation.y += (this.target.x - this.group.rotation.y) * this.lerpSpeed;

                this.updateCamera();
            };

            static updateCamera = () => {
                this.group.updateMatrix();
                this.innerGroup.updateMatrix();
                this.group.updateMatrixWorld();
                this.innerGroup.matrixWorld.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
            };

            static animateIn = () => {
                this.enabled = true;

                tween(this.target, { x: MathUtils.degToRad(-360) }, 4200, 'easeInOutQuart', () => {
                    this.prevent = false;
                });
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_ripple.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Ripple — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AssetLoader, Color, ColorManagement, DirectionalLight, Group, Interface, LinearFilter, LinearSRGBColorSpace, Mesh, MeshStandardMaterial, PanelItem, PerspectiveCamera, PlaneGeometry, Scene, Texture, UI, Vector2, WebGLRenderer, WireframeOptions, clearTween, delayedCall, getKeyByValue, getViewSize, ticker } from '../../build/alien.three.js';

        class GridCanvas extends Interface {
            constructor() {
                super(null, 'canvas');

                this.initCanvas();
                this.initGrid();
            }

            initCanvas() {
                this.context = this.element.getContext('2d');
            }

            initGrid() {
                this.grid = {
                    fillStyle: '#060606',
                    strokeStyle: '#fff'
                };
            }

            drawGrid() {
                this.context.fillStyle = this.grid.fillStyle;
                this.context.strokeStyle = this.grid.strokeStyle;

                this.context.fillRect(0, 0, this.width, this.height);
                this.context.beginPath();

                for (let x = 0; x < this.width; x += this.width / 10) {
                    this.context.moveTo(x, 0);
                    this.context.lineTo(x, this.height);
                }

                for (let y = 0; y < this.height; y += this.height / 10) {
                    this.context.moveTo(0, y);
                    this.context.lineTo(this.width, y);
                }

                this.context.stroke();
            }

            // Public methods

            resize = (width, height, dpr) => {
                this.width = width;
                this.height = height;

                this.element.width = Math.round(this.width * dpr);
                this.element.height = Math.round(this.height * dpr);
                this.context.scale(dpr, dpr);

                this.update();
            };

            update = () => {
                this.context.clearRect(0, 0, this.element.width, this.element.height);

                this.drawGrid();
            };
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.canvas = {};
                this.context = {};
                this.texture = {};
                this.image = {};
                this.ripples = [];
                this.multiplier = 1;
                this.needsUpdate = false;
                this.isLoaded = false;
                this.visible = false;

                this.initCanvas();
                this.initMesh();
            }

            initCanvas() {
                this.grid = new GridCanvas();
                this.createCanvas('displace');
                this.createCanvas('ripple');
            }

            initMesh() {
                this.material = new MeshStandardMaterial({
                    // wireframe: true,
                    displacementScale: 0.3,
                    depthTest: false,
                    depthWrite: false
                });

                this.mesh = new Mesh(new PlaneGeometry(1, 1, 64, 64), this.material);
                this.mesh.frustumCulled = false;
                this.add(this.mesh);
            }

            async initImages() {
                const now = Date.now();
                const svgHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024"><filter id="ripple_${now}"><feGaussianBlur in="SourceGraphic" stdDeviation="16"/></filter><g fill="none" filter="url(#ripple_${now})"><rect width="100%" height="100%"></rect><circle cx="512" cy="512" r="256" stroke="#fff" stroke-width="64"/></g></svg>`;

                await Promise.all([
                    this.loadImage('ripple', `data:image/svg+xml;base64,${btoa(svgHTML)}`)
                ]);

                this.isLoaded = true;

                this.resize();
            }

            async loadImage(name, path) {
                const image = await WorldController.loadImage(path);

                this.image[name] = image;

                return image;
            }

            createCanvas(name) {
                this.canvas[name] = document.createElement('canvas');
                this.context[name] = this.canvas[name].getContext('2d');
            }

            resizeCanvas(name, width, height, dpr) {
                this.canvas[name].width = Math.round(width * dpr);
                this.canvas[name].height = Math.round(height * dpr);
            }

            updateRipples() {
                const calc = (frame, min, max, total) => max * Math.sin(frame / total * (Math.PI / 2)) + min;
                let offset = 0;

                this.ripples.forEach((ripple, i) => {
                    if (ripple.frame++ >= 0) {
                        const frame = ripple.frame;

                        ripple.x = ripple.direction > 0 ? -0.5 + calc(frame, 0, 1, 260) : 1.5 - calc(frame, 0, 1, 260);
                        ripple.scale = 1.5 + calc(frame, 0, 12 * this.multiplier, 260);
                        ripple.alpha = frame > 200 ? 1 - calc(frame - 200, 0, 1, 60) : 1;

                        if (frame >= 260) {
                            this.ripples.splice(i - offset++, 1);

                            if (!this.ripples.length) {
                                this.needsUpdate = false;
                            }
                        }
                    }
                });
            }

            drawDisplace() {
                this.context.displace.fillRect(0, 0, this.canvas.displace.width, this.canvas.displace.height);

                this.updateRipples();

                this.ripples.forEach(ripple => {
                    const width = this.canvas.ripple.width * ripple.scale;
                    const height = this.canvas.ripple.height * ripple.scale;

                    this.context.displace.save();
                    this.context.displace.translate(this.canvas.displace.width * ripple.x, this.canvas.displace.height * ripple.y);
                    this.context.displace.transform(1, ripple.skew, 0, 1 + ripple.random, 0, 0);
                    this.context.displace.globalAlpha = ripple.alpha;
                    this.context.displace.drawImage(this.canvas.ripple, -width / 2, -height / 2, width, height);
                    this.context.displace.restore();
                });
            }

            // Public methods

            resize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                if (this.texture.grid) {
                    this.texture.grid.dispose();
                }

                if (this.texture.displace) {
                    this.texture.displace.dispose();
                }

                this.grid.resize(width, height, dpr);
                this.resizeCanvas('displace', width, height, dpr);
                this.resizeCanvas('ripple', 256, 256, dpr);

                this.texture.grid = new Texture(this.grid.element);
                this.texture.grid.minFilter = LinearFilter;
                this.texture.grid.generateMipmaps = false;
                this.texture.grid.needsUpdate = true;
                this.texture.displace = new Texture(this.canvas.displace);
                this.texture.displace.minFilter = LinearFilter;
                this.texture.displace.generateMipmaps = false;
                this.texture.displace.needsUpdate = true;

                this.material.map = this.texture.grid;
                // this.material.map = this.texture.displace;
                this.material.displacementMap = this.texture.displace;

                if (this.isLoaded) {
                    // Draws from a canvas are faster
                    this.context.ripple.drawImage(this.image.ripple, 0, 0, this.canvas.ripple.width, this.canvas.ripple.height);

                    this.update();
                }

                if (width < height) {
                    this.multiplier = 0.5;
                } else {
                    this.multiplier = 1;
                }

                this.material.displacementScale = 5 * this.multiplier;

                const { getViewSize } = WorldController;

                const { x, y } = getViewSize();
                this.mesh.scale.set(x, y, 1);
            };

            update = () => {
                if (!this.visible) {
                    return;
                }

                this.drawDisplace();

                this.texture.displace.needsUpdate = true;
            };

            addRipple = (direction = 1, skew = 0, frame = 0) => {
                this.ripples.push({
                    direction,
                    x: direction > 0 ? -0.5 : 1.5,
                    y: 0.5,
                    skew: 0.5 * Math.random() * skew,
                    scale: 1.5,
                    alpha: 1,
                    frame,
                    random: Math.random()
                });
            };

            wave = direction => {
                this.addRipple(direction, 1, 0);
                this.addRipple(direction, -1, 10 * Math.random() + 5);

                this.needsUpdate = true;
            };
        }

        class SceneController {
            static init(view) {
                this.view = view;

                this.mouse = new Vector2();
                this.last = new Vector2();
                this.delta = new Vector2();
                this.mouse.set(document.documentElement.clientWidth / 2, document.documentElement.clientHeight / 2);
                this.last.copy(this.mouse);

                this.timeout = false;

                this.addListeners();
                this.constantWaving();
            }

            static addListeners() {
                document.addEventListener('visibilitychange', this.onVisibility);
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onVisibility = () => {
                if (document.hidden) {
                    clearTween(this.constant);
                } else {
                    this.constantWaving();
                }
            };

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.set(clientX, clientY);
                this.delta.subVectors(this.mouse, this.last);
                this.last.copy(this.mouse);

                if (!this.timeout) {
                    this.timeout = true;

                    this.view.wave(Math.sign(this.delta.x));

                    delayedCall(2500, () => {
                        this.timeout = false;
                    });
                }
            };

            // Public methods

            static resize = () => {
                this.view.resize();
            };

            static update = () => {
                if (this.view.needsUpdate) {
                    this.view.update();
                }
            };

            static constantWaving = () => {
                this.view.wave(1);

                this.constant = delayedCall(1000 + Math.random() * 1000, this.constantWaving);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.initImages();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { mesh } = this.view;

                const currentMaterialMap = mesh.material.map;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: WireframeOptions,
                        value: getKeyByValue(WireframeOptions, mesh.material.wireframe),
                        callback: value => {
                            mesh.material.wireframe = WireframeOptions[value];

                            if (mesh.material.wireframe) {
                                mesh.material.map = null;
                            } else {
                                mesh.material.map = currentMaterialMap;
                            }

                            mesh.material.needsUpdate = true;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(25);
                this.camera.near = 0.1;
                this.camera.far = 1000;
                this.camera.position.z = 100;
                this.camera.lookAt(this.scene.position);

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                const light = new DirectionalLight(0xffffff, 3);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.assetLoader = new AssetLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static loadImage = path => this.assetLoader.loadImage(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                SceneController.animateIn();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({
                    fps: true,
                    thumbnail: {
                        image: this.view.canvas.displace,
                        position: 'bl' // tl, bl, br, tr
                    }
                });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_spherical_cube_uv.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Cubemap UV — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BasicMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, Group, ImageBitmapLoaderThread, LinearSRGBColorSpace, Mesh, OrbitControls, PerspectiveCamera, Scene, TextureLoader, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class Cube extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('spherical_cube.json');

                // Use second set of UVs for cubemap row layout
                // https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Cubemaps/CreatingCubemaps/
                geometry.attributes.uv = geometry.attributes.uv1;

                this.geometry = geometry;
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                const map = await loadTexture('cubemap.jpg');
                map.anisotropy = anisotropy;

                this.material = new BasicMaterial({ map });
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.cube = new Cube();
                this.add(this.cube);
            }

            // Public methods

            animateIn = () => {
                this.visible = true;
            };

            ready = () => Promise.all([
                this.cube.ready()
            ]);
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLoaders();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await this.view.ready();
                this.view.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/3d_stripe_gradient.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>3D Stripe Gradient — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        :root {
            --gradient-color-1: white;
            --gradient-color-2: gainsboro;
            --gradient-color-3: lightgray;
            --gradient-color-4: silver;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --gradient-color-1: black;
                --gradient-color-2: dimgray;
                --gradient-color-3: gray;
                --gradient-color-4: darkgray;
            }
        }
    </style>

    <script type="module">
        import { Color, ColorManagement, GLSL3, Group, LinearSRGBColorSpace, Mesh, OrthographicCamera, PanelItem, PlaneGeometry, RawShaderMaterial, Scene, UI, Vector2, WebGLRenderer, WireframeOptions, getKeyByValue, ticker } from '../../build/alien.three.js';

        // Based on https://www.youtube.com/watch?v=LW9d2cqIHb4 by akella

        import simplex3d from '../../src/shaders/modules/noise/simplex3d.glsl.js';

        class GradientMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        uColor: { value: [new Color(), new Color(), new Color(), new Color()] },
                        uTime: { value: 0 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec3 normal;
                        in vec2 uv;

                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;

                        uniform vec3 uColor[4];
                        uniform float uTime;

                        out vec3 vColor;

                        ${simplex3d}

                        void main() {
                            vec2 noiseCoord = uv * vec2(3, 4);

                            float tilt = -0.05 * uv.y;

                            float offset = 0.5 * mix(-0.25, 0.25, uv.y);

                            float noise = snoise(vec3(noiseCoord.x + uTime * 0.1, noiseCoord.y, uTime * 0.2));

                            noise = max(0.0, noise);

                            vec3 pos = vec3(position.x, position.y + noise * 0.1 + tilt + offset, position.z);

                            vColor = uColor[0];

                            for (int i = 1; i < 4; i++) {
                                float noiseFlow = 0.1;
                                float noiseSpeed = 0.2;

                                float noiseSeed = 1.0 + float(i) * 10.0;
                                vec2 noiseFreq = vec2(1.0, 1.4) * 0.4;

                                float noiseFloor = 0.0;
                                float noiseCeil = 1.0;

                                float noise = smoothstep(noiseFloor, noiseCeil,
                                    snoise(
                                        vec3(
                                            noiseCoord.x * noiseFreq.x + uTime * noiseFlow,
                                            noiseCoord.y * noiseFreq.y,
                                            uTime * noiseSpeed + noiseSeed
                                        )
                                    )
                                );

                                vColor = mix(vColor, uColor[i], noise);
                            }

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        in vec3 vColor;

                        out vec4 FragColor;

                        void main() {
                            FragColor = vec4(vColor, 1.0);
                        }
                    `,
                    // wireframe: true,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const geometry = new PlaneGeometry(1, 1, 96, 96);

                const material = new GradientMaterial();

                this.mesh = new Mesh(geometry, material);
                this.mesh.frustumCulled = false;
                this.add(this.mesh);
            }

            // Public methods

            theme = () => {
                const rootStyle = getComputedStyle(document.querySelector(':root'));

                this.mesh.material.uniforms.uColor.value[0].set(rootStyle.getPropertyValue('--gradient-color-1').trim());
                this.mesh.material.uniforms.uColor.value[1].set(rootStyle.getPropertyValue('--gradient-color-2').trim());
                this.mesh.material.uniforms.uColor.value[2].set(rootStyle.getPropertyValue('--gradient-color-3').trim());
                this.mesh.material.uniforms.uColor.value[3].set(rootStyle.getPropertyValue('--gradient-color-4').trim());
            };

            resize = (width, height) => {
                this.mesh.scale.set(width, height, 1);
            };

            update = time => {
                this.mesh.material.uniforms.uTime.value = time;
            };

            ready = () => Promise.all([
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static theme = () => {
                this.view.theme();
            };

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = time => {
                this.view.update(time);
            };

            static animateIn = () => {
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { mesh } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'color',
                        value: mesh.material.uniforms.uColor.value[0],
                        callback: value => {
                            mesh.material.uniforms.uColor.value[0].copy(value);
                        }
                    },
                    {
                        type: 'color',
                        value: mesh.material.uniforms.uColor.value[1],
                        callback: value => {
                            mesh.material.uniforms.uColor.value[1].copy(value);
                        }
                    },
                    {
                        type: 'color',
                        value: mesh.material.uniforms.uColor.value[2],
                        callback: value => {
                            mesh.material.uniforms.uColor.value[2].copy(value);
                        }
                    },
                    {
                        type: 'color',
                        value: mesh.material.uniforms.uColor.value[3],
                        callback: value => {
                            mesh.material.uniforms.uColor.value[3].copy(value);
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: WireframeOptions,
                        value: getKeyByValue(WireframeOptions, mesh.material.wireframe),
                        callback: value => {
                            mesh.material.wireframe = WireframeOptions[value];
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 2D scene
                this.scene = new Scene();
                this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.left = -width / 2;
                this.camera.right = width / 2;
                this.camera.top = height / 2;
                this.camera.bottom = -height / 2;
                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onTheme();
                this.onResize();

                await SceneController.ready();
                SceneController.animateIn();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', this.onTheme);
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onTheme = () => {
                SceneController.theme();
            };

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update(time);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_afterimage.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Afterimage Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AfterimageMaterial, BloomCompositeMaterial, BufferAttribute, BufferGeometry, Color, ColorManagement, DirectionalLight, Fog, Group, HemisphereLight, LinearFilter, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Reflector, RepeatWrapping, Scene, SceneCompositeMaterial, Text, TextMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getDoubleRenderTarget, getFullscreenTriangle, getKeyByValue, ticker } from '../../build/alien.three.js';

        class Text2D extends Group {
            constructor() {
                super();

                this.count = 0;
                this.time = 0;
                this.prev = 0;
                this.fps = 0;
            }

            async initMesh() {
                const { loadTexture, camera } = WorldController;

                const map = await loadTexture('fonts/Roboto-Bold.png');
                map.minFilter = LinearFilter;
                map.generateMipmaps = false;

                const material = new TextMaterial({ map });
                material.uniforms.uAlpha.value = 0.94;

                const font = await (await fetch('../assets/textures/fonts/Roboto-Bold.json')).json();

                const text = new Text({
                    font,
                    text: this.fps.toString(),
                    width: 4,
                    align: 'center',
                    letterSpacing: -0.05,
                    size: 2,
                    lineHeight: 1.1
                });

                const geometry = new BufferGeometry();

                const mesh = new Mesh(geometry, material);
                mesh.frustumCulled = false;
                mesh.position.set(0, 1.4, -11);
                mesh.lookAt(camera.position);

                this.add(mesh);

                this.text = text;
                this.geometry = geometry;

                this.update();
            }

            // Public methods

            update = () => {
                this.time = performance.now();

                if (this.time - 1000 > this.prev) {
                    this.prev = this.time;
                    this.fps = this.count;
                    this.count = 0;
                }

                this.count++;

                this.text.update({ text: this.fps.toString() });

                this.geometry.setAttribute('position', new BufferAttribute(this.text.buffers.position, 3));
                this.geometry.setAttribute('uv', new BufferAttribute(this.text.buffers.uv, 2));
                this.geometry.setAttribute('id', new BufferAttribute(this.text.buffers.id, 1));
                this.geometry.setIndex(new BufferAttribute(this.text.buffers.index, 1));
            };

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/polished_concrete_basecolor.jpg'),
                    loadTexture('pbr/polished_concrete_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/polished_concrete_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const uniforms = {
                    mirror: { value: 0 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture2D(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.text = new Text2D();
                this.add(this.text);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.text.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.view.text.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { afterimageMaterial, luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const postOptions = {
                    Off: false,
                    Post: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: value => {
                            RenderManager.enabled = postOptions[value];
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Damping',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: afterimageMaterial.uniforms.uDamping.value,
                        callback: value => {
                            afterimageMaterial.uniforms.uDamping.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Afterimage
                this.afterimageDamping = 0.96;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.afterimage = getDoubleRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Afterimage material
                this.afterimageMaterial = new AfterimageMaterial();
                this.afterimageMaterial.uniforms.uDamping.value = this.afterimageDamping;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.afterimage.setSize(width, height);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Afterimage pass
                this.afterimageMaterial.uniforms.tOld.value = this.afterimage.read.texture;
                this.afterimageMaterial.uniforms.tNew.value = renderTarget.texture;
                this.screen.material = this.afterimageMaterial;
                renderer.setRenderTarget(this.afterimage.write);
                renderer.render(this.screen, this.screenCamera);
                this.afterimage.swap();

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = this.afterimage.read.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = this.afterimage.read.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_anamorphic_light_lensflare.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Fast Anamorphic Light Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BlurMaterial, Color, ColorManagement, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PointLight, RepeatWrapping, Scene, SceneCompositeAddMaterial, ShaderChunk, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, VolumetricLightLensflareMaterial, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getViewSize, ticker } from '../../build/alien.three.js';

        const colors = {
            lightColor: 0xf44336
        };

        const layers = {
            default: 0,
            occlusion: 1
        };

        class Ball extends Group {
            constructor() {
                super();

                this.position.z = -1;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 1.9, 2.2, 0);
                this.add(light);
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.25, 6);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(colors.lightColor),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.2 };
                    shader.uniforms.thicknessPower = { value: 2 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                // Occlusion mesh
                const occMesh = mesh.clone();
                occMesh.material = new MeshBasicMaterial({
                    color: new Color(colors.lightColor).multiply(new Color(0.55, 0.55, 1)) // Blue tint
                });
                occMesh.layers.set(layers.occlusion);
                this.add(occMesh);
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class Sphere extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.5, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu
                // Based on https://gist.github.com/mattdesl/2ee82157a86962347dedb6572142df7c

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.185 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 1 },
                    thicknessPower: { value: 20 },
                    thicknessScale: { value: 16 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).r;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += material.diffuseColor * directLight.color * scatteringIllu * thicknessAttenuation;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.uniforms = uniforms;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.sphere = new Sphere();
                this.add(this.sphere);

                this.ball = new Ball();
                this.add(this.ball);
            }

            // Public methods

            ready = () => Promise.all([
                this.sphere.ready(),
                this.ball.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.target = new Vector2();
                this.lightPosition = new Vector3();
                this.lerpSpeed = 0.25;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.target.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.target.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = () => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.ball.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.lerp(this.target, this.lerpSpeed);

                this.lightPosition.x = this.mouse.x * this.halfWidth;
                this.lightPosition.y = this.mouse.y * this.halfHeight;
                this.lightPosition.z = this.view.ball.position.z;

                this.view.ball.position.copy(this.lightPosition);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { vlMaterial, luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const { sphere } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Scale X',
                        min: -2,
                        max: 2,
                        step: 0.01,
                        value: vlMaterial.uniforms.uScale.value.x,
                        callback: value => {
                            vlMaterial.uniforms.uScale.value.x = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale Y',
                        min: -2,
                        max: 2,
                        step: 0.01,
                        value: vlMaterial.uniforms.uScale.value.y,
                        callback: value => {
                            vlMaterial.uniforms.uScale.value.y = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Swizzle',
                        min: -2,
                        max: 2,
                        step: 0.01,
                        value: vlMaterial.uniforms.uSwizzle.value,
                        callback: value => {
                            vlMaterial.uniforms.uSwizzle.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Decay',
                        min: 0.6,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDecay.value,
                        callback: value => {
                            vlMaterial.uniforms.uDecay.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDensity.value,
                        callback: value => {
                            vlMaterial.uniforms.uDensity.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Weight',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uWeight.value,
                        callback: value => {
                            vlMaterial.uniforms.uWeight.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Scale X',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: vlMaterial.uniforms.uLensflareScale.value.x,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareScale.value.x = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale Y',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: vlMaterial.uniforms.uLensflareScale.value.y,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareScale.value.y = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uLensflareExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uLensflareClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: sphere.uniforms.thicknessDistortion.value,
                        callback: value => {
                            sphere.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAmbient.value,
                        callback: value => {
                            sphere.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            sphere.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: sphere.uniforms.thicknessPower.value,
                        callback: value => {
                            sphere.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: sphere.uniforms.thicknessScale.value,
                        callback: value => {
                            sphere.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, view) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;

                // Volumetric light and lens flare
                this.lightPosition = new Vector3();
                this.vlScale = new Vector2(1, -2);
                this.vlSwizzle = 0;
                this.vlExposure = 0.15;
                this.vlDecay = 1;
                this.vlDensity = 1;
                this.vlWeight = 0.4;
                this.vlClamp = 1;
                this.lensflareScale = new Vector2(1.5, 1.5);
                this.lensflareExposure = 1;
                this.lensflareClamp = 1;
                this.blurResolutionScale = 0.25;
                this.blurAmount = 2.5;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Clear colors
                this.clearColor = new Color(0, 0, 0);
                this.currentClearColor = new Color();

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBlurA = this.renderTarget.clone();
                this.renderTargetBlurB = this.renderTarget.clone();

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;
                this.renderTargetBlurA.depthBuffer = true;

                // Occlusion material
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Volumetric light material
                this.vlMaterial = new VolumetricLightLensflareMaterial();
                this.vlMaterial.uniforms.uScale.value = this.vlScale;
                this.vlMaterial.uniforms.uSwizzle.value = this.vlSwizzle;
                this.vlMaterial.uniforms.uExposure.value = this.vlExposure;
                this.vlMaterial.uniforms.uDecay.value = this.vlDecay;
                this.vlMaterial.uniforms.uDensity.value = this.vlDensity;
                this.vlMaterial.uniforms.uWeight.value = this.vlWeight;
                this.vlMaterial.uniforms.uClamp.value = this.vlClamp;
                this.vlMaterial.uniforms.uLensflareScale.value = this.lensflareScale;
                this.vlMaterial.uniforms.uLensflareExposure.value = this.lensflareExposure;
                this.vlMaterial.uniforms.uLensflareClamp.value = this.lensflareClamp;
                this.vlMaterial.uniforms.uResolution = resolution;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeAddMaterial({ dithering: true });
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static setLightPosition() {
                this.lightPosition.copy(this.view.ball.position).project(this.camera);

                const x = (this.lightPosition.x + 1) / 2;
                const y = (this.lightPosition.y + 1) / 2;

                this.vlMaterial.uniforms.uLightPosition.value.set(x, y);
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Gaussian blur
                const blurWidth = Math.round(width * this.blurResolutionScale);
                const blurHeight = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(blurWidth, blurHeight);
                this.renderTargetBlurB.setSize(blurWidth, blurHeight);

                this.hBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);
                this.vBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Renderer state
                const currentOverrideMaterial = scene.overrideMaterial;
                const currentBackground = scene.background;
                renderer.getClearColor(this.currentClearColor);
                const currentClearAlpha = renderer.getClearAlpha();

                // Scene layer
                camera.layers.set(layers.default);

                renderer.setRenderTarget(renderTarget);
                renderer.clear();
                renderer.render(scene, camera);

                // Occlusion layer
                scene.background = null;
                renderer.setClearColor(this.clearColor, 1);

                scene.overrideMaterial = this.blackoutMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = currentOverrideMaterial;

                camera.layers.set(layers.occlusion);

                renderer.render(scene, camera);

                // Restore renderer settings
                scene.background = currentBackground;
                renderer.setClearColor(this.currentClearColor, currentClearAlpha);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Volumetric light pass
                this.vlMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.setLightPosition();
                this.screen.material = this.vlMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.compositeMaterial.uniforms.tAdd.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera, this.view);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_anamorphic_light.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Fast Anamorphic Light Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BlurMaterial, Color, ColorManagement, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PointLight, RepeatWrapping, Scene, SceneCompositeAddMaterial, ShaderChunk, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, VolumetricLightMaterial, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        const colors = {
            lightColor: 0xf44336
        };

        const layers = {
            default: 0,
            occlusion: 1
        };

        class Ball extends Group {
            constructor() {
                super();

                this.frameRotation = 0;
                this.position.x = 1;
                this.position.z = 1;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 1.9, 2.2, 0);
                this.add(light);
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.25, 6);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(colors.lightColor),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.2 };
                    shader.uniforms.thicknessPower = { value: 2 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                // Occlusion mesh
                const occMesh = mesh.clone();
                occMesh.material = new MeshBasicMaterial({
                    color: new Color(colors.lightColor).multiply(new Color(0.55, 0.55, 1)) // Blue tint
                });
                occMesh.layers.set(layers.occlusion);
                this.add(occMesh);
            }

            // Public methods

            update = () => {
                this.frameRotation += 0.01;
                this.position.x = 1 * Math.sin(this.frameRotation);
                this.position.z = 1 * Math.cos(this.frameRotation);
            };

            ready = () => this.initMesh();
        }

        class Sphere extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.5, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu
                // Based on https://gist.github.com/mattdesl/2ee82157a86962347dedb6572142df7c

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.185 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 1 },
                    thicknessPower: { value: 20 },
                    thicknessScale: { value: 16 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).r;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += material.diffuseColor * directLight.color * scatteringIllu * thicknessAttenuation;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.uniforms = uniforms;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.sphere = new Sphere();
                this.add(this.sphere);

                this.ball = new Ball();
                this.add(this.ball);
            }

            // Public methods

            update = () => {
                this.ball.update();
            };

            ready = () => Promise.all([
                this.sphere.ready(),
                this.ball.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { vlMaterial, luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const { sphere } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Scale X',
                        min: -2,
                        max: 2,
                        step: 0.01,
                        value: vlMaterial.uniforms.uScale.value.x,
                        callback: value => {
                            vlMaterial.uniforms.uScale.value.x = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale Y',
                        min: -2,
                        max: 2,
                        step: 0.01,
                        value: vlMaterial.uniforms.uScale.value.y,
                        callback: value => {
                            vlMaterial.uniforms.uScale.value.y = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Swizzle',
                        min: -2,
                        max: 2,
                        step: 0.01,
                        value: vlMaterial.uniforms.uSwizzle.value,
                        callback: value => {
                            vlMaterial.uniforms.uSwizzle.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Decay',
                        min: 0.6,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDecay.value,
                        callback: value => {
                            vlMaterial.uniforms.uDecay.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDensity.value,
                        callback: value => {
                            vlMaterial.uniforms.uDensity.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Weight',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uWeight.value,
                        callback: value => {
                            vlMaterial.uniforms.uWeight.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: sphere.uniforms.thicknessDistortion.value,
                        callback: value => {
                            sphere.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAmbient.value,
                        callback: value => {
                            sphere.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            sphere.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: sphere.uniforms.thicknessPower.value,
                        callback: value => {
                            sphere.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: sphere.uniforms.thicknessScale.value,
                        callback: value => {
                            sphere.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, view) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;

                // Volumetric light
                this.lightPosition = new Vector3();
                this.vlScale = new Vector2(1, -2);
                this.vlSwizzle = 0;
                this.vlExposure = 0.15;
                this.vlDecay = 1;
                this.vlDensity = 1;
                this.vlWeight = 0.4;
                this.vlClamp = 1;
                this.blurResolutionScale = 0.25;
                this.blurAmount = 2.5;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Clear colors
                this.clearColor = new Color(0, 0, 0);
                this.currentClearColor = new Color();

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBlurA = this.renderTarget.clone();
                this.renderTargetBlurB = this.renderTarget.clone();

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;
                this.renderTargetBlurA.depthBuffer = true;

                // Occlusion material
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Volumetric light material
                this.vlMaterial = new VolumetricLightMaterial();
                this.vlMaterial.uniforms.uScale.value = this.vlScale;
                this.vlMaterial.uniforms.uSwizzle.value = this.vlSwizzle;
                this.vlMaterial.uniforms.uExposure.value = this.vlExposure;
                this.vlMaterial.uniforms.uDecay.value = this.vlDecay;
                this.vlMaterial.uniforms.uDensity.value = this.vlDensity;
                this.vlMaterial.uniforms.uWeight.value = this.vlWeight;
                this.vlMaterial.uniforms.uClamp.value = this.vlClamp;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeAddMaterial({ dithering: true });
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static setLightPosition() {
                this.lightPosition.copy(this.view.ball.position).project(this.camera);

                const x = (this.lightPosition.x + 1) / 2;
                const y = (this.lightPosition.y + 1) / 2;

                this.vlMaterial.uniforms.uLightPosition.value.set(x, y);
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Gaussian blur
                const blurWidth = Math.round(width * this.blurResolutionScale);
                const blurHeight = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(blurWidth, blurHeight);
                this.renderTargetBlurB.setSize(blurWidth, blurHeight);

                this.hBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);
                this.vBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Renderer state
                const currentOverrideMaterial = scene.overrideMaterial;
                const currentBackground = scene.background;
                renderer.getClearColor(this.currentClearColor);
                const currentClearAlpha = renderer.getClearAlpha();

                // Scene layer
                camera.layers.set(layers.default);

                renderer.setRenderTarget(renderTarget);
                renderer.clear();
                renderer.render(scene, camera);

                // Occlusion layer
                scene.background = null;
                renderer.setClearColor(this.clearColor, 1);

                scene.overrideMaterial = this.blackoutMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = currentOverrideMaterial;

                camera.layers.set(layers.occlusion);

                renderer.render(scene, camera);

                // Restore renderer settings
                scene.background = currentBackground;
                renderer.setClearColor(this.currentClearColor, currentClearAlpha);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Volumetric light pass
                this.vlMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.setLightPosition();
                this.screen.material = this.vlMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.compositeMaterial.uniforms.tAdd.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera, this.view);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_baked_abstract_cube_dudv.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Baked Shadow Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        :root {
            --bg-color: #fff;
            --ui-color: #000;
            --ui-color-triplet: 0 0 0;
        }
    </style>

    <script type="module">
        import { BasicMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, Group, ImageBitmapLoaderThread, LinearSRGBColorSpace, Mesh, OrbitControls, PerspectiveCamera, PlaneGeometry, Reflector, ReflectorDudvMaterial, RepeatWrapping, Scene, TextureLoader, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class AbstractCube extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('abstract_cube.json');

                // Use second set of UVs for cubemap row layout
                // https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Cubemaps/CreatingCubemaps/
                geometry.attributes.uv = geometry.attributes.uv1;

                this.geometry = geometry;
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // const map = await loadTexture('cubemap.jpg');
                const map = await loadTexture('abstract_cube/abstract_cube_basecolor.jpg');
                map.anisotropy = anisotropy;

                this.material = new BasicMaterial({ map });
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 3);

                const material = new ReflectorDudvMaterial({
                    map,
                    reflectivity: 0.5
                });
                material.uniforms.tReflect = { value: this.reflector.renderTarget.texture };
                material.uniforms.tReflectBlur = this.reflector.renderTargetUniform;
                material.uniforms.uMatrix = this.reflector.textureMatrixUniform;

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -0.86;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.abstractCube = new AbstractCube();
                this.add(this.abstractCube);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.abstractCube.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLoaders();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0xffffff);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update();
                RenderManager.update(time, delta, frame);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_baked_abstract_cube_sss.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Baked Subsurface Scattering Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, EnvironmentTextureLoader, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, PointLightHelper, Reflector, ReflectorDudvMaterial, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, ShaderChunk, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getViewSize, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const colors = {
            lightColor: 0xf44336
        };

        class MouseLight extends Group {
            constructor() {
                super();

                this.position.z = -0.7;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 0.9, 4.4, 0);
                this.add(light);

                if (isDebug) {
                    WorldController.scene.add(new PointLightHelper(light, 0.125));
                }
            }
        }

        class AbstractCube extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                this.geometry = await loadBufferGeometry('abstract_cube.json');
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('abstract_cube/abstract_cube_thickness.jpg')
                ]);

                map.anisotropy = anisotropy;
                normalMap.anisotropy = anisotropy;
                ormMap.anisotropy = anisotropy;
                thicknessMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3),
                    flatShading: true
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.1 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 0.7 },
                    thicknessPower: { value: 1 },
                    thicknessScale: { value: 16 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                this.material = material;
                this.uniforms = uniforms;
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector({ blurIterations: 6 });
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 6);

                const material = new ReflectorDudvMaterial({
                    map,
                    reflectivity: 0.5
                });
                material.uniforms.tReflect = { value: this.reflector.renderTarget.texture };
                material.uniforms.tReflectBlur = this.reflector.renderTargetUniform;
                material.uniforms.uMatrix = this.reflector.textureMatrixUniform;

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -0.86;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.abstractCube = new AbstractCube();
                this.add(this.abstractCube);

                this.light = new MouseLight();
                this.add(this.light);
            }

            // Public methods

            ready = () => Promise.all([
                this.floor.ready(),
                this.abstractCube.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.target = new Vector2();
                this.lightPosition = new Vector3();
                this.lerpSpeed = 0.25;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.target.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.target.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.view.floor.resize(width, height);

                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.light.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.lerp(this.target, this.lerpSpeed);

                this.lightPosition.x = this.mouse.x * this.halfWidth;
                this.lightPosition.y = this.mouse.y * this.halfHeight;
                this.lightPosition.z = this.view.light.position.z;

                this.view.light.position.copy(this.lightPosition);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { abstractCube } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: abstractCube.uniforms.thicknessDistortion.value,
                        callback: value => {
                            abstractCube.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: abstractCube.uniforms.thicknessAmbient.value,
                        callback: value => {
                            abstractCube.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: abstractCube.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            abstractCube.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: abstractCube.uniforms.thicknessPower.value,
                        callback: value => {
                            abstractCube.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: abstractCube.uniforms.thicknessScale.value,
                        callback: value => {
                            abstractCube.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_baked_abstract_cube.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Baked Shadow Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        :root {
            --bg-color: #fff;
            --ui-color: #000;
            --ui-color-triplet: 0 0 0;
        }
    </style>

    <script type="module">
        import { BasicMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, DoubleSide, Group, ImageBitmapLoaderThread, LinearSRGBColorSpace, Mesh, OrbitControls, PerspectiveCamera, Scene, ShadowTextureMaterial, TextureLoader, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class AbstractCube extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('abstract_cube.json');

                // Use second set of UVs for cubemap row layout
                // https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Cubemaps/CreatingCubemaps/
                geometry.attributes.uv = geometry.attributes.uv1;

                this.geometry = geometry;
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // const map = await loadTexture('cubemap.jpg');
                const map = await loadTexture('abstract_cube/abstract_cube_basecolor.jpg');
                map.anisotropy = anisotropy;

                this.material = new BasicMaterial({ map });
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        // Based on https://oframe.github.io/ogl/examples/?src=skinning.html by gordonnl

        class Floor extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                this.geometry = await loadBufferGeometry('floor.json');
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // const map = await loadTexture('uv.jpg');
                const map = await loadTexture('abstract_cube/abstract_cube_shadow.jpg');
                map.anisotropy = anisotropy;

                this.material = new ShadowTextureMaterial({ map });
                this.material.side = DoubleSide;
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                mesh.position.y = -0.86;
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.abstractCube = new AbstractCube();
                this.add(this.abstractCube);
            }

            // Public methods

            animateIn = () => {
                this.visible = true;
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.abstractCube.ready()
            ]);
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLoaders();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0xffffff);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await this.view.ready();
                this.view.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_baked_cube_dudv.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Baked Shadow Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        :root {
            --bg-color: #fff;
            --ui-color: #000;
            --ui-color-triplet: 0 0 0;
        }
    </style>

    <script type="module">
        import { BasicMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, Group, ImageBitmapLoaderThread, LinearSRGBColorSpace, Mesh, OrbitControls, PerspectiveCamera, PlaneGeometry, Reflector, ReflectorDudvMaterial, RepeatWrapping, Scene, TextureLoader, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class Cube extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('cube.json');

                // Use second set of UVs for cubemap row layout
                // https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Cubemaps/CreatingCubemaps/
                geometry.attributes.uv = geometry.attributes.uv1;

                this.geometry = geometry;
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // const map = await loadTexture('cubemap.jpg');
                const map = await loadTexture('cube/cube_basecolor.jpg');
                map.anisotropy = anisotropy;

                this.material = new BasicMaterial({ map });
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 3);

                const material = new ReflectorDudvMaterial({
                    map,
                    reflectivity: 0.5
                });
                material.uniforms.tReflect = { value: this.reflector.renderTarget.texture };
                material.uniforms.tReflectBlur = this.reflector.renderTargetUniform;
                material.uniforms.uMatrix = this.reflector.textureMatrixUniform;

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -0.54;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.cube = new Cube();
                this.add(this.cube);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.cube.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLoaders();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0xffffff);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update();
                RenderManager.update(time, delta, frame);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_baked_cube_sss.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Baked Subsurface Scattering Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, EnvironmentTextureLoader, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, PointLightHelper, Reflector, ReflectorDudvMaterial, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, ShaderChunk, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getViewSize, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const colors = {
            lightColor: 0xf44336
        };

        class MouseLight extends Group {
            constructor() {
                super();

                this.position.z = 0;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 0.9, 4.4, 0);
                this.add(light);

                if (isDebug) {
                    WorldController.scene.add(new PointLightHelper(light, 0.125));
                }
            }
        }

        class Cube extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                this.geometry = await loadBufferGeometry('cube.json');
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('cube/cube_thickness.jpg')
                ]);

                map.anisotropy = anisotropy;
                normalMap.anisotropy = anisotropy;
                ormMap.anisotropy = anisotropy;
                thicknessMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3),
                    flatShading: true
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.1 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 0.7 },
                    thicknessPower: { value: 1 },
                    thicknessScale: { value: 16 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                this.material = material;
                this.uniforms = uniforms;
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector({ blurIterations: 6 });
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 6);

                const material = new ReflectorDudvMaterial({
                    map,
                    reflectivity: 0.5
                });
                material.uniforms.tReflect = { value: this.reflector.renderTarget.texture };
                material.uniforms.tReflectBlur = this.reflector.renderTargetUniform;
                material.uniforms.uMatrix = this.reflector.textureMatrixUniform;

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -0.54;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.cube = new Cube();
                this.add(this.cube);

                this.light = new MouseLight();
                this.add(this.light);
            }

            // Public methods

            ready = () => Promise.all([
                this.floor.ready(),
                this.cube.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.target = new Vector2();
                this.lightPosition = new Vector3();
                this.lerpSpeed = 0.25;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.target.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.target.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.view.floor.resize(width, height);

                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.light.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.lerp(this.target, this.lerpSpeed);

                this.lightPosition.x = this.mouse.x * this.halfWidth;
                this.lightPosition.y = this.mouse.y * this.halfHeight;
                this.lightPosition.z = this.view.light.position.z;

                this.view.light.position.copy(this.lightPosition);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { cube } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: cube.uniforms.thicknessDistortion.value,
                        callback: value => {
                            cube.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: cube.uniforms.thicknessAmbient.value,
                        callback: value => {
                            cube.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: cube.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            cube.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: cube.uniforms.thicknessPower.value,
                        callback: value => {
                            cube.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: cube.uniforms.thicknessScale.value,
                        callback: value => {
                            cube.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_baked_cube.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Baked Shadow Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        :root {
            --bg-color: #fff;
            --ui-color: #000;
            --ui-color-triplet: 0 0 0;
        }
    </style>

    <script type="module">
        import { BasicMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, DoubleSide, Group, ImageBitmapLoaderThread, LinearSRGBColorSpace, Mesh, OrbitControls, PerspectiveCamera, Scene, ShadowTextureMaterial, TextureLoader, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class Cube extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('cube.json');

                // Use second set of UVs for cubemap row layout
                // https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Cubemaps/CreatingCubemaps/
                geometry.attributes.uv = geometry.attributes.uv1;

                this.geometry = geometry;
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // const map = await loadTexture('cubemap.jpg');
                const map = await loadTexture('cube/cube_basecolor.jpg');
                map.anisotropy = anisotropy;

                this.material = new BasicMaterial({ map });
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        // Based on https://oframe.github.io/ogl/examples/?src=skinning.html by gordonnl

        class Floor extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                this.geometry = await loadBufferGeometry('floor.json');
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // const map = await loadTexture('uv.jpg');
                const map = await loadTexture('cube/cube_shadow.jpg');
                map.anisotropy = anisotropy;

                this.material = new ShadowTextureMaterial({ map });
                this.material.side = DoubleSide;
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                mesh.position.y = -0.54;
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.cube = new Cube();
                this.add(this.cube);
            }

            // Public methods

            animateIn = () => {
                this.visible = true;
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.cube.ready()
            ]);
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLoaders();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0xffffff);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await this.view.ready();
                this.view.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_baked_spherical_cube_dudv.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Baked Shadow Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        :root {
            --bg-color: #fff;
            --ui-color: #000;
            --ui-color-triplet: 0 0 0;
        }
    </style>

    <script type="module">
        import { BasicMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, Group, ImageBitmapLoaderThread, LinearSRGBColorSpace, Mesh, OrbitControls, PerspectiveCamera, PlaneGeometry, Reflector, ReflectorDudvMaterial, RepeatWrapping, Scene, TextureLoader, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class Sphere extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('spherical_cube.json');

                // Use second set of UVs for cubemap row layout
                // https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Cubemaps/CreatingCubemaps/
                geometry.attributes.uv = geometry.attributes.uv1;

                this.geometry = geometry;
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // const map = await loadTexture('cubemap.jpg');
                const map = await loadTexture('spherical_cube/spherical_cube_basecolor.jpg');
                map.anisotropy = anisotropy;

                this.material = new BasicMaterial({ map });
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 3);

                const material = new ReflectorDudvMaterial({
                    map,
                    reflectivity: 0.5
                });
                material.uniforms.tReflect = { value: this.reflector.renderTarget.texture };
                material.uniforms.tReflectBlur = this.reflector.renderTargetUniform;
                material.uniforms.uMatrix = this.reflector.textureMatrixUniform;

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -0.54;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.sphere = new Sphere();
                this.add(this.sphere);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.sphere.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLoaders();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0xffffff);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update();
                RenderManager.update(time, delta, frame);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_baked_spherical_cube_sss.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Baked Subsurface Scattering Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, EnvironmentTextureLoader, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, PointLightHelper, Reflector, ReflectorDudvMaterial, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, ShaderChunk, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getViewSize, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const colors = {
            lightColor: 0xf44336
        };

        class MouseLight extends Group {
            constructor() {
                super();

                this.position.z = 0;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 0.9, 4.4, 0);
                this.add(light);

                if (isDebug) {
                    WorldController.scene.add(new PointLightHelper(light, 0.125));
                }
            }
        }

        class Sphere extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                this.geometry = await loadBufferGeometry('spherical_cube.json');
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('spherical_cube/spherical_cube_thickness.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.1 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 0.7 },
                    thicknessPower: { value: 1 },
                    thicknessScale: { value: 16 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                this.material = material;
                this.uniforms = uniforms;
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector({ blurIterations: 6 });
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 6);

                const material = new ReflectorDudvMaterial({
                    map,
                    reflectivity: 0.5
                });
                material.uniforms.tReflect = { value: this.reflector.renderTarget.texture };
                material.uniforms.tReflectBlur = this.reflector.renderTargetUniform;
                material.uniforms.uMatrix = this.reflector.textureMatrixUniform;

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -0.54;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.sphere = new Sphere();
                this.add(this.sphere);

                this.light = new MouseLight();
                this.add(this.light);
            }

            // Public methods

            ready = () => Promise.all([
                this.floor.ready(),
                this.sphere.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.target = new Vector2();
                this.lightPosition = new Vector3();
                this.lerpSpeed = 0.25;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.target.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.target.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.view.floor.resize(width, height);

                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.light.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.lerp(this.target, this.lerpSpeed);

                this.lightPosition.x = this.mouse.x * this.halfWidth;
                this.lightPosition.y = this.mouse.y * this.halfHeight;
                this.lightPosition.z = this.view.light.position.z;

                this.view.light.position.copy(this.lightPosition);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { sphere } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: sphere.uniforms.thicknessDistortion.value,
                        callback: value => {
                            sphere.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAmbient.value,
                        callback: value => {
                            sphere.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            sphere.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: sphere.uniforms.thicknessPower.value,
                        callback: value => {
                            sphere.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: sphere.uniforms.thicknessScale.value,
                        callback: value => {
                            sphere.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_baked_spherical_cube.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Baked Shadow Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        :root {
            --bg-color: #fff;
            --ui-color: #000;
            --ui-color-triplet: 0 0 0;
        }
    </style>

    <script type="module">
        import { BasicMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, DoubleSide, Group, ImageBitmapLoaderThread, LinearSRGBColorSpace, Mesh, OrbitControls, PerspectiveCamera, Scene, ShadowTextureMaterial, TextureLoader, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class Sphere extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('spherical_cube.json');

                // Use second set of UVs for cubemap row layout
                // https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Cubemaps/CreatingCubemaps/
                geometry.attributes.uv = geometry.attributes.uv1;

                this.geometry = geometry;
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // const map = await loadTexture('cubemap.jpg');
                const map = await loadTexture('spherical_cube/spherical_cube_basecolor.jpg');
                map.anisotropy = anisotropy;

                this.material = new BasicMaterial({ map });
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        // Based on https://oframe.github.io/ogl/examples/?src=skinning.html by gordonnl

        class Floor extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                this.geometry = await loadBufferGeometry('floor.json');
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // const map = await loadTexture('uv.jpg');
                const map = await loadTexture('spherical_cube/spherical_cube_shadow.jpg');
                map.anisotropy = anisotropy;

                this.material = new ShadowTextureMaterial({ map });
                this.material.side = DoubleSide;
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                mesh.position.y = -0.54;
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.sphere = new Sphere();
                this.add(this.sphere);
            }

            // Public methods

            animateIn = () => {
                this.visible = true;
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.sphere.ready()
            ]);
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLoaders();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0xffffff);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await this.view.ready();
                this.view.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_barrel_distortion.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Barrel Distortion Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BufferGeometry, Color, ColorManagement, CopyMaterial, DepthTexture, DirectionalLight, EnvironmentTextureLoader, Float32BufferAttribute, GLSL3, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OrbitControls, OrthographicCamera, PanelItem, PerspectiveCamera, Points, RawShaderMaterial, RepeatWrapping, Scene, SphereGeometry, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://github.com/mattatz/ShibuyaCrowd

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: null },
                        uDistortion: { value: 2.2 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tMap;
                        uniform float uDistortion;

                        in vec2 vUv;

                        out vec4 FragColor;

                        vec2 barrelDistortion(vec2 coord, float amt) {
                            vec2 cc = coord - 0.5;
                            float dist = dot(cc, cc);
                            return coord + cc * dist * amt;
                        }

                        float sat(float t) {
                            return clamp(t, 0.0, 1.0);
                        }

                        float linterp(float t) {
                            return sat(1.0 - abs(2.0 * t - 1.0));
                        }

                        float remap(float t, float a, float b) {
                            return sat((t - a) / (b - a));
                        }

                        vec4 spectrum_offset(float t) {
                            vec4 ret;
                            float lo = step(t, 0.5);
                            float hi = 1.0 - lo;
                            float w = linterp(remap(t, 1.0 / 6.0, 5.0 / 6.0));
                            ret = vec4(lo, 1.0, hi, 1.0) * vec4(1.0 - w, w, 1.0 - w, 1.0);
                            return pow(ret, vec4(1.0 / 2.2));
                        }

                        vec4 apply(sampler2D tex, vec2 uv, float distortion) {
                            const int num_iter = 9;
                            const float reci_num_iter_f = 1.0 / float(num_iter);

                            vec4 sumcol = vec4(0.0);
                            vec4 sumw = vec4(0.0);
                            for (int i = 0; i < num_iter; i++) {
                                float t = float(i) * reci_num_iter_f;
                                vec4 w = spectrum_offset(t);
                                sumw += w;
                                sumcol += w * texture(tex, barrelDistortion(uv, 0.04 * distortion * t));
                            }

                            return sumcol / sumw;
                        }

                        void main() {
                            FragColor = apply(tMap, vUv, uDistortion);
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        import simplex3d from '../../src/shaders/modules/noise/simplex3d.glsl.js';
        import depth from '../../src/shaders/modules/depth/depth.glsl.js';

        class Dust extends Group {
            constructor(numParticles) {
                super();

                this.numParticles = numParticles;

                this.initPoints();
            }

            initPoints() {
                const { camera, getTexture, resolution, time } = WorldController;

                const vertices = [];

                for (let i = 0; i < this.numParticles; i++) {
                    vertices[i * 3 + 0] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 1] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 2] = MathUtils.randFloatSpread(camera.far / 2);
                }

                const geometry = new BufferGeometry();
                geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));

                // Based on https://jsfiddle.net/m7tvxpbs/ by Mugen87

                const material = new RawShaderMaterial({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: getTexture('particle.png') },
                        tDepth: { value: null },
                        uScale: { value: window.devicePixelRatio / 2 },
                        uAlpha: { value: 1 },
                        uCameraNear: { value: camera.near },
                        uCameraFar: { value: camera.far },
                        uResolution: resolution,
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;

                        uniform mat4 modelMatrix;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;

                        uniform float uScale;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform float uTime;

                        out float vFade;

                        ${simplex3d}

                        void main() {
                            vec3 p = position;
                            p.x += snoise(position.xyz + uTime * 0.02);
                            p.y += snoise(position.yyz + uTime * 0.02);
                            p.z += snoise(position.zxy + uTime * 0.02);

                            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);

                            gl_PointSize = uScale * (150.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;

                            vec3 worldPosition = (modelMatrix * vec4(p, 1.0)).xyz;
                            float linearDepth = 1.0 / (uCameraFar - uCameraNear);
                            float linearPos = length(cameraPosition - worldPosition) * linearDepth;

                            vFade = 1.0 - linearPos * 0.75;
                            vFade *= smoothstep(0.09, 0.13, linearPos);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        #include <packing>

                        uniform sampler2D tMap;
                        uniform sampler2D tDepth;
                        uniform float uAlpha;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform vec2 uResolution;

                        in float vFade;

                        out vec4 FragColor;

                        ${depth}

                        float fadeEdge(float particleDepth, float sceneDepth) {
                            // Margin makes it blend through the solid objects a little bit more,
                            // creating illusion of density
                            float extraMargin = 0.015;
                            float a = (sceneDepth + extraMargin - particleDepth) * 120.0;

                            if (a <= 0.0) return 0.0;
                            if (a >= 1.0) return 1.0;

                            if (a < 0.5) a = 2.0 * a * a;
                            else a = -2.0 * pow(a - 1.0, 2.0) + 1.0;

                            return a;
                        }

                        void main() {
                            FragColor = texture(tMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));

                            vec2 uv = gl_FragCoord.xy / uResolution;
                            float particleDepth = getDepth(gl_FragCoord.z, uCameraNear, uCameraFar);
                            float sceneDepth = getDepth(tDepth, uv, uCameraNear, uCameraFar);
                            float alphaScale = fadeEdge(particleDepth, sceneDepth);

                            FragColor.a *= alphaScale;
                            FragColor.a *= vFade;
                            FragColor.a *= uAlpha;
                        }
                    `,
                    transparent: true,
                    blending: AdditiveBlending,
                    depthTest: false,
                    depthWrite: false
                });

                const points = new Points(geometry, material);
                this.add(points);

                this.material = material;
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(0x060606),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uDistortion.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, dust) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.dust = dust;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetA.depthTexture = new DepthTexture();

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Blend it additively
                this.bloomCompositeMaterial.blending = AdditiveBlending;

                // Dust scene
                this.dustScene = new Scene();
                this.dustScene.add(this.dust);

                this.dust.material.uniforms.tDepth.value = this.renderTargetA.depthTexture;

                // Copy material
                this.copyMaterial = new CopyMaterial();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.screen, this.screenCamera);

                // Dust scene
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.dustScene, camera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.dust = new Dust(1000);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera, this.dust);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_basic_color_lighting.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Basic Lighting Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorLightingMaterial, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, MathUtils, Mesh, MeshBasicMaterial, PanelItem, PerspectiveCamera, Scene, SphereGeometry, TextureLoader, UI, Vector2, Vector3, WebGLRenderer, getFullscreenTriangle, getViewSize, ticker, tween } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        class MouseLight extends Group {
            constructor() {
                super();

                this.position.z = 2;

                if (isDebug) {
                    this.initDebug();
                }
            }

            initDebug() {
                const geometry = new SphereGeometry(0.125, 1, 1);

                const material = new MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true
                });

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class Polyhedron extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('polyhedron.json');

                const material = new ColorLightingMaterial({
                    color: new Color(0.2, 0.8, 1.0),
                    // lightPosition: new Vector3(1, 1, 1),
                    lightIntensity: 0.1
                });

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.material = material;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.polyhedron = new Polyhedron();
                this.add(this.polyhedron);

                this.light = new MouseLight();
                this.add(this.light);
            }
        }

        class SceneController {
            static init(view) {
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.target = new Vector2();
                this.lightPosition = new Vector3();
                this.lerpSpeed = 0.25;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.target.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.target.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = () => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.light.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.lerp(this.target, this.lerpSpeed);

                this.lightPosition.x = this.mouse.x * this.halfWidth;
                this.lightPosition.y = this.mouse.y * this.halfHeight;
                this.lightPosition.z = this.view.light.position.z;

                this.view.polyhedron.material.uniforms.uLightPosition.value.copy(this.lightPosition);
                this.view.light.position.copy(this.lightPosition);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.polyhedron.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { polyhedron } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Int',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: polyhedron.material.uniforms.uLightIntensity.value,
                        callback: value => {
                            polyhedron.material.uniforms.uLightIntensity.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.target = new Vector2();

                // Motion control
                this.group = new Group();
                this.innerGroup = new Group();
                this.group.add(this.innerGroup);
                this.group.matrixAutoUpdate = false;
                this.innerGroup.matrixAutoUpdate = false;

                // Start position
                this.innerGroup.position.copy(this.camera.position);

                this.rotation = 0.0002;
                this.lerpSpeed = 0.05;
                this.multiplier = 1;
                this.enabled = false;
                this.prevent = true;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (this.prevent) {
                    return;
                }

                this.mouse.x = clientX - this.halfWidth;
                this.mouse.y = clientY - this.halfHeight;

                this.target.x = MathUtils.degToRad(-360) + this.mouse.x * this.rotation * this.multiplier;
                this.target.y = this.mouse.y * this.rotation * this.multiplier;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                this.halfWidth = width / 2;
                this.halfHeight = height / 2;

                if (width < height) {
                    this.camera.position.z = 10;
                    this.multiplier = 2;
                } else {
                    this.camera.position.z = 8;
                    this.multiplier = 1;
                }

                this.innerGroup.position.z = this.camera.position.z;
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.group.rotation.x += (this.target.y - this.group.rotation.x) * this.lerpSpeed;
                this.group.rotation.y += (this.target.x - this.group.rotation.y) * this.lerpSpeed;

                this.updateCamera();
            };

            static updateCamera = () => {
                this.group.updateMatrix();
                this.innerGroup.updateMatrix();
                this.group.updateMatrixWorld();
                this.innerGroup.matrixWorld.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
            };

            static animateIn = () => {
                this.enabled = true;

                tween(this.target, { x: MathUtils.degToRad(-360) }, 4200, 'easeInOutQuart', () => {
                    this.prevent = false;
                });
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_basic_texture_lighting.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Basic Lighting Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BasicLightingMaterial, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, MathUtils, Mesh, MeshBasicMaterial, PanelItem, PerspectiveCamera, RepeatWrapping, Scene, SphereGeometry, TextureLoader, UI, Vector2, Vector3, WebGLRenderer, getFullscreenTriangle, getViewSize, ticker, tween } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        class MouseLight extends Group {
            constructor() {
                super();

                this.position.z = 2;

                if (isDebug) {
                    this.initDebug();
                }
            }

            initDebug() {
                const geometry = new SphereGeometry(0.125, 1, 1);

                const material = new MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true
                });

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class Polyhedron extends Group {
            constructor() {
                super();
            }

            async initGeometry() {
                const { loadBufferGeometry } = WorldController;

                const geometry = await loadBufferGeometry('polyhedron.json');

                this.geometry = geometry;
            }

            async initMaterial() {
                const { anisotropy, loadTexture } = WorldController;

                // Textures
                // const map = await loadTexture('uv.jpg');
                const map = await loadTexture('pbr/pitted_metal_basecolor.jpg');
                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                const material = new BasicLightingMaterial({
                    map,
                    // lightPosition: new Vector3(1, 1, 1),
                    lightIntensity: 0.25
                });

                this.material = material;
            }

            initMesh() {
                const mesh = new Mesh(this.geometry, this.material);
                this.add(mesh);
            }

            // Public methods

            ready = async () => {
                await Promise.all([
                    this.initGeometry(),
                    this.initMaterial()
                ]);

                this.initMesh();
            };
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.polyhedron = new Polyhedron();
                this.add(this.polyhedron);

                this.light = new MouseLight();
                this.add(this.light);
            }
        }

        class SceneController {
            static init(view) {
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.target = new Vector2();
                this.lightPosition = new Vector3();
                this.lerpSpeed = 0.25;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.target.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.target.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = () => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.light.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.lerp(this.target, this.lerpSpeed);

                this.lightPosition.x = this.mouse.x * this.halfWidth;
                this.lightPosition.y = this.mouse.y * this.halfHeight;
                this.lightPosition.z = this.view.light.position.z;

                this.view.polyhedron.material.uniforms.uLightPosition.value.copy(this.lightPosition);
                this.view.light.position.copy(this.lightPosition);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.polyhedron.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { polyhedron } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Int',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: polyhedron.material.uniforms.uLightIntensity.value,
                        callback: value => {
                            polyhedron.material.uniforms.uLightIntensity.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.target = new Vector2();

                // Motion control
                this.group = new Group();
                this.innerGroup = new Group();
                this.group.add(this.innerGroup);
                this.group.matrixAutoUpdate = false;
                this.innerGroup.matrixAutoUpdate = false;

                // Start position
                this.innerGroup.position.copy(this.camera.position);

                this.rotation = 0.0002;
                this.lerpSpeed = 0.05;
                this.multiplier = 1;
                this.enabled = false;
                this.prevent = true;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (this.prevent) {
                    return;
                }

                this.mouse.x = clientX - this.halfWidth;
                this.mouse.y = clientY - this.halfHeight;

                this.target.x = MathUtils.degToRad(-360) + this.mouse.x * this.rotation * this.multiplier;
                this.target.y = this.mouse.y * this.rotation * this.multiplier;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                this.halfWidth = width / 2;
                this.halfHeight = height / 2;

                if (width < height) {
                    this.camera.position.z = 10;
                    this.multiplier = 2;
                } else {
                    this.camera.position.z = 8;
                    this.multiplier = 1;
                }

                this.innerGroup.position.z = this.camera.position.z;
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.group.rotation.x += (this.target.y - this.group.rotation.x) * this.lerpSpeed;
                this.group.rotation.y += (this.target.x - this.group.rotation.y) * this.lerpSpeed;

                this.updateCamera();
            };

            static updateCamera = () => {
                this.group.updateMatrix();
                this.innerGroup.updateMatrix();
                this.group.updateMatrixWorld();
                this.innerGroup.matrixWorld.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
            };

            static animateIn = () => {
                this.enabled = true;

                tween(this.target, { x: MathUtils.degToRad(-360) }, 4200, 'easeInOutQuart', () => {
                    this.prevent = false;
                });
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_bloom_dither.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Bloom Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, Scene, SceneCompositeMaterial, SphereGeometry, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                const material = new MeshStandardMaterial({ roughness: 0 });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/postprocessing/UnrealBloomPass.js by spidersharma03 and bhouston

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial({ dithering: true });
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 1.2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_bloom_hdr.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Bloom Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Group, HalfFloatType, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, Scene, SceneCompositeMaterial, SphereGeometry, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        const colors = {
            lightColor: 0xff8dfc
        };

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Based on https://twitter.com/0xca0a/status/1525083552672632833

                const material = new MeshBasicMaterial({
                    color: new Color(colors.lightColor).multiplyScalar(4),
                    toneMapped: false
                });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { bloomCompositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        // Based on https://twitter.com/0xca0a/status/1525083552672632833

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.15;
                this.bloomRadius = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    type: HalfFloatType,
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial({ dithering: true });
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 1.2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_bloom.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Bloom Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BlurMaterial, Color, ColorManagement, DirectionalLight, GLSL3, Group, HemisphereLight, LinearSRGBColorSpace, Mesh, MeshStandardMaterial, NoBlending, OrthographicCamera, PanelItem, PerspectiveCamera, RawShaderMaterial, Scene, SphereGeometry, UI, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        uBloomReduction: { value: 0.07 },
                        uBloomBoost: { value: 0.4 },
                        uBloomClamp: { value: 1 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform float uBloomReduction;
                        uniform float uBloomBoost;
                        uniform float uBloomClamp;

                        in vec2 vUv;

                        out vec4 FragColor;

                        void main() {
                            FragColor = texture(tScene, vUv);

                            vec4 bloom = texture(tBloom, vUv);
                            bloom.r = max(0.0, bloom.r - uBloomReduction);
                            bloom.g = max(0.0, bloom.g - uBloomReduction);
                            bloom.b = max(0.0, bloom.b - uBloomReduction);
                            bloom.rgb *= uBloomBoost;
                            bloom = clamp(bloom, 0.0, uBloomClamp);

                            FragColor.rgb += bloom.rgb;
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                const material = new MeshStandardMaterial({ roughness: 0 });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { hBlurMaterial, vBlurMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Blur',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: hBlurMaterial.uniforms.uBlurAmount.value,
                        callback: value => {
                            hBlurMaterial.uniforms.uBlurAmount.value = value;
                            vBlurMaterial.uniforms.uBlurAmount.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Reduce',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uBloomReduction.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomReduction.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Boost',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomBoost.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomBoost.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uBloomClamp.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomClamp.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.bloomReduction = 0.07;
                this.bloomBoost = 0.4;
                this.bloomClamp = 1;
                this.blurResolutionScale = 0.25;
                this.blurAmount = 3;
                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Background scene
                this.backgroundScene = new Scene();
                this.backgroundScene.background = new Color(0x060606);

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBlurA = this.renderTarget.clone();
                this.renderTargetBlurB = this.renderTarget.clone();

                this.renderTarget.depthBuffer = true;

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.uBloomReduction.value = this.bloomReduction;
                this.compositeMaterial.uniforms.uBloomBoost.value = this.bloomBoost;
                this.compositeMaterial.uniforms.uBloomClamp.value = this.bloomClamp;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                width = Math.round(width * this.blurResolutionScale);
                height = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(width, height);
                this.renderTargetBlurB.setSize(width, height);

                this.hBlurMaterial.uniforms.uResolution.value.set(width, height);
                this.vBlurMaterial.uniforms.uResolution.value.set(width, height);
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;

                // Background pass
                renderer.setRenderTarget(renderTarget);
                renderer.clear();
                renderer.render(this.backgroundScene, camera);

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 1.3);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_blur.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Blur Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BlurMaterial, Color, ColorManagement, CopyMaterial, DirectionalLight, Group, HemisphereLight, LinearSRGBColorSpace, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, Scene, SphereGeometry, UI, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                const material = new MeshStandardMaterial({ roughness: 0 });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { hBlurMaterial, vBlurMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Blur',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: hBlurMaterial.uniforms.uBlurAmount.value,
                        callback: value => {
                            hBlurMaterial.uniforms.uBlurAmount.value = value;
                            vBlurMaterial.uniforms.uBlurAmount.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.blurResolutionScale = 0.25;
                this.blurAmount = 1.8;
                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBlurA = this.renderTarget.clone();
                this.renderTargetBlurB = this.renderTarget.clone();

                this.renderTarget.depthBuffer = true;

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Copy material
                this.copyMaterial = new CopyMaterial();
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                width = Math.round(width * this.blurResolutionScale);
                height = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(width, height);
                this.renderTargetBlurB.setSize(width, height);

                this.hBlurMaterial.uniforms.uResolution.value.set(width, height);
                this.vBlurMaterial.uniforms.uResolution.value.set(width, height);
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.render(this.screen, this.screenCamera);

                // Copy pass (render to screen)
                this.copyMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_bokeh_blur.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Bokeh Blur Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BokehBlurMaterial1, BokehBlurMaterial2, Color, ColorManagement, CopyMaterial, DirectionalLight, Group, HemisphereLight, LinearSRGBColorSpace, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, Scene, SphereGeometry, UI, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                const material = new MeshStandardMaterial({ roughness: 0 });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { bokehBlurMaterial1, bokehBlurMaterial2 } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Blur',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bokehBlurScale,
                        callback: value => {
                            bokehBlurMaterial1.uniforms.uScale.value = value;
                            bokehBlurMaterial2.uniforms.uScale.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.blurResolutionScale = 0.25;
                this.bokehBlurScale = 1;
                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBlurA = this.renderTarget.clone();
                this.renderTargetBlurB = this.renderTarget.clone();

                this.renderTarget.depthBuffer = true;

                // Bokeh blur materials
                this.bokehBlurMaterial1 = new BokehBlurMaterial1();
                this.bokehBlurMaterial1.uniforms.uScale.value = this.bokehBlurScale;
                this.bokehBlurMaterial1.uniforms.uResolution = resolution;

                this.bokehBlurMaterial2 = new BokehBlurMaterial2();
                this.bokehBlurMaterial2.uniforms.uScale.value = this.bokehBlurScale;
                this.bokehBlurMaterial2.uniforms.uResolution = resolution;

                // Copy material
                this.copyMaterial = new CopyMaterial();
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                width = Math.round(width * this.blurResolutionScale);
                height = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(width, height);
                this.renderTargetBlurB.setSize(width, height);
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Bokeh blur pass
                this.bokehBlurMaterial1.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.bokehBlurMaterial1;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.render(this.screen, this.screenCamera);

                this.bokehBlurMaterial2.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.bokehBlurMaterial2;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.render(this.screen, this.screenCamera);

                // Copy pass (render to screen)
                this.copyMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_chromatic_aberration.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Chromatic Aberration Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BufferGeometry, ChromaticAberrationMaterial, Color, ColorManagement, CopyMaterial, DepthTexture, DirectionalLight, EnvironmentTextureLoader, Float32BufferAttribute, GLSL3, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrbitControls, OrthographicCamera, PanelItem, PerspectiveCamera, Points, RawShaderMaterial, RepeatWrapping, Scene, SphereGeometry, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import simplex3d from '../../src/shaders/modules/noise/simplex3d.glsl.js';
        import depth from '../../src/shaders/modules/depth/depth.glsl.js';

        class Dust extends Group {
            constructor(numParticles) {
                super();

                this.numParticles = numParticles;

                this.initPoints();
            }

            initPoints() {
                const { camera, getTexture, resolution, time } = WorldController;

                const vertices = [];

                for (let i = 0; i < this.numParticles; i++) {
                    vertices[i * 3 + 0] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 1] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 2] = MathUtils.randFloatSpread(camera.far / 2);
                }

                const geometry = new BufferGeometry();
                geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));

                // Based on https://jsfiddle.net/m7tvxpbs/ by Mugen87

                const material = new RawShaderMaterial({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: getTexture('particle.png') },
                        tDepth: { value: null },
                        uScale: { value: window.devicePixelRatio / 2 },
                        uAlpha: { value: 1 },
                        uCameraNear: { value: camera.near },
                        uCameraFar: { value: camera.far },
                        uResolution: resolution,
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;

                        uniform mat4 modelMatrix;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;

                        uniform float uScale;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform float uTime;

                        out float vFade;

                        ${simplex3d}

                        void main() {
                            vec3 p = position;
                            p.x += snoise(position.xyz + uTime * 0.02);
                            p.y += snoise(position.yyz + uTime * 0.02);
                            p.z += snoise(position.zxy + uTime * 0.02);

                            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);

                            gl_PointSize = uScale * (150.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;

                            vec3 worldPosition = (modelMatrix * vec4(p, 1.0)).xyz;
                            float linearDepth = 1.0 / (uCameraFar - uCameraNear);
                            float linearPos = length(cameraPosition - worldPosition) * linearDepth;

                            vFade = 1.0 - linearPos * 0.75;
                            vFade *= smoothstep(0.09, 0.13, linearPos);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        #include <packing>

                        uniform sampler2D tMap;
                        uniform sampler2D tDepth;
                        uniform float uAlpha;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform vec2 uResolution;

                        in float vFade;

                        out vec4 FragColor;

                        ${depth}

                        float fadeEdge(float particleDepth, float sceneDepth) {
                            // Margin makes it blend through the solid objects a little bit more,
                            // creating illusion of density
                            float extraMargin = 0.015;
                            float a = (sceneDepth + extraMargin - particleDepth) * 120.0;

                            if (a <= 0.0) return 0.0;
                            if (a >= 1.0) return 1.0;

                            if (a < 0.5) a = 2.0 * a * a;
                            else a = -2.0 * pow(a - 1.0, 2.0) + 1.0;

                            return a;
                        }

                        void main() {
                            FragColor = texture(tMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));

                            vec2 uv = gl_FragCoord.xy / uResolution;
                            float particleDepth = getDepth(gl_FragCoord.z, uCameraNear, uCameraFar);
                            float sceneDepth = getDepth(tDepth, uv, uCameraNear, uCameraFar);
                            float alphaScale = fadeEdge(particleDepth, sceneDepth);

                            FragColor.a *= alphaScale;
                            FragColor.a *= vFade;
                            FragColor.a *= uAlpha;
                        }
                    `,
                    transparent: true,
                    blending: AdditiveBlending,
                    depthTest: false,
                    depthWrite: false
                });

                const points = new Points(geometry, material);
                this.add(points);

                this.material = material;
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(0x060606),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { caMaterial, luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Red',
                        min: -4,
                        max: 4,
                        step: 0.01,
                        value: caMaterial.uniforms.uRedOffset.value,
                        callback: value => {
                            caMaterial.uniforms.uRedOffset.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Green',
                        min: -4,
                        max: 4,
                        step: 0.01,
                        value: caMaterial.uniforms.uGreenOffset.value,
                        callback: value => {
                            caMaterial.uniforms.uGreenOffset.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Blue',
                        min: -4,
                        max: 4,
                        step: 0.01,
                        value: caMaterial.uniforms.uBlueOffset.value,
                        callback: value => {
                            caMaterial.uniforms.uBlueOffset.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Int',
                        min: 0,
                        max: 3,
                        step: 0.01,
                        value: caMaterial.uniforms.uIntensity.value,
                        callback: value => {
                            caMaterial.uniforms.uIntensity.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, dust) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.dust = dust;

                // Chromatic aberration
                this.caRedOffset = 0;
                this.caGreenOffset = 4;
                this.caBlueOffset = 0;
                this.caIntensity = 2.2;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetA.depthTexture = new DepthTexture();

                // Chromatic aberration material
                this.caMaterial = new ChromaticAberrationMaterial();
                this.caMaterial.uniforms.uRedOffset.value = this.caRedOffset;
                this.caMaterial.uniforms.uGreenOffset.value = this.caGreenOffset;
                this.caMaterial.uniforms.uBlueOffset.value = this.caBlueOffset;
                this.caMaterial.uniforms.uIntensity.value = this.caIntensity;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Blend it additively
                this.bloomCompositeMaterial.blending = AdditiveBlending;

                // Dust scene
                this.dustScene = new Scene();
                this.dustScene.add(this.dust);

                this.dust.material.uniforms.tDepth.value = this.renderTargetA.depthTexture;

                // Copy material
                this.copyMaterial = new CopyMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.screen, this.screenCamera);

                // Dust scene
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.dustScene, camera);

                // Chromatic aberration pass (render to screen)
                this.caMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.caMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.dust = new Dust(1000);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera, this.dust);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_datamosh.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Datamosh Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BlurMaterial, Color, ColorManagement, CopyMaterial, DatamoshMaterial, DepthMaterial, DirectionalLight, DisplayOptions, DrawBuffers, DynamicDrawUsage, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, InstancedMesh, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Matrix4, Mesh, MeshBasicMaterial, MeshMatcapMaterial, MeshStandardMaterial, MotionBlurCompositeMaterial, NoBlending, NormalMaterial, OimoPhysics, OrthographicCamera, Panel, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, RawShaderMaterial, RepeatWrapping, RigidBodyConfig, RigidBodyType, Scene, ShaderChunk, TextureLoader, UI, UniversalJointConfig, UnrealBloomBlurMaterial, Vector2, Vector3, VolumetricLightLensflareMaterial, WebGLRenderTarget, WebGLRenderer, getDoubleRenderTarget, getFullscreenTriangle, getKeyByValue, getViewSize, headsTails, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        const count = parseInt(location.search.slice(1), 10) || 100;

        const layers = {
            default: 0,
            buffers: 1,
            occlusion: 2
        };

        const colors = {
            lightColor: 0xf44336
        };

        // Based on https://threejs.org/examples/#webgl_multiple_rendertargets by takahirox
        // Based on https://oframe.github.io/ogl/examples/?src=mrt.html by gordonnl
        // Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/motionBlurPass
        // Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/shader-replacement

        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                const { aspect } = WorldController;

                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tColor: { value: null },
                        tNormal: { value: null },
                        tPosition: { value: null },
                        tVelocity: { value: null },
                        tScene: { value: null },
                        tBloom: { value: null },
                        tAdd: { value: null },
                        uDebug: { value: isDebug },
                        uAspect: aspect
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tColor;
                        uniform sampler2D tNormal;
                        uniform sampler2D tPosition;
                        uniform sampler2D tVelocity;
                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform sampler2D tAdd;
                        uniform bool uDebug;
                        uniform float uAspect;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${dither}

                        void main() {
                            // Extract data from render targets
                            vec3 color = texture(tColor, vUv).rgb;
                            vec3 normal = texture(tNormal, vUv).rgb;
                            vec4 pos = texture(tPosition, vUv);
                            vec2 vel = texture(tVelocity, vUv).xy;
                            float depth = pos.a;

                            FragColor = texture(tScene, vUv);

                            FragColor.rgb += texture(tBloom, vUv).rgb;

                            FragColor.rgb += texture(tAdd, vUv).rgb;

                            FragColor.rgb = dither(FragColor.rgb);
                            FragColor.a = 1.0;

                            if (uDebug) {
                                // Render raw render targets in corner
                                vec2 uv = gl_FragCoord.xy / vec2(250.0 * uAspect, 250.0);
                                if (uv.y < 1.0 && uv.x < 1.0) {
                                    FragColor.rgb = vec3(texture(tPosition, mod(uv, 1.0)).a);
                                } else if (uv.y < 2.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tVelocity, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 3.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tPosition, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 4.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tScene, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 5.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tBloom, mod(uv, 1.0)).rgb;
                                } else if (uv.y < 6.0 && uv.x < 1.0) {
                                    FragColor.rgb = texture(tAdd, mod(uv, 1.0)).rgb;
                                }
                            }
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        // https://adinunz.io/translucentPearls/

        // Based on http://lo-th.github.io/Oimo.js/#planet

        class Balls extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { physics, anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(1, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu
                // Based on https://gist.github.com/mattdesl/2ee82157a86962347dedb6572142df7c

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.05 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 0.8 },
                    thicknessPower: { value: 2 },
                    thicknessScale: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).r;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += material.diffuseColor * directLight.color * scatteringIllu * thicknessAttenuation;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new InstancedMesh(geometry, material, count);
                mesh.instanceMatrix.setUsage(DynamicDrawUsage); // Will be updated every frame
                mesh.layers.enable(layers.buffers);
                this.add(mesh);

                const object = new Group();

                for (let i = 0; i < mesh.count; i++) {
                    object.position.x = MathUtils.randFloat(10, 100) * (headsTails() ? -1 : 1);
                    object.position.y = MathUtils.randFloat(10, 100) * (headsTails() ? -1 : 1);
                    object.position.z = MathUtils.randFloat(10, 100) * (headsTails() ? -1 : 1);

                    object.rotation.x = MathUtils.degToRad(MathUtils.randInt(0, 360));
                    object.rotation.y = MathUtils.degToRad(MathUtils.randInt(0, 360));
                    object.rotation.z = MathUtils.degToRad(MathUtils.randInt(0, 360));

                    object.updateMatrix();

                    mesh.setMatrixAt(i, object.matrix);
                }

                mesh.computeBoundingSphere();

                // Physics
                physics.add(mesh, { autoSleep: false });

                this.uniforms = uniforms;
                this.mesh = mesh;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class Sphere extends Group {
            constructor() {
                super();

                // Physics
                this.name = 'sphere';
                this.autoSleep = false;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 1.9, 4.4, 0);
                this.add(light);
            }

            async initMesh() {
                const { physics, anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(1, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(colors.lightColor),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.2 };
                    shader.uniforms.thicknessPower = { value: 2 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.layers.enable(layers.buffers);
                this.add(mesh);

                // Occlusion mesh
                const occMesh = mesh.clone();
                occMesh.material = new MeshBasicMaterial({ color: colors.lightColor });
                occMesh.layers.set(layers.occlusion);
                this.add(occMesh);

                // Physics
                physics.add(mesh);

                const body = new RigidBodyConfig();
                body.type = RigidBodyType.KINEMATIC;
                physics.add(body);

                const joint = new UniversalJointConfig();
                joint.rigidBody1 = physics.get(this);
                joint.rigidBody2 = physics.get(body);
                physics.add(joint);

                this.body = body;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.sphere = new Sphere();
                this.add(this.sphere);

                this.balls = new Balls();
                this.add(this.balls);
            }

            // Public methods

            ready = () => Promise.all([
                this.sphere.ready(),
                this.balls.ready()
            ]);
        }

        class SceneController {
            static init(physics, view) {
                this.physics = physics;
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.lightPosition = new Vector3();

                // Physics
                this.force = new Vector3();
                this.center = new Vector3(0, 0, 0);
                this.object = new Group();
                this.matrix = new Matrix4();

                this.enabled = true;
                this.animatedOneFramePast = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = () => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.sphere.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                if (this.enabled || !this.animatedOneFramePast) {
                    // Mouse light
                    this.lightPosition.x = this.mouse.x * this.halfWidth;
                    this.lightPosition.y = this.mouse.y * this.halfHeight;
                    this.lightPosition.z = this.view.sphere.position.z;

                    this.physics.setPosition(this.view.sphere.body, this.lightPosition);

                    // Physics
                    for (let i = 0; i < this.view.balls.mesh.count; i++) {
                        const { position, quaternion, scale } = this.object;

                        this.view.balls.mesh.getMatrixAt(i, this.matrix);
                        this.matrix.decompose(position, quaternion, scale);

                        this.force.copy(position).negate().normalize().multiplyScalar(0.1);
                        this.physics.applyImpulse(this.view.balls.mesh, this.force, this.center, i);
                    }

                    this.physics.step();

                    this.animatedOneFramePast = !this.enabled;
                }
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(physics, view, ui) {
                this.physics = physics;
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { drawBuffers, vlMaterial, datamoshMaterial, luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const physics = this.physics;
                const { balls } = this.view;

                const gravity = this.physics.getGravity();

                const physicsOptions = {
                    Off: false,
                    Physics: true
                };

                const defaultOptions = {
                    Off: false,
                    Targets: true
                };

                const defaultItems = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: defaultOptions,
                        value: getKeyByValue(defaultOptions, compositeMaterial.uniforms.uDebug.value),
                        callback: value => {
                            compositeMaterial.uniforms.uDebug.value = defaultOptions[value];
                        }
                    }
                ];

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: DisplayOptions,
                        value: getKeyByValue(DisplayOptions, RenderManager.display),
                        callback: (value, item) => {
                            if (!item.hasContent()) {
                                const defaultPanel = new Panel();
                                defaultPanel.animateIn(true);

                                defaultItems.forEach(data => {
                                    defaultPanel.add(new PanelItem(data));
                                });

                                item.setContent(defaultPanel);
                            }

                            RenderManager.display = DisplayOptions[value];

                            if (RenderManager.display === DisplayOptions.Default) {
                                item.toggleContent(true);
                            } else {
                                item.toggleContent(false);
                            }
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: physicsOptions,
                        value: getKeyByValue(physicsOptions, SceneController.enabled),
                        callback: value => {
                            SceneController.enabled = physicsOptions[value];
                            drawBuffers.saveState = SceneController.enabled;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Gravity',
                        min: -10,
                        max: 10,
                        step: 0.1,
                        value: -gravity.y,
                        callback: value => {
                            gravity.y = -value;
                            physics.setGravity(gravity);
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Interp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: drawBuffers.interpolateGeometry,
                        callback: value => {
                            drawBuffers.interpolateGeometry = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smear',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: drawBuffers.smearIntensity,
                        callback: value => {
                            drawBuffers.smearIntensity = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Datamosh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: datamoshMaterial.uniforms.uAmount.value,
                        callback: value => {
                            datamoshMaterial.uniforms.uAmount.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Lossy',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: datamoshMaterial.uniforms.uLossy.value,
                        callback: value => {
                            datamoshMaterial.uniforms.uLossy.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Damping',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: datamoshMaterial.uniforms.uDamping.value,
                        callback: value => {
                            datamoshMaterial.uniforms.uDamping.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Decay',
                        min: 0.6,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDecay.value,
                        callback: value => {
                            vlMaterial.uniforms.uDecay.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDensity.value,
                        callback: value => {
                            vlMaterial.uniforms.uDensity.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Weight',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uWeight.value,
                        callback: value => {
                            vlMaterial.uniforms.uWeight.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Scale X',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: vlMaterial.uniforms.uLensflareScale.value.x,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareScale.value.x = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale Y',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: vlMaterial.uniforms.uLensflareScale.value.y,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareScale.value.y = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uLensflareExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uLensflareClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uLensflareClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: balls.uniforms.thicknessDistortion.value,
                        callback: value => {
                            balls.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: balls.uniforms.thicknessAmbient.value,
                        callback: value => {
                            balls.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: balls.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            balls.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: balls.uniforms.thicknessPower.value,
                        callback: value => {
                            balls.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: balls.uniforms.thicknessScale.value,
                        callback: value => {
                            balls.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, view) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;

                // Volumetric light and lens flare
                this.lightPosition = new Vector3();
                this.vlExposure = 0.1;
                this.vlDecay = 1;
                this.vlDensity = 1;
                this.vlWeight = 0.4;
                this.vlClamp = 1;
                this.lensflareScale = new Vector2(2.5, 2.5);
                this.lensflareExposure = 0.02;
                this.lensflareClamp = 1;
                this.blurResolutionScale = 0.25;
                this.blurAmount = 2.5;

                // Datamosh
                this.datamoshAmount = 1;
                this.datamoshLossy = 1;
                this.datamoshDamping = 0.96;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                // Debug
                DisplayOptions.Light = 8;
                this.display = DisplayOptions.Default;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution, time, frame, textureLoader, getTexture } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Clear colors
                this.clearColor = new Color(0, 0, 0);
                this.currentClearColor = new Color();

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.datamosh = getDoubleRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBlurA = this.renderTargetA.clone();
                this.renderTargetBlurB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetBlurA.depthBuffer = true;

                // G-Buffer
                this.drawBuffers = new DrawBuffers(this.renderer, this.scene, this.camera, layers.buffers, {
                    cameraBlur: false
                });

                // Motion blur composite material
                this.motionBlurCompositeMaterial = new MotionBlurCompositeMaterial(textureLoader, {
                    blueNoisePath: 'blue_noise.png'
                });
                this.motionBlurCompositeMaterial.uniforms.tVelocity.value = this.drawBuffers.renderTarget.textures[1];

                // Occlusion material
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Volumetric light material
                this.vlMaterial = new VolumetricLightLensflareMaterial();
                this.vlMaterial.uniforms.uExposure.value = this.vlExposure;
                this.vlMaterial.uniforms.uDecay.value = this.vlDecay;
                this.vlMaterial.uniforms.uDensity.value = this.vlDensity;
                this.vlMaterial.uniforms.uWeight.value = this.vlWeight;
                this.vlMaterial.uniforms.uClamp.value = this.vlClamp;
                this.vlMaterial.uniforms.uLensflareScale.value = this.lensflareScale;
                this.vlMaterial.uniforms.uLensflareExposure.value = this.lensflareExposure;
                this.vlMaterial.uniforms.uLensflareClamp.value = this.lensflareClamp;
                this.vlMaterial.uniforms.uResolution = resolution;

                // Datamosh material
                this.datamoshMaterial = new DatamoshMaterial();
                this.datamoshMaterial.uniforms.tVelocity.value = this.drawBuffers.renderTarget.textures[1];
                this.datamoshMaterial.uniforms.uAmount.value = this.datamoshAmount;
                this.datamoshMaterial.uniforms.uLossy.value = this.datamoshLossy;
                this.datamoshMaterial.uniforms.uDamping.value = this.datamoshDamping;
                this.datamoshMaterial.uniforms.uResolution = resolution;
                this.datamoshMaterial.uniforms.uTime = time;
                this.datamoshMaterial.uniforms.uFrame = frame;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();

                // Debug materials
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });
                this.matcap1Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/040full.jpg') });
                this.matcap2Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/defaultwax.jpg') });
                this.normalMaterial = new NormalMaterial();
                this.normalMaterialInstanced = new NormalMaterial({ instancing: true });
                this.depthMaterial = new DepthMaterial();
                this.depthMaterialInstanced = new DepthMaterial({ instancing: true });
                this.copyMaterial = new CopyMaterial();

                // Based on https://github.com/mrdoob/three.js/issues/26732#issuecomment-1741276120 by donmccurdy
                this.originalMaterials = new Map();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static setLightPosition() {
                this.lightPosition.copy(this.view.sphere.position).project(this.camera);

                const x = (this.lightPosition.x + 1) / 2;
                const y = (this.lightPosition.y + 1) / 2;

                this.vlMaterial.uniforms.uLightPosition.value.set(x, y);
            }

            static rendererState() {
                this.currentOverrideMaterial = this.scene.overrideMaterial;
                this.currentBackground = this.scene.background;
                this.renderer.getClearColor(this.currentClearColor);
                this.currentClearAlpha = this.renderer.getClearAlpha();
            }

            static restoreRendererState() {
                this.scene.overrideMaterial = this.currentOverrideMaterial;
                this.scene.background = this.currentBackground;
                this.renderer.setClearColor(this.currentClearColor, this.currentClearAlpha);

                // Restore original materials
                for (const [object, material] of this.originalMaterials.entries()) {
                    object.material = material;
                }
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.datamosh.setSize(width, height);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                this.drawBuffers.setSize(width, height);

                // Gaussian blur
                const blurWidth = Math.round(width * this.blurResolutionScale);
                const blurHeight = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(blurWidth, blurHeight);
                this.renderTargetBlurB.setSize(blurWidth, blurHeight);

                this.hBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);
                this.vBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Renderer state
                this.rendererState();

                // G-Buffer layer
                camera.layers.set(layers.buffers);

                this.drawBuffers.update();

                if (this.display === DisplayOptions.Velocity) {
                    // Debug pass (render to screen)
                    this.copyMaterial.uniforms.tMap.value = this.drawBuffers.renderTarget.textures[1];
                    this.screen.material = this.copyMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                }

                // Scene layer
                camera.layers.set(layers.default);

                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Occlusion layer
                scene.background = null;

                scene.overrideMaterial = this.blackoutMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = this.currentOverrideMaterial;

                camera.layers.set(layers.occlusion);

                renderer.render(scene, camera);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Volumetric light pass
                this.vlMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.setLightPosition();
                this.screen.material = this.vlMaterial;

                if (this.display === DisplayOptions.Light) {
                    // Debug pass (render to screen)
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                } else {
                    renderer.setRenderTarget(renderTargetBlurB);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Post-processing
                camera.layers.set(layers.default);

                scene.background = null;
                renderer.setClearColor(this.clearColor, 1);

                // Debug override material passes (render to screen)
                if (this.display === DisplayOptions.Depth) {
                    scene.traverseVisible(object => {
                        if (object.material) {
                            this.originalMaterials.set(object, object.material);

                            if (object.isInstancedMesh) {
                                object.material = this.depthMaterialInstanced;
                            } else {
                                object.material = this.depthMaterial;
                            }
                        }
                    });

                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);

                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Geometry) {
                    scene.traverseVisible(object => {
                        if (object.material) {
                            this.originalMaterials.set(object, object.material);

                            if (object.isInstancedMesh) {
                                object.material = this.normalMaterialInstanced;
                            } else {
                                object.material = this.normalMaterial;
                            }
                        }
                    });

                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);

                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Matcap1) {
                    scene.overrideMaterial = this.matcap1Material;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Matcap2) {
                    scene.overrideMaterial = this.matcap2Material;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                }

                // Motion blur pass
                this.motionBlurCompositeMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.motionBlurCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Datamosh pass
                this.datamoshMaterial.uniforms.tOld.value = this.datamosh.read.texture;
                this.datamoshMaterial.uniforms.tNew.value = renderTargetB.texture;
                this.screen.material = this.datamoshMaterial;
                renderer.setRenderTarget(this.datamosh.write);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
                this.datamosh.swap();

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = this.datamosh.read.texture;

                if (this.display === DisplayOptions.Luma) {
                    // Debug pass (render to screen)
                    this.screen.material = this.blackoutMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.screen.material = this.luminosityMaterial;
                    this.screen.material.blending = AdditiveBlending;
                    renderer.render(this.screen, this.screenCamera);
                    this.screen.material.blending = NoBlending;
                    this.restoreRendererState();
                    return;
                } else {
                    this.screen.material = this.luminosityMaterial;
                    renderer.setRenderTarget(renderTargetBright);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;

                if (this.display === DisplayOptions.Bloom) {
                    // Debug pass (render to screen)
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                } else {
                    renderer.setRenderTarget(renderTargetsHorizontal[0]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tPosition.value = this.drawBuffers.renderTarget.textures[0];
                this.compositeMaterial.uniforms.tVelocity.value = this.drawBuffers.renderTarget.textures[1];
                this.compositeMaterial.uniforms.tScene.value = this.datamosh.read.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.compositeMaterial.uniforms.tAdd.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Restore renderer settings
                this.restoreRendererState();
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.targetXY.x = 1;
                } else {
                    this.targetXY.x = 2;
                }
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initPhysics();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(35);
                this.camera.near = 1;
                this.camera.far = 3000;
                this.camera.position.z = 40;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.quad = new PlaneGeometry(1, 1);
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initPhysics() {
                this.physics = new OimoPhysics({
                    gravity: new Vector3(0, 0, 0)
                });
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera, physics } = WorldController;

                CameraController.init(camera);
                SceneController.init(physics, this.view);
                RenderManager.init(renderer, scene, camera, this.view);
            }

            static initPanel() {
                const { physics } = WorldController;

                PanelController.init(physics, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_depth.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Depth Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { Color, ColorManagement, GLSL3, Group, LinearSRGBColorSpace, Mesh, OrbitControls, PanelItem, PerspectiveCamera, RawShaderMaterial, Scene, SphereGeometry, UI, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://github.com/spite/perlin-experiments

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';
        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class DepthMaterial extends RawShaderMaterial {
            constructor() {
                const { camera, time } = WorldController;

                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        uAperture: { value: camera.position.z },
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec3 normal;

                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;

                        uniform float uAperture;
                        uniform float uTime;

                        out vec3 vColor;

                        ${periodic3d}

                        void main() {
                            float linearDepth = 1.0 / uAperture;
                            float linearPos = length(cameraPosition - position) * linearDepth;

                            vColor = vec3(1.0 - linearPos);

                            float f = 0.05 * pnoise(vec3(2.0 * normal + uTime), vec3(10.0));

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position + f * normal, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        in vec3 vColor;

                        out vec4 FragColor;

                        ${dither}

                        void main() {
                            FragColor = vec4(vColor, 1.0);

                            FragColor.rgb = dither(FragColor.rgb);
                            FragColor.a = 1.0;
                        }
                    `
                });
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                this.mesh = new Mesh(
                    new SphereGeometry(1, 80, 80),
                    new DepthMaterial()
                );
                this.add(this.mesh);
            }

            // Public methods

            resize = () => {
                const { camera } = WorldController;

                this.mesh.material.uniforms.uAperture.value = camera.position.z;
            };
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
                this.view.resize();
            };
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { mesh } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Aperture',
                        min: 0,
                        max: 50,
                        step: 0.1,
                        value: mesh.material.uniforms.uAperture.value,
                        callback: value => {
                            mesh.material.uniforms.uAperture.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_dof_fake.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Depth of Field Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BufferGeometry, Color, ColorManagement, CopyMaterial, DepthTexture, DirectionalLight, EnvironmentTextureLoader, Float32BufferAttribute, GLSL3, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OrbitControls, OrthographicCamera, PanelItem, PerspectiveCamera, Points, RawShaderMaterial, RepeatWrapping, Scene, SphereGeometry, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, ticker } from '../../build/alien.three.js';

        const isDebug = /[?&]debug/.test(location.search);

        // Based on https://www.shadertoy.com/view/4lVfDt by battlebottle

        class BokehBlurMaterial1 extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: null },
                        uPower: { value: 3 },
                        uAmount: { value: 1 },
                        uResolution: { value: new Vector2() }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        #define PI          3.14
                        #define TWO_PI      6.28
                        #define MAX_SAMPLES 28.0

                        uniform sampler2D tMap;
                        uniform float uPower;
                        uniform float uAmount;
                        uniform vec2 uResolution;

                        in vec2 vUv;

                        out vec4 FragColor;

                        const float blurRadMax = 0.08;
                        const float blurCircles = 4.0;

                        void main() {
                            vec2 uv = vUv - 0.5;
                            uv.x *= uResolution.x / uResolution.y;
                            uv += 0.5;

                            float amount = length(uv - 0.5);
                            amount = pow(amount, uPower);
                            amount *= uAmount;

                            float blurRadius = blurRadMax * amount;

                            float totalSamples = 0.0;
                            vec3 colAcum = vec3(0.0);

                            for (float currentCircle = 0.0; currentCircle < blurCircles; currentCircle++) {
                                float samplesForCurrentCircle = (pow(currentCircle + 1.0, 2.0) - pow(currentCircle, 2.0)) * 4.0;
                                float currentRadius = (blurRadius / blurCircles) * (currentCircle + 0.5);

                                for (float currentSample = 0.0; currentSample < MAX_SAMPLES; currentSample++) {
                                    if (currentSample >= samplesForCurrentCircle) break;

                                    vec2 samplePoint = vec2(0.0, currentRadius);
                                    float angle = TWO_PI * ((currentSample + 0.5) / samplesForCurrentCircle);

                                    float s = sin(angle);
                                    float c = cos(angle);
                                    mat2 m = mat2(c, -s, s, c);
                                    samplePoint = m * samplePoint;

                                    samplePoint *= vec2(uResolution.y / uResolution.x, 1.0);

                                    totalSamples++;
                                    colAcum += texture(tMap, vUv + samplePoint, blurRadius * 30.0).rgb;
                                }
                            }

                            FragColor = vec4(colAcum / totalSamples, 1.0);
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class BokehBlurMaterial2 extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: null },
                        uPower: { value: 3 },
                        uAmount: { value: 1 },
                        uDebug: { value: isDebug },
                        uResolution: { value: new Vector2() }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        #define PI          3.14
                        #define TWO_PI      6.28
                        #define MAX_SAMPLES 20.0

                        uniform sampler2D tMap;
                        uniform float uPower;
                        uniform float uAmount;
                        uniform bool uDebug;
                        uniform vec2 uResolution;

                        in vec2 vUv;

                        out vec4 FragColor;

                        const float blurRadMax = 0.08;
                        const float blurCircles = 3.0;

                        void main() {
                            vec2 uv = vUv - 0.5;
                            uv.x *= uResolution.x / uResolution.y;
                            uv += 0.5;

                            float amount = length(uv - 0.5);
                            amount = pow(amount, uPower);
                            amount *= uAmount;

                            float blurRadius = blurRadMax * amount * 0.3;

                            float totalSamples = 0.0;
                            vec3 colAcum = vec3(0.0);

                            for (float currentCircle = 0.0; currentCircle < blurCircles; currentCircle++) {
                                float samplesForCurrentCircle = (pow(currentCircle + 1.0, 2.0) - pow(currentCircle, 2.0)) * 4.0;
                                float currentRadius = (blurRadius / blurCircles) * (currentCircle + 0.5);

                                for (float currentSample = 0.0; currentSample < MAX_SAMPLES; currentSample++) {
                                    if (currentSample >= samplesForCurrentCircle) break;

                                    vec2 samplePoint = vec2(0.0, currentRadius);
                                    float angle = TWO_PI * ((currentSample + 0.5) / samplesForCurrentCircle);

                                    float s = sin(angle);
                                    float c = cos(angle);
                                    mat2 m = mat2(c, -s, s, c);
                                    samplePoint = m * samplePoint;

                                    samplePoint *= vec2(uResolution.y / uResolution.x, 1.0);

                                    totalSamples++;
                                    colAcum = max(colAcum, texture(tMap, vUv + samplePoint).rgb);
                                }
                            }

                            FragColor = vec4(colAcum, 1.0);

                            if (uDebug) {
                                FragColor.rgb = mix(FragColor.rgb, mix(FragColor.rgb, vec3(1), 0.5), amount);
                            }
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        import simplex3d from '../../src/shaders/modules/noise/simplex3d.glsl.js';
        import depth from '../../src/shaders/modules/depth/depth.glsl.js';

        class Dust extends Group {
            constructor(numParticles) {
                super();

                this.numParticles = numParticles;

                this.initPoints();
            }

            initPoints() {
                const { camera, getTexture, resolution, time } = WorldController;

                const vertices = [];

                for (let i = 0; i < this.numParticles; i++) {
                    vertices[i * 3 + 0] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 1] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 2] = MathUtils.randFloatSpread(camera.far / 2);
                }

                const geometry = new BufferGeometry();
                geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));

                // Based on https://jsfiddle.net/m7tvxpbs/ by Mugen87

                const material = new RawShaderMaterial({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: getTexture('particle.png') },
                        tDepth: { value: null },
                        uScale: { value: window.devicePixelRatio / 2 },
                        uAlpha: { value: 1 },
                        uCameraNear: { value: camera.near },
                        uCameraFar: { value: camera.far },
                        uResolution: resolution,
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;

                        uniform mat4 modelMatrix;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;

                        uniform float uScale;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform float uTime;

                        out float vFade;

                        ${simplex3d}

                        void main() {
                            vec3 p = position;
                            p.x += snoise(position.xyz + uTime * 0.02);
                            p.y += snoise(position.yyz + uTime * 0.02);
                            p.z += snoise(position.zxy + uTime * 0.02);

                            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);

                            gl_PointSize = uScale * (150.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;

                            vec3 worldPosition = (modelMatrix * vec4(p, 1.0)).xyz;
                            float linearDepth = 1.0 / (uCameraFar - uCameraNear);
                            float linearPos = length(cameraPosition - worldPosition) * linearDepth;

                            vFade = 1.0 - linearPos * 0.75;
                            vFade *= smoothstep(0.09, 0.13, linearPos);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        #include <packing>

                        uniform sampler2D tMap;
                        uniform sampler2D tDepth;
                        uniform float uAlpha;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform vec2 uResolution;

                        in float vFade;

                        out vec4 FragColor;

                        ${depth}

                        float fadeEdge(float particleDepth, float sceneDepth) {
                            // Margin makes it blend through the solid objects a little bit more,
                            // creating illusion of density
                            float extraMargin = 0.015;
                            float a = (sceneDepth + extraMargin - particleDepth) * 120.0;

                            if (a <= 0.0) return 0.0;
                            if (a >= 1.0) return 1.0;

                            if (a < 0.5) a = 2.0 * a * a;
                            else a = -2.0 * pow(a - 1.0, 2.0) + 1.0;

                            return a;
                        }

                        void main() {
                            FragColor = texture(tMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));

                            vec2 uv = gl_FragCoord.xy / uResolution;
                            float particleDepth = getDepth(gl_FragCoord.z, uCameraNear, uCameraFar);
                            float sceneDepth = getDepth(tDepth, uv, uCameraNear, uCameraFar);
                            float alphaScale = fadeEdge(particleDepth, sceneDepth);

                            FragColor.a *= alphaScale;
                            FragColor.a *= vFade;
                            FragColor.a *= uAlpha;
                        }
                    `,
                    transparent: true,
                    blending: AdditiveBlending,
                    depthTest: false,
                    depthWrite: false
                });

                const points = new Points(geometry, material);
                this.add(points);

                this.material = material;
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(0x060606),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { bokehBlurMaterial1, bokehBlurMaterial2, luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const debugOptions = {
                    Off: false,
                    Debug: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 0,
                        max: 6,
                        step: 0.01,
                        value: bokehBlurMaterial1.uniforms.uPower.value,
                        callback: value => {
                            bokehBlurMaterial1.uniforms.uPower.value = value;
                            bokehBlurMaterial2.uniforms.uPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Amount',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: bokehBlurMaterial1.uniforms.uAmount.value,
                        callback: value => {
                            bokehBlurMaterial1.uniforms.uAmount.value = value;
                            bokehBlurMaterial2.uniforms.uAmount.value = value;
                        }
                    },
                    {
                        type: 'list',
                        list: debugOptions,
                        value: getKeyByValue(debugOptions, bokehBlurMaterial2.uniforms.uDebug.value),
                        callback: value => {
                            bokehBlurMaterial2.uniforms.uDebug.value = debugOptions[value];
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, dust) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.dust = dust;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetA.depthTexture = new DepthTexture();

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Blend it additively
                this.bloomCompositeMaterial.blending = AdditiveBlending;

                // Dust scene
                this.dustScene = new Scene();
                this.dustScene.add(this.dust);

                this.dust.material.uniforms.tDepth.value = this.renderTargetA.depthTexture;

                // Bokeh blur materials
                this.bokehBlurMaterial1 = new BokehBlurMaterial1();
                this.bokehBlurMaterial1.uniforms.uResolution = resolution;

                this.bokehBlurMaterial2 = new BokehBlurMaterial2();
                this.bokehBlurMaterial2.uniforms.uResolution = resolution;

                // Copy material
                this.copyMaterial = new CopyMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.screen, this.screenCamera);

                // Dust scene
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.dustScene, camera);

                // Two pass Bokeh blur
                this.bokehBlurMaterial1.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.bokehBlurMaterial1;
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.bokehBlurMaterial2.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.bokehBlurMaterial2;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Copy pass (render to screen)
                this.copyMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.dust = new Dust(1000);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera, this.dust);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_film_grain.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Film Grain Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BoxGeometry, BufferGeometry, Color, ColorManagement, DirectionalLight, Float32BufferAttribute, GLSL3, Group, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OrthographicCamera, PanelItem, PlaneGeometry, RawShaderMaterial, Scene, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, ticker } from '../../build/alien.three.js';

        const breakpoint = 1000;

        import random from '../../src/shaders/modules/random/random.glsl.js';
        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                const { time } = WorldController;

                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        uBloomDistortion: { value: 1.5 },
                        uGrainAmount: { value: 0.2 },
                        uReduction: { value: 0.9 },
                        uBoost: { value: 1.1 },
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform float uBloomDistortion;
                        uniform float uGrainAmount;
                        uniform float uReduction;
                        uniform float uBoost;
                        uniform float uTime;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${random}
                        ${rgbshift}

                        void main() {
                            float center = length(vUv - 0.5);

                            FragColor = texture(tScene, vUv);

                            float angle = length(vUv - 0.5);
                            float amount = 0.001 * uBloomDistortion;

                            FragColor.rgb += getRGB(tBloom, vUv, angle, amount).rgb;

                            // Film grain
                            FragColor.rgb += vec3(uGrainAmount * random(vUv + vec2(uTime, 0.0) * 0.06));

                            // Vignetting
                            FragColor.rgb *= uBoost - center * uReduction;
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        // Based on https://codepen.io/zachgoldstein/pen/LXRXVw

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const material = new MeshStandardMaterial({ metalness: 1 });

                // Penrose triangle geometry
                const bottomBox = new BoxGeometry(50, 50, 300);
                const bottomMesh = new Mesh(bottomBox, material);
                this.add(bottomMesh);

                const upBox = new BoxGeometry(50, 250, 50);
                const upMesh = new Mesh(upBox, material);
                upMesh.position.set(0, 150, 125);
                this.add(upMesh);

                const topBox = new BoxGeometry(150, 50, 50);
                const topMesh = new Mesh(topBox, material);
                topMesh.position.set(100, 250, 125);
                this.add(topMesh);

                const topPlane = new PlaneGeometry(50, 50);
                const topPlaneMesh = new Mesh(topPlane, material);
                topPlaneMesh.position.set(200, 275, 125);
                topPlaneMesh.rotation.x = MathUtils.degToRad(-90);
                this.add(topPlaneMesh);

                const topTri = new BufferGeometry();
                topTri.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 50, 0, 0, 0, 50, 0], 3));
                topTri.setAttribute('uv', new Float32BufferAttribute([0, 0, 1, 0, 0, 1], 2));
                topTri.computeVertexNormals();
                const topTriMesh = new Mesh(topTri, material);
                topTriMesh.position.set(175, 275, 150);
                topTriMesh.scale.y = -1;
                this.add(topTriMesh);

                // Centre
                this.position.y = -62.5;
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const postOptions = {
                    Off: false,
                    Post: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: value => {
                            RenderManager.enabled = postOptions[value];
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Grain',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uGrainAmount.value,
                        callback: value => {
                            compositeMaterial.uniforms.uGrainAmount.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Reduce',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uReduction.value,
                        callback: value => {
                            compositeMaterial.uniforms.uReduction.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Boost',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uBoost.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBoost.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Film grain and vignetting
                this.grainAmount = 0.2;
                this.reduction = 0.9;
                this.boost = 1.1;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial({ dithering: true });
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
                this.compositeMaterial.uniforms.uGrainAmount.value = this.grainAmount;
                this.compositeMaterial.uniforms.uReduction.value = this.reduction;
                this.compositeMaterial.uniforms.uBoost.value = this.boost;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // Isometric scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new OrthographicCamera();
                this.camera.near = 0;
                this.camera.far = 3000;
                this.camera.zoom = 1;
                this.camera.position.set(500, 500, 500);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                const light = new DirectionalLight(0xffffff, 7);
                light.position.set(60, 100, 20);
                this.scene.add(light);
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.left = -width / 2;
                this.camera.right = width / 2;
                this.camera.top = height / 2;
                this.camera.bottom = -height / 2;

                if (width < breakpoint) {
                    this.camera.zoom = 0.8;
                } else {
                    this.camera.zoom = 1;
                }

                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_flowmap_rgbshift.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Flowmap Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Flowmap, Fog, GLSL3, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, NoBlending, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, RawShaderMaterial, Reflector, RepeatWrapping, SVGLoader, Scene, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://oframe.github.io/ogl/examples/?src=mouse-flowmap.html by gordonnl

        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        tFlow: { value: null },
                        uBloomDistortion: { value: 1.5 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform sampler2D tFlow;
                        uniform float uBloomDistortion;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${rgbshift}
                        ${dither}

                        void main() {
                            // R and G values are velocity in the X and Y direction
                            // B value is the velocity length
                            vec3 flow = texture(tFlow, vUv).rgb;

                            // Use flow to adjust the UV lookup of a texture
                            vec2 uv = vUv - flow.rg * 0.05;

                            vec2 dir = 0.5 - vUv;
                            float angle = atan(dir.y, dir.x);
                            float amount = length(flow.rg) * 0.025;

                            FragColor = getRGB(tScene, uv, angle, amount);

                            FragColor.rgb += getRGB(tBloom, uv, angle, amount + 0.001 * uBloomDistortion).rgb;

                            FragColor.rgb = dither(FragColor.rgb);
                            FragColor.a = 1.0;
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { camera, loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.position.set(0, 1.4, -11);
                group.scale.y *= -1;
                group.lookAt(camera.position);

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/polished_concrete_basecolor.jpg'),
                    loadTexture('pbr/polished_concrete_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/polished_concrete_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const uniforms = {
                    mirror: { value: 0 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture2D(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new Triangle();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { flowmap, luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Falloff',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: flowmap.material.uniforms.uFalloff.value,
                        callback: value => {
                            flowmap.material.uniforms.uFalloff.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Alpha',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: flowmap.material.uniforms.uAlpha.value,
                        callback: value => {
                            flowmap.material.uniforms.uAlpha.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Dissipate',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: flowmap.material.uniforms.uDissipation.value,
                        callback: value => {
                            flowmap.material.uniforms.uDissipation.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.width = 1;
                this.height = 1;

                // Flowmap
                this.mouse = new Vector2(-1, -1);
                this.velocity = new Vector2();
                this.lastTime = 0;
                this.lastMouse = new Vector2();

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();

                this.addListeners();
            }

            static initRenderer() {
                const { screenTriangle, aspect } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Flowmap
                this.flowmap = new Flowmap(this.renderer);
                this.flowmap.material.uniforms.uAspect = aspect;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.tFlow = this.flowmap.uniform;
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                const event = {
                    x: clientX,
                    y: clientY
                };

                // Get mouse value in 0 to 1 range, with Y flipped
                this.mouse.set(
                    event.x / this.width,
                    1 - event.y / this.height
                );

                // First frame
                if (!this.lastTime) {
                    this.lastTime = performance.now();
                    this.lastMouse.copy(event);
                }

                const deltaX = event.x - this.lastMouse.x;
                const deltaY = event.y - this.lastMouse.y;

                this.lastMouse.copy(event);

                const time = performance.now();

                // Avoid dividing by 0
                const delta = Math.max(14, time - this.lastTime);
                this.lastTime = time;

                // Calculate velocity
                this.velocity.x = deltaX / delta;
                this.velocity.y = deltaY / delta;

                // Flag update to prevent hanging velocity values when not moving
                this.velocity.needsUpdate = true;
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.width = width;
                this.height = height;

                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Reset velocity when mouse not moving
                if (!this.velocity.needsUpdate) {
                    this.mouse.set(-1, -1);
                    this.velocity.set(0, 0);
                    this.lastTime = 0;
                }
                this.velocity.needsUpdate = false;

                // Update flowmap inputs
                this.flowmap.mouse.copy(this.mouse);

                // Ease velocity input, slower when fading out
                this.flowmap.velocity.lerp(this.velocity, this.velocity.length() ? 0.5 : 0.1);
                this.flowmap.update();

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_flowmap_view.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Flowmap Post-processing View — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Flowmap, Fog, GLSL3, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, RawShaderMaterial, Reflector, RepeatWrapping, SVGLoader, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getViewSize, ticker } from '../../build/alien.three.js';

        // Based on https://oframe.github.io/ogl/examples/?src=mouse-flowmap.html by gordonnl

        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';

        class FlowMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: null },
                        tFlow: { value: null }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tMap;
                        uniform sampler2D tFlow;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${rgbshift}

                        void main() {
                            // R and G values are velocity in the X and Y direction
                            // B value is the velocity length
                            vec3 flow = texture(tFlow, vUv).rgb;

                            // Use flow to adjust the UV lookup of a texture
                            vec2 uv = vUv - flow.rg * 0.05;

                            vec2 dir = 0.5 - vUv;
                            float angle = atan(dir.y, dir.x);
                            float amount = length(flow.rg) * 0.025;

                            FragColor = getRGB(tMap, uv, angle, amount);
                            FragColor.a = 1.0;
                        }
                    `,
                    blending: AdditiveBlending
                });
            }
        }

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.scale.y *= -1;

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }
        }

        class TriangleView extends Group {
            constructor() {
                super();

                this.width = 8;
                this.height = 6;
                this.isLoaded = false;

                this.initRenderer();
                this.initMesh();
                this.initViews();
            }

            initRenderer() {
                const { renderer, aspect } = WorldController;

                this.renderer = renderer;

                // 2D scene
                this.scene = new Scene();
                this.camera = new OrthographicCamera(-this.width / 2, this.width / 2, this.height / 2, -this.height / 2, 0, 1);

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                // Flowmap
                this.flowmap = new Flowmap(this.renderer, {
                    alpha: 0.25
                });
                this.flowmap.material.uniforms.uAspect = aspect;
            }

            initMesh() {
                const { camera, quad } = WorldController;

                const material = new FlowMaterial();
                material.uniforms.tMap.value = this.renderTarget.texture;
                material.uniforms.tFlow = this.flowmap.uniform;

                const mesh = new Mesh(quad, material);
                mesh.position.set(0, 1.4, -11);
                mesh.scale.set(this.width, this.height, 1);
                mesh.lookAt(camera.position);
                mesh.renderOrder = 1; // Render last (default is 0)

                this.add(mesh);

                this.mesh = mesh;
            }

            initViews() {
                this.triangle = new Triangle();

                // Reduce size to make room for flowmap dissipation
                this.triangle.scale.multiplyScalar(0.8);

                this.scene.add(this.triangle);
            }

            // Public methods

            resize = (width, height, dpr) => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.mesh.position.z);

                this.widthResolutionScale = this.width / x;
                this.heightResolutionScale = this.height / y;

                width = Math.round(width * dpr * this.widthResolutionScale);
                height = Math.round(height * dpr * this.heightResolutionScale);

                this.renderTarget.setSize(width, height);

                if (this.isLoaded) {
                    this.update();
                }
            };

            update = () => {
                // Renderer state
                const currentRenderTarget = this.renderer.getRenderTarget();

                // Scene pass
                this.renderer.setRenderTarget(this.renderTarget);
                this.renderer.render(this.scene, this.camera);

                // Restore renderer settings
                this.renderer.setRenderTarget(currentRenderTarget);
            };

            ready = async () => {
                await this.triangle.initMesh();

                this.isLoaded = true;

                this.update();
            };
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/polished_concrete_basecolor.jpg'),
                    loadTexture('pbr/polished_concrete_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/polished_concrete_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const uniforms = {
                    mirror: { value: 0 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture2D(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new TriangleView();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height, dpr) => {
                this.floor.resize(width, height);
                this.triangle.resize(width, height, dpr);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(camera, view) {
                this.camera = camera;
                this.view = view;

                // Flowmap
                this.mouse = new Vector2(-1, -1);
                this.velocity = new Vector2();
                this.lastTime = 0;
                this.lastMouse = new Vector2();

                this.triangleWorldPosition = new Vector3();
                this.screenSpacePosition = new Vector3();

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                const event = {
                    x: clientX,
                    y: clientY
                };

                // Adjust for triangle screen space
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;
                const triangleWidth = Math.round(this.width * this.view.triangle.widthResolutionScale);
                const triangleHeight = Math.round(this.height * this.view.triangle.heightResolutionScale);
                const triangleHalfWidth = triangleWidth / 2;
                const triangleHalfHeight = triangleHeight / 2;

                this.triangleWorldPosition.setFromMatrixPosition(this.view.triangle.mesh.matrixWorld);
                this.screenSpacePosition.copy(this.triangleWorldPosition).project(this.camera);

                this.screenSpacePosition.x = (this.screenSpacePosition.x * halfWidth) + halfWidth - triangleHalfWidth;
                this.screenSpacePosition.y = -(this.screenSpacePosition.y * halfHeight) + halfHeight - triangleHalfHeight;

                // Get mouse value in 0 to 1 range, with Y flipped
                this.mouse.set(
                    MathUtils.mapLinear(event.x, this.screenSpacePosition.x, this.screenSpacePosition.x + triangleWidth, 0, 1),
                    1 - MathUtils.mapLinear(event.y, this.screenSpacePosition.y, this.screenSpacePosition.y + triangleHeight, 0, 1)
                );

                // First frame
                if (!this.lastTime) {
                    this.lastTime = performance.now();
                    this.lastMouse.copy(event);
                }

                const deltaX = event.x - this.lastMouse.x;
                const deltaY = event.y - this.lastMouse.y;

                this.lastMouse.copy(event);

                const time = performance.now();

                // Avoid dividing by 0
                const delta = Math.max(14, time - this.lastTime);
                this.lastTime = time;

                // Calculate velocity
                this.velocity.x = deltaX / delta;
                this.velocity.y = deltaY / delta;

                // Flag update to prevent hanging velocity values when not moving
                this.velocity.needsUpdate = true;
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.width = width;
                this.height = height;

                this.view.resize(width, height, dpr);
            };

            static update = () => {
                // Reset velocity when mouse not moving
                if (!this.velocity.needsUpdate) {
                    this.mouse.set(-1, -1);
                    this.velocity.set(0, 0);
                    this.lastTime = 0;
                }
                this.velocity.needsUpdate = false;

                // Update flowmap inputs
                this.view.triangle.flowmap.mouse.copy(this.mouse);

                // Ease velocity input, slower when fading out
                this.view.triangle.flowmap.velocity.lerp(this.velocity, this.velocity.length() ? 0.5 : 0.1);
                this.view.triangle.flowmap.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { triangle } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Falloff',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: triangle.flowmap.material.uniforms.uFalloff.value,
                        callback: value => {
                            triangle.flowmap.material.uniforms.uFalloff.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Alpha',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: triangle.flowmap.material.uniforms.uAlpha.value,
                        callback: value => {
                            triangle.flowmap.material.uniforms.uAlpha.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Dissipate',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: triangle.flowmap.material.uniforms.uDissipation.value,
                        callback: value => {
                            triangle.flowmap.material.uniforms.uDissipation.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.quad = new PlaneGeometry(1, 1);
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(camera, this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_flowmap.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Flowmap Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Flowmap, Fog, GLSL3, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, NoBlending, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, RawShaderMaterial, Reflector, RepeatWrapping, SVGLoader, Scene, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://oframe.github.io/ogl/examples/?src=mouse-flowmap.html by gordonnl

        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        tFlow: { value: null },
                        uBloomDistortion: { value: 1.5 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform sampler2D tFlow;
                        uniform float uBloomDistortion;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${rgbshift}
                        ${dither}

                        void main() {
                            // R and G values are velocity in the X and Y direction
                            // B value is the velocity length
                            vec3 flow = texture(tFlow, vUv).rgb;

                            // Use flow to adjust the UV lookup of a texture
                            vec2 uv = vUv - flow.rg * 0.05;

                            FragColor = texture(tScene, uv);

                            vec2 dir = 0.5 - vUv;
                            float angle = atan(dir.y, dir.x);
                            float amount = 0.001 * uBloomDistortion;

                            FragColor.rgb += getRGB(tBloom, uv, angle, amount).rgb;

                            FragColor.rgb = dither(FragColor.rgb);
                            FragColor.a = 1.0;
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { camera, loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.position.set(0, 1.4, -11);
                group.scale.y *= -1;
                group.lookAt(camera.position);

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/polished_concrete_basecolor.jpg'),
                    loadTexture('pbr/polished_concrete_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/polished_concrete_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const uniforms = {
                    mirror: { value: 0 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture2D(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new Triangle();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { flowmap, luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Falloff',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: flowmap.material.uniforms.uFalloff.value,
                        callback: value => {
                            flowmap.material.uniforms.uFalloff.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Alpha',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: flowmap.material.uniforms.uAlpha.value,
                        callback: value => {
                            flowmap.material.uniforms.uAlpha.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Dissipate',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: flowmap.material.uniforms.uDissipation.value,
                        callback: value => {
                            flowmap.material.uniforms.uDissipation.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.width = 1;
                this.height = 1;

                // Flowmap
                this.mouse = new Vector2(-1, -1);
                this.velocity = new Vector2();
                this.lastTime = 0;
                this.lastMouse = new Vector2();

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();

                this.addListeners();
            }

            static initRenderer() {
                const { screenTriangle, aspect } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Flowmap
                this.flowmap = new Flowmap(this.renderer);
                this.flowmap.material.uniforms.uAspect = aspect;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.tFlow = this.flowmap.uniform;
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                const event = {
                    x: clientX,
                    y: clientY
                };

                // Get mouse value in 0 to 1 range, with Y flipped
                this.mouse.set(
                    event.x / this.width,
                    1 - event.y / this.height
                );

                // First frame
                if (!this.lastTime) {
                    this.lastTime = performance.now();
                    this.lastMouse.copy(event);
                }

                const deltaX = event.x - this.lastMouse.x;
                const deltaY = event.y - this.lastMouse.y;

                this.lastMouse.copy(event);

                const time = performance.now();

                // Avoid dividing by 0
                const delta = Math.max(14, time - this.lastTime);
                this.lastTime = time;

                // Calculate velocity
                this.velocity.x = deltaX / delta;
                this.velocity.y = deltaY / delta;

                // Flag update to prevent hanging velocity values when not moving
                this.velocity.needsUpdate = true;
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.width = width;
                this.height = height;

                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Reset velocity when mouse not moving
                if (!this.velocity.needsUpdate) {
                    this.mouse.set(-1, -1);
                    this.velocity.set(0, 0);
                    this.lastTime = 0;
                }
                this.velocity.needsUpdate = false;

                // Update flowmap inputs
                this.flowmap.mouse.copy(this.mouse);

                // Ease velocity input, slower when fading out
                this.flowmap.velocity.lerp(this.velocity, this.velocity.length() ? 0.5 : 0.1);
                this.flowmap.update();

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_fluid_distortion_rgbshift.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Fluid Distortion Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Fluid, Fog, GLSL3, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, NoBlending, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, RawShaderMaterial, Reflector, RepeatWrapping, SVGLoader, Scene, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://github.com/PavelDoGreat/WebGL-Fluid-Simulation
        // Based on https://oframe.github.io/ogl/examples/?src=post-fluid-distortion.html by gordonnl

        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        tFluid: { value: null },
                        uBloomDistortion: { value: 1.5 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform sampler2D tFluid;
                        uniform float uBloomDistortion;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${rgbshift}
                        ${dither}

                        void main() {
                            vec3 fluid = texture(tFluid, vUv).rgb;
                            vec2 uv = vUv - fluid.rg * 0.0002;

                            vec2 dir = 0.5 - vUv;
                            float angle = atan(dir.y, dir.x);
                            float amount = length(fluid.rg) * 0.0001;

                            FragColor = getRGB(tScene, uv, angle, amount);

                            FragColor.rgb += getRGB(tBloom, uv, angle, amount + 0.001 * uBloomDistortion).rgb;

                            FragColor.rgb = dither(FragColor.rgb);
                            FragColor.a = 1.0;
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { camera, loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.position.set(0, 1.4, -11);
                group.scale.y *= -1;
                group.lookAt(camera.position);

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/polished_concrete_basecolor.jpg'),
                    loadTexture('pbr/polished_concrete_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/polished_concrete_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const uniforms = {
                    mirror: { value: 0 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new Triangle();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { fluid, luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Iterate',
                        min: 0,
                        max: 10,
                        step: 1,
                        value: fluid.iterations,
                        callback: value => {
                            fluid.iterations = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.densityDissipation,
                        callback: value => {
                            fluid.densityDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Velocity',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.velocityDissipation,
                        callback: value => {
                            fluid.velocityDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Pressure',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.pressureDissipation,
                        callback: value => {
                            fluid.pressureDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Curl',
                        min: 0,
                        max: 50,
                        step: 0.1,
                        value: fluid.curlStrength,
                        callback: value => {
                            fluid.curlStrength = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.radius,
                        callback: value => {
                            fluid.radius = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.width = 1;
                this.height = 1;

                // Fluid simulation
                this.lastMouse = new Vector2();

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();

                this.addListeners();
            }

            static initRenderer() {
                const { screenTriangle, aspect } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Fluid simulation
                this.fluid = new Fluid(this.renderer, {
                    curlStrength: 0
                });
                this.fluid.splatMaterial.uniforms.uAspect = aspect;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.tFluid = this.fluid.uniform;
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                const event = {
                    x: clientX,
                    y: clientY
                };

                // First input
                if (!this.lastMouse.isInit) {
                    this.lastMouse.isInit = true;
                    this.lastMouse.copy(event);
                }

                const deltaX = event.x - this.lastMouse.x;
                const deltaY = event.y - this.lastMouse.y;

                this.lastMouse.copy(event);

                // Add if the mouse is moving
                if (Math.abs(deltaX) || Math.abs(deltaY)) {
                    // Update fluid simulation inputs
                    this.fluid.splats.push({
                        // Get mouse value in 0 to 1 range, with Y flipped
                        x: event.x / this.width,
                        y: 1 - event.y / this.height,
                        dx: deltaX * 5,
                        dy: deltaY * -5
                    });
                }
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.width = width;
                this.height = height;

                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Perform all of the fluid simulation renders
                this.fluid.update();

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_fluid_distortion_view.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Fluid Distortion Post-processing View — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Fluid, Fog, GLSL3, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, RawShaderMaterial, Reflector, RepeatWrapping, SVGLoader, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getViewSize, ticker } from '../../build/alien.three.js';

        // Based on https://github.com/PavelDoGreat/WebGL-Fluid-Simulation
        // Based on https://oframe.github.io/ogl/examples/?src=post-fluid-distortion.html by gordonnl

        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';

        class FluidMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: null },
                        tFluid: { value: null }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tMap;
                        uniform sampler2D tFluid;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${rgbshift}

                        void main() {
                            vec3 fluid = texture(tFluid, vUv).rgb;
                            vec2 uv = vUv - fluid.rg * 0.0002;

                            vec2 dir = 0.5 - vUv;
                            float angle = atan(dir.y, dir.x);
                            float amount = length(fluid.rg) * 0.0001;

                            FragColor = getRGB(tMap, uv, angle, amount);
                            FragColor.a = 1.0;
                        }
                    `,
                    blending: AdditiveBlending
                });
            }
        }

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.scale.y *= -1;

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }
        }

        class TriangleView extends Group {
            constructor() {
                super();

                this.width = 8;
                this.height = 6;
                this.isLoaded = false;

                this.initRenderer();
                this.initMesh();
                this.initViews();
            }

            initRenderer() {
                const { renderer, aspect } = WorldController;

                this.renderer = renderer;

                // 2D scene
                this.scene = new Scene();
                this.camera = new OrthographicCamera(-this.width / 2, this.width / 2, this.height / 2, -this.height / 2, 0, 1);

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                // Fluid simulation
                this.fluid = new Fluid(this.renderer, {
                    curlStrength: 0
                });
                this.fluid.splatMaterial.uniforms.uAspect = aspect;
            }

            initMesh() {
                const { camera, quad } = WorldController;

                const material = new FluidMaterial();
                material.uniforms.tMap.value = this.renderTarget.texture;
                material.uniforms.tFluid = this.fluid.uniform;

                const mesh = new Mesh(quad, material);
                mesh.position.set(0, 1.4, -11);
                mesh.scale.set(this.width, this.height, 1);
                mesh.lookAt(camera.position);
                mesh.renderOrder = 1; // Render last (default is 0)

                this.add(mesh);

                this.mesh = mesh;
            }

            initViews() {
                this.triangle = new Triangle();

                // Reduce size to make room for fluid dissipation
                this.triangle.scale.multiplyScalar(0.8);

                this.scene.add(this.triangle);
            }

            // Public methods

            resize = (width, height, dpr) => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.mesh.position.z);

                this.widthResolutionScale = this.width / x;
                this.heightResolutionScale = this.height / y;

                width = Math.round(width * dpr * this.widthResolutionScale);
                height = Math.round(height * dpr * this.heightResolutionScale);

                this.renderTarget.setSize(width, height);

                if (this.isLoaded) {
                    this.update();
                }
            };

            update = () => {
                // Render a single frame for the triangle texture
                const currentRenderTarget = this.renderer.getRenderTarget();

                // Scene pass
                this.renderer.setRenderTarget(this.renderTarget);
                this.renderer.render(this.scene, this.camera);

                // Restore renderer settings
                this.renderer.setRenderTarget(currentRenderTarget);
            };

            ready = async () => {
                await this.triangle.initMesh();

                this.isLoaded = true;

                this.update();
            };
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/polished_concrete_basecolor.jpg'),
                    loadTexture('pbr/polished_concrete_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/polished_concrete_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const uniforms = {
                    mirror: { value: 0 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture2D(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new TriangleView();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height, dpr) => {
                this.floor.resize(width, height);
                this.triangle.resize(width, height, dpr);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(camera, view) {
                this.camera = camera;
                this.view = view;

                // Fluid simulation
                this.lastMouse = new Vector2();

                this.triangleWorldPosition = new Vector3();
                this.screenSpacePosition = new Vector3();

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                const event = {
                    x: clientX,
                    y: clientY
                };

                // Adjust for triangle screen space
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;
                const triangleWidth = Math.round(this.width * this.view.triangle.widthResolutionScale);
                const triangleHeight = Math.round(this.height * this.view.triangle.heightResolutionScale);
                const triangleHalfWidth = triangleWidth / 2;
                const triangleHalfHeight = triangleHeight / 2;

                this.triangleWorldPosition.setFromMatrixPosition(this.view.triangle.mesh.matrixWorld);
                this.screenSpacePosition.copy(this.triangleWorldPosition).project(this.camera);

                this.screenSpacePosition.x = (this.screenSpacePosition.x * halfWidth) + halfWidth - triangleHalfWidth;
                this.screenSpacePosition.y = -(this.screenSpacePosition.y * halfHeight) + halfHeight - triangleHalfHeight;

                // First input
                if (!this.lastMouse.isInit) {
                    this.lastMouse.isInit = true;
                    this.lastMouse.copy(event);
                }

                const deltaX = event.x - this.lastMouse.x;
                const deltaY = event.y - this.lastMouse.y;

                this.lastMouse.copy(event);

                // Add if the mouse is moving
                if (Math.abs(deltaX) || Math.abs(deltaY)) {
                    // Update fluid simulation inputs
                    this.view.triangle.fluid.splats.push({
                        // Get mouse value in 0 to 1 range, with Y flipped
                        x: MathUtils.mapLinear(event.x, this.screenSpacePosition.x, this.screenSpacePosition.x + triangleWidth, 0, 1),
                        y: 1 - MathUtils.mapLinear(event.y, this.screenSpacePosition.y, this.screenSpacePosition.y + triangleHeight, 0, 1),
                        dx: deltaX * 5,
                        dy: deltaY * -5
                    });
                }
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.width = width;
                this.height = height;

                this.view.resize(width, height, dpr);
            };

            static update = () => {
                // Perform all of the fluid simulation renders
                this.view.triangle.fluid.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { triangle } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Iterate',
                        min: 0,
                        max: 10,
                        step: 1,
                        value: triangle.fluid.iterations,
                        callback: value => {
                            triangle.fluid.iterations = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: triangle.fluid.densityDissipation,
                        callback: value => {
                            triangle.fluid.densityDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Velocity',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: triangle.fluid.velocityDissipation,
                        callback: value => {
                            triangle.fluid.velocityDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Pressure',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: triangle.fluid.pressureDissipation,
                        callback: value => {
                            triangle.fluid.pressureDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Curl',
                        min: 0,
                        max: 50,
                        step: 0.1,
                        value: triangle.fluid.curlStrength,
                        callback: value => {
                            triangle.fluid.curlStrength = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: triangle.fluid.radius,
                        callback: value => {
                            triangle.fluid.radius = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.quad = new PlaneGeometry(1, 1);
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(camera, this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_fluid_distortion.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Fluid Distortion Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Fluid, Fog, GLSL3, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, NoBlending, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, RawShaderMaterial, Reflector, RepeatWrapping, SVGLoader, Scene, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://github.com/PavelDoGreat/WebGL-Fluid-Simulation
        // Based on https://oframe.github.io/ogl/examples/?src=post-fluid-distortion.html by gordonnl

        import rgbshift from '../../src/shaders/modules/rgbshift/rgbshift.glsl.js';
        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        tFluid: { value: null },
                        uBloomDistortion: { value: 1.5 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform sampler2D tFluid;
                        uniform float uBloomDistortion;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${rgbshift}
                        ${dither}

                        void main() {
                            vec3 fluid = texture(tFluid, vUv).rgb;
                            vec2 uv = vUv - fluid.rg * 0.0002;

                            FragColor = texture(tScene, uv);

                            vec2 dir = 0.5 - vUv;
                            float angle = atan(dir.y, dir.x);
                            float amount = 0.001 * uBloomDistortion;

                            FragColor.rgb += getRGB(tBloom, uv, angle, amount).rgb;

                            FragColor.rgb = dither(FragColor.rgb);
                            FragColor.a = 1.0;
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { camera, loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.position.set(0, 1.4, -11);
                group.scale.y *= -1;
                group.lookAt(camera.position);

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/polished_concrete_basecolor.jpg'),
                    loadTexture('pbr/polished_concrete_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/polished_concrete_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const uniforms = {
                    mirror: { value: 0 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new Triangle();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { fluid, luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Iterate',
                        min: 0,
                        max: 10,
                        step: 1,
                        value: fluid.iterations,
                        callback: value => {
                            fluid.iterations = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.densityDissipation,
                        callback: value => {
                            fluid.densityDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Velocity',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.velocityDissipation,
                        callback: value => {
                            fluid.velocityDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Pressure',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.pressureDissipation,
                        callback: value => {
                            fluid.pressureDissipation = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Curl',
                        min: 0,
                        max: 50,
                        step: 0.1,
                        value: fluid.curlStrength,
                        callback: value => {
                            fluid.curlStrength = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: fluid.radius,
                        callback: value => {
                            fluid.radius = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.width = 1;
                this.height = 1;

                // Fluid simulation
                this.lastMouse = new Vector2();

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();

                this.addListeners();
            }

            static initRenderer() {
                const { screenTriangle, aspect } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Fluid simulation
                this.fluid = new Fluid(this.renderer, {
                    curlStrength: 0
                });
                this.fluid.splatMaterial.uniforms.uAspect = aspect;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.tFluid = this.fluid.uniform;
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                const event = {
                    x: clientX,
                    y: clientY
                };

                // First input
                if (!this.lastMouse.isInit) {
                    this.lastMouse.isInit = true;
                    this.lastMouse.copy(event);
                }

                const deltaX = event.x - this.lastMouse.x;
                const deltaY = event.y - this.lastMouse.y;

                this.lastMouse.copy(event);

                // Add if the mouse is moving
                if (Math.abs(deltaX) || Math.abs(deltaY)) {
                    // Update fluid simulation inputs
                    this.fluid.splats.push({
                        // Get mouse value in 0 to 1 range, with Y flipped
                        x: event.x / this.width,
                        y: 1 - event.y / this.height,
                        dx: deltaX * 5,
                        dy: deltaY * -5
                    });
                }
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.width = width;
                this.height = height;

                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Perform all of the fluid simulation renders
                this.fluid.update();

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_fresnel.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Fresnel Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { Color, ColorManagement, GLSL3, Group, LinearSRGBColorSpace, Mesh, OrbitControls, PanelItem, PerspectiveCamera, RawShaderMaterial, Scene, SphereGeometry, UI, Vector2, WebGLRenderer, brightness, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://oframe.github.io/ogl/examples/?src=fresnel.html by michaeldll

        const colors = {
            backgroundColor: 0x060606,
            baseColor: 0x060606,
            fresnelColor: 0x3b5b89
        };

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class FresnelMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        uBaseColor: { value: new Color(colors.baseColor) },
                        uFresnelColor: { value: new Color(colors.fresnelColor) },
                        uFresnelPower: { value: 1.5 },
                        uTime: WorldController.time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec3 normal;

                        uniform mat4 modelMatrix;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;

                        uniform float uTime;

                        out vec3 vWorldNormal;
                        out vec3 vViewDirection;

                        ${periodic3d}

                        void main() {
                            // http://connorbell.ca/2017/09/09/Generating-Looping-Noise.html

                            float loopLength = 2.0;
                            float transitionStart = 1.5;
                            float time = mod(uTime, loopLength);

                            float v1 = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                            float v2 = 0.05 * pnoise(vec3(2.0 * normal + time - loopLength), vec3(10.0));

                            float transitionProgress = (time - transitionStart) / (loopLength - transitionStart);
                            float progress = clamp(transitionProgress, 0.0, 1.0);

                            float result = mix(v1, v2, progress);

                            vec3 worldPosition = (modelMatrix * vec4(position + result * normal, 1.0)).xyz;
                            vWorldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
                            vViewDirection = normalize(cameraPosition - worldPosition);

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position + result * normal, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform vec3 uBaseColor;
                        uniform vec3 uFresnelColor;
                        uniform float uFresnelPower;

                        in vec3 vWorldNormal;
                        in vec3 vViewDirection;

                        out vec4 FragColor;

                        void main() {
                            float fresnelFactor = abs(dot(vViewDirection, vWorldNormal));
                            float inversefresnelFactor = 1.0 - fresnelFactor;

                            // Shaping function
                            fresnelFactor = pow(fresnelFactor, uFresnelPower);
                            inversefresnelFactor = pow(inversefresnelFactor, uFresnelPower);

                            FragColor = vec4(fresnelFactor * uBaseColor + inversefresnelFactor * uFresnelColor, 1.0);
                        }
                    `
                });
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                this.mesh = new Mesh(
                    new SphereGeometry(1, 160, 80),
                    new FresnelMaterial()
                );
                this.add(this.mesh);
            }
        }

        class PanelController {
            static init(scene, view, ui) {
                this.scene = scene;
                this.view = view;
                this.ui = ui;

                this.lastInvert = null;

                this.initPanel();
                this.setInvert(this.scene.background);
            }

            static initPanel() {
                const { mesh } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'color',
                        value: this.scene.background,
                        callback: value => {
                            this.scene.background.copy(value);

                            this.setInvert(value);
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'color',
                        value: mesh.material.uniforms.uBaseColor.value,
                        callback: value => {
                            mesh.material.uniforms.uBaseColor.value.copy(value);
                        }
                    },
                    {
                        type: 'color',
                        value: mesh.material.uniforms.uFresnelColor.value,
                        callback: value => {
                            mesh.material.uniforms.uFresnelColor.value.copy(value);
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 0,
                        max: 3,
                        step: 0.01,
                        value: mesh.material.uniforms.uFresnelPower.value,
                        callback: value => {
                            mesh.material.uniforms.uFresnelPower.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }

            // Public methods

            static setInvert = value => {
                // Light colour is inverted
                const invert = brightness(value) > 0.6;

                if (invert !== this.lastInvert) {
                    this.lastInvert = invert;

                    this.ui.invert(invert);
                }
            };
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(colors.backgroundColor);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { scene } = WorldController;

                PanelController.init(scene, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_fxaa.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>FXAA Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { Color, ColorManagement, DirectionalLight, FXAAMaterial, Group, HemisphereLight, LinearSRGBColorSpace, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, Scene, SphereGeometry, UI, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, ticker } from '../../build/alien.three.js';

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                const material = new MeshStandardMaterial({ roughness: 0 });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const postOptions = {
                    Off: false,
                    FXAA: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: value => {
                            RenderManager.enabled = postOptions[value];
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1);

                // FXAA material
                this.fxaaMaterial = new FXAAMaterial();
                this.fxaaMaterial.uniforms.tMap.value = this.renderTarget.texture;
                this.fxaaMaterial.uniforms.uResolution = resolution;
                this.screen.material = this.fxaaMaterial;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // FXAA pass (render to screen)
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance'
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_hologram.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Hologram — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BlurMaterial, BoxGeometry, ChromaticAberrationMaterial, Color, ColorManagement, DirectionalLight, EdgesGeometry, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, LineBasicMaterial, LineSegments, LinearSRGBColorSpace, LuminosityMaterial, MapControls, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, NoBlending, OctahedronGeometry, OrthographicCamera, Panel, PanelItem, PerspectiveCamera, Point3D, RawShaderMaterial, RepeatWrapping, Scene, SphereGeometry, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, VideoGlitchMaterial, WebGLRenderTarget, WebGLRenderer, clearTween, getFullscreenTriangle, getKeyByValue, ticker, tween } from '../../build/alien.three.js';

        // Based on https://codepen.io/peterhry/pen/egzjGR

        const colors = {
            backgroundColor: 0x060606,
            lightColor: 0x00ffff,
            errorColor: 0xff0000
        };

        const layers = {
            default: 0,
            hologram: 1,
            glow: 2
        };

        import blendScreen from '../../src/shaders/modules/blending/screen.glsl.js';
        import blendSoftLight from '../../src/shaders/modules/blending/soft-light.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tHologram: { value: null },
                        tGlow: { value: null },
                        uColor: { value: new Color(colors.backgroundColor) }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tHologram;
                        uniform sampler2D tGlow;
                        uniform vec3 uColor;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${blendScreen}
                        ${blendSoftLight}

                        void main() {
                            vec4 base = texture(tScene, vUv);
                            vec4 blend = texture(tHologram, vUv);

                            // Blend soft light background color
                            blend = blendSoftLight(blend, vec4(uColor, 1.0), 0.8);

                            FragColor = blendScreen(base, blend, 1.0);

                            base = FragColor;
                            blend = texture(tGlow, vUv);

                            FragColor = blendScreen(base, blend, 1.0);
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        import fresnel from '../../src/shaders/modules/fresnel/fresnel.glsl.js';

        class AbstractCube extends Group {
            constructor() {
                super();

                this.position.x = 2.5;
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new BoxGeometry();

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                normalMap.anisotropy = anisotropy;
                ormMap.anisotropy = anisotropy;

                const material = new MeshStandardMaterial({
                    name: 'Abstract Cube',
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 0.7,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1),
                    flatShading: true,
                    polygonOffset: true,
                    polygonOffsetFactor: 3,
                    polygonOffsetUnits: 1
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.rotation.x = MathUtils.degToRad(-45);
                mesh.rotation.z = MathUtils.degToRad(-45);
                mesh.layers.set(layers.hologram);
                mesh.layers.enable(31); // Last layer for `Point3D` raycasting
                this.add(mesh);

                // Hologram
                const glowMaterial = material.clone();
                glowMaterial.color = new Color(colors.errorColor);
                glowMaterial.emissive = new Color(colors.errorColor);
                glowMaterial.emissiveIntensity = 0.125;

                const uniforms = {
                    fresnelColor: { value: new Color(colors.errorColor).offsetHSL(0, 0, 0.25) },
                    fresnelPower: { value: 1 }
                };

                glowMaterial.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        out vec3 vWorldNormal;
                        out vec3 vViewDirection;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vWorldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
                        vViewDirection = normalize(cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz);
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform vec3 fresnelColor;
                        uniform float fresnelPower;

                        in vec3 vWorldNormal;
                        in vec3 vViewDirection;

                        ${fresnel}

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'vec3 totalEmissiveRadiance = emissive;',
                        /* glsl */ `
                        vec3 totalEmissiveRadiance = emissive;

                        float fresnel = getFresnel(vViewDirection, vWorldNormal, fresnelPower);
                        totalEmissiveRadiance += (fresnel * fresnelColor) * 0.2;
                        `
                    );
                };

                const glowMesh = new Mesh(geometry, glowMaterial);
                glowMesh.position.copy(mesh.position);
                glowMesh.scale.copy(mesh.scale);
                glowMesh.layers.set(layers.glow);
                this.add(glowMesh);

                // Wireframe
                const wireframe = new LineSegments(
                    new EdgesGeometry(mesh.geometry),
                    new LineBasicMaterial({ color: new Color(colors.errorColor).offsetHSL(0, 0, 0.25) })
                );
                wireframe.layers.set(layers.hologram);
                glowMesh.add(wireframe);

                this.mesh = mesh;
                this.glowMesh = glowMesh;
                this.wireframe = wireframe;
                this.uniforms = uniforms;
            }

            // Public methods

            setHologramColor = color => {
                this.glowMesh.material.color.copy(color);
                this.glowMesh.material.emissive.copy(color);
                this.wireframe.material.color.copy(color).offsetHSL(0, 0, 0.25);
                this.uniforms.fresnelColor.value.copy(color).offsetHSL(0, 0, 0.25);
            };

            update = () => {
                this.mesh.rotation.y -= 0.005;

                // Update glow mesh
                this.mesh.matrix.decompose(this.glowMesh.position, this.glowMesh.quaternion, this.glowMesh.scale);
            };

            ready = () => this.initMesh();
        }

        class FloatingCrystal extends Group {
            constructor() {
                super();

                this.position.y = 0.7;
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new OctahedronGeometry();

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 2);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 2);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 2);

                const material = new MeshStandardMaterial({
                    name: 'Floating Crystal',
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 0.7,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1),
                    flatShading: true,
                    polygonOffset: true,
                    polygonOffsetFactor: 3,
                    polygonOffsetUnits: 1
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.scale.set(0.5, 1, 0.5);
                mesh.layers.set(layers.hologram);
                mesh.layers.enable(31); // Last layer for `Point3D` raycasting
                mesh.layers.set(layers.default); // Off
                this.add(mesh);

                // Hologram
                const glowMaterial = material.clone();
                glowMaterial.color = new Color(colors.lightColor);
                glowMaterial.emissive = new Color(colors.lightColor);
                glowMaterial.emissiveIntensity = 0.125;

                const uniforms = {
                    fresnelColor: { value: new Color(colors.lightColor).offsetHSL(0, 0, 0.25) },
                    fresnelPower: { value: 1 }
                };

                glowMaterial.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        out vec3 vWorldNormal;
                        out vec3 vViewDirection;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vWorldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
                        vViewDirection = normalize(cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz);
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform vec3 fresnelColor;
                        uniform float fresnelPower;

                        in vec3 vWorldNormal;
                        in vec3 vViewDirection;

                        ${fresnel}

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'vec3 totalEmissiveRadiance = emissive;',
                        /* glsl */ `
                        vec3 totalEmissiveRadiance = emissive;

                        float fresnel = getFresnel(vViewDirection, vWorldNormal, fresnelPower);
                        totalEmissiveRadiance += (fresnel * fresnelColor) * 0.2;
                        `
                    );
                };

                const glowMesh = new Mesh(geometry, glowMaterial);
                glowMesh.position.copy(mesh.position);
                glowMesh.scale.copy(mesh.scale);
                glowMesh.layers.set(layers.glow);
                glowMesh.layers.disable(layers.glow); // Off
                this.add(glowMesh);

                // Wireframe
                const wireframe = new LineSegments(
                    new EdgesGeometry(mesh.geometry),
                    new LineBasicMaterial({ color: new Color(colors.lightColor).offsetHSL(0, 0, 0.25) })
                );
                wireframe.layers.set(layers.hologram);
                wireframe.layers.disable(layers.hologram); // Off
                glowMesh.add(wireframe);

                this.mesh = mesh;
                this.glowMesh = glowMesh;
                this.wireframe = wireframe;
                this.uniforms = uniforms;
            }

            // Public methods

            setHologramColor = color => {
                this.glowMesh.material.color.copy(color);
                this.glowMesh.material.emissive.copy(color);
                this.wireframe.material.color.copy(color).offsetHSL(0, 0, 0.25);
                this.uniforms.fresnelColor.value.copy(color).offsetHSL(0, 0, 0.25);
            };

            update = time => {
                this.mesh.position.y = Math.sin(time) * 0.1;
                this.mesh.rotation.y += 0.01;

                // Update glow mesh
                this.mesh.matrix.decompose(this.glowMesh.position, this.glowMesh.quaternion, this.glowMesh.scale);
            };

            ready = () => this.initMesh();
        }

        class DarkPlanet extends Group {
            constructor() {
                super();

                this.position.x = -2.5;

                // 25 degree tilt like Mars
                this.rotation.z = MathUtils.degToRad(25);
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new SphereGeometry(0.6, 40, 20);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    name: 'Dark Planet',
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3),
                    polygonOffset: true,
                    polygonOffsetFactor: 3,
                    polygonOffsetUnits: 1
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.layers.set(layers.hologram);
                mesh.layers.enable(31); // Last layer for `Point3D` raycasting
                this.add(mesh);

                // Hologram
                const glowMaterial = material.clone();
                glowMaterial.color = new Color(colors.lightColor);
                glowMaterial.emissive = new Color(colors.lightColor);
                glowMaterial.emissiveIntensity = 0.125;

                const uniforms = {
                    fresnelColor: { value: new Color(colors.lightColor).offsetHSL(0, 0, 0.25) },
                    fresnelPower: { value: 1 }
                };

                glowMaterial.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        out vec3 vWorldNormal;
                        out vec3 vViewDirection;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vWorldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
                        vViewDirection = normalize(cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz);
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform vec3 fresnelColor;
                        uniform float fresnelPower;

                        in vec3 vWorldNormal;
                        in vec3 vViewDirection;

                        ${fresnel}

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'vec3 totalEmissiveRadiance = emissive;',
                        /* glsl */ `
                        vec3 totalEmissiveRadiance = emissive;

                        float fresnel = getFresnel(vViewDirection, vWorldNormal, fresnelPower);
                        totalEmissiveRadiance += (fresnel * fresnelColor) * 0.2;
                        `
                    );
                };

                const glowMesh = new Mesh(geometry, glowMaterial);
                glowMesh.position.copy(mesh.position);
                glowMesh.scale.copy(mesh.scale);
                glowMesh.layers.set(layers.glow);
                this.add(glowMesh);

                // Wireframe
                const wireframe = new LineSegments(
                    new EdgesGeometry(mesh.geometry),
                    new LineBasicMaterial({ color: new Color(colors.lightColor).offsetHSL(0, 0, 0.25) })
                );
                wireframe.layers.set(layers.hologram);
                glowMesh.add(wireframe);

                this.mesh = mesh;
                this.glowMesh = glowMesh;
                this.wireframe = wireframe;
                this.uniforms = uniforms;
            }

            // Public methods

            setHologramColor = color => {
                this.glowMesh.material.color.copy(color);
                this.glowMesh.material.emissive.copy(color);
                this.wireframe.material.color.copy(color).offsetHSL(0, 0, 0.25);
                this.uniforms.fresnelColor.value.copy(color).offsetHSL(0, 0, 0.25);
            };

            update = () => {
                // Counter clockwise rotation
                this.mesh.rotation.y += 0.005;

                // Update glow mesh
                this.mesh.matrix.decompose(this.glowMesh.position, this.glowMesh.quaternion, this.glowMesh.scale);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.darkPlanet = new DarkPlanet();
                this.add(this.darkPlanet);

                this.floatingCrystal = new FloatingCrystal();
                this.add(this.floatingCrystal);

                this.abstractCube = new AbstractCube();
                this.add(this.abstractCube);
            }

            // Public methods

            update = time => {
                this.darkPlanet.update(time);
                this.floatingCrystal.update(time);
                this.abstractCube.update(time);
            };

            ready = () => Promise.all([
                this.darkPlanet.ready(),
                this.floatingCrystal.ready(),
                this.abstractCube.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
            };

            static update = time => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update(time);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class ScenePanelController {
            static init(view) {
                this.view = view;

                this.initPanel();
            }

            static initPanel() {
                const { darkPlanet, floatingCrystal, abstractCube } = this.view;

                const objects = [darkPlanet, floatingCrystal, abstractCube];

                objects.forEach(object => {
                    object.point = new Point3D(object.mesh);
                    object.add(object.point);

                    const hologramOptions = {
                        Off: false,
                        On: true
                    };

                    const colorOptions = {
                        Light: colors.lightColor,
                        Error: colors.errorColor
                    };

                    const hologramItems = [
                        {
                            type: 'divider'
                        },
                        {
                            type: 'list',
                            name: 'Color',
                            list: colorOptions,
                            value: getKeyByValue(colorOptions, object.glowMesh.material.color.getHex()),
                            callback: value => {
                                object.setHologramColor(new Color(colorOptions[value]));

                                RenderManager.glitchHologram();
                            }
                        }
                    ];

                    const items = [
                        {
                            type: 'divider'
                        },
                        {
                            type: 'list',
                            name: 'Hologram',
                            list: hologramOptions,
                            value: getKeyByValue(hologramOptions, object.mesh.layers.isEnabled(layers.hologram)),
                            callback: (value, item) => {
                                if (!item.hasContent()) {
                                    const hologramPanel = new Panel();
                                    hologramPanel.animateIn(true);

                                    hologramItems.forEach(data => {
                                        hologramPanel.add(new PanelItem(data));
                                    });

                                    item.setContent(hologramPanel);
                                }

                                if (hologramOptions[value]) {
                                    object.mesh.layers.set(layers.hologram);
                                    object.glowMesh.layers.set(layers.glow);
                                    object.wireframe.layers.set(layers.hologram);

                                    item.toggleContent(true);

                                    RenderManager.glitchHologram();
                                } else {
                                    object.mesh.layers.set(layers.default);
                                    object.glowMesh.layers.disable(layers.glow);
                                    object.wireframe.layers.disable(layers.hologram);

                                    item.toggleContent(false);
                                }

                                object.mesh.layers.enable(31); // Last layer for `Point3D` raycasting
                            }
                        }
                    ];

                    items.forEach(data => {
                        object.point.addPanel(new PanelItem(data));
                    });
                });

                // Shrink tracker mesh to better match the visual size of the object
                floatingCrystal.point.mesh.scale.multiply(new Vector3(0.6, 1, 0.6));
                abstractCube.point.mesh.scale.multiplyScalar(0.9);
            }
        }

        class PanelController {
            static init(renderer, scene, camera, view, ui) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;
                this.ui = ui;

                this.initControllers();
                this.initPanel();
            }

            static initControllers() {
                Point3D.init(this.renderer, this.scene, this.camera, {
                    container: this.ui
                });

                ScenePanelController.init(this.view);
            }

            static initPanel() {
                const { hBlurMaterial, vBlurMaterial, videoGlitchMaterial, luminosityMaterial, bloomCompositeMaterial, caMaterial } = RenderManager;

                const { darkPlanet, abstractCube } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Fresnel',
                        min: 0,
                        max: 3,
                        step: 0.01,
                        value: darkPlanet.uniforms.fresnelPower.value,
                        callback: value => {
                            darkPlanet.uniforms.fresnelPower.value = value;
                            abstractCube.uniforms.fresnelPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Glow',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: hBlurMaterial.uniforms.uBlurAmount.value,
                        callback: value => {
                            hBlurMaterial.uniforms.uBlurAmount.value = value;
                            vBlurMaterial.uniforms.uBlurAmount.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: videoGlitchMaterial.uniforms.uDistortion.value,
                        callback: value => {
                            videoGlitchMaterial.uniforms.uDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Distort2',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: videoGlitchMaterial.uniforms.uDistortion2.value,
                        callback: value => {
                            videoGlitchMaterial.uniforms.uDistortion2.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Speed',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: videoGlitchMaterial.uniforms.uSpeed.value,
                        callback: value => {
                            videoGlitchMaterial.uniforms.uSpeed.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Red',
                        min: -4,
                        max: 4,
                        step: 0.01,
                        value: caMaterial.uniforms.uRedOffset.value,
                        callback: value => {
                            caMaterial.uniforms.uRedOffset.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Green',
                        min: -4,
                        max: 4,
                        step: 0.01,
                        value: caMaterial.uniforms.uGreenOffset.value,
                        callback: value => {
                            caMaterial.uniforms.uGreenOffset.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Blue',
                        min: -4,
                        max: 4,
                        step: 0.01,
                        value: caMaterial.uniforms.uBlueOffset.value,
                        callback: value => {
                            caMaterial.uniforms.uBlueOffset.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Int',
                        min: 0,
                        max: 3,
                        step: 0.01,
                        value: caMaterial.uniforms.uIntensity.value,
                        callback: value => {
                            caMaterial.uniforms.uIntensity.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }

            // Public methods

            static update = time => {
                if (!this.ui) {
                    return;
                }

                Point3D.update(time);
            };
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Hologram
                this.glitchDistortion = 0.15;
                this.glitchDistortion2 = 0.04;
                this.glitchSpeed = 0.01;
                this.blurResolutionScale = 0.25;
                this.blurAmount = 1;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                // Chromatic aberration
                this.caRedOffset = 0;
                this.caGreenOffset = 4;
                this.caBlueOffset = 0;
                this.caIntensity = 1.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, time } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Clear colors
                this.clearColor = new Color(0, 0, 0);
                this.currentClearColor = new Color();

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();
                this.renderTargetC = this.renderTargetA.clone();
                this.renderTargetHologram = this.renderTargetA.clone();

                this.renderTargetBlurA = this.renderTargetA.clone();
                this.renderTargetBlurB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetHologram.depthBuffer = true;
                this.renderTargetBlurA.depthBuffer = true;

                // Occlusion material
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Video glitch material
                this.videoGlitchMaterial = new VideoGlitchMaterial();
                this.videoGlitchMaterial.uniforms.uDistortion.value = this.glitchDistortion;
                this.videoGlitchMaterial.uniforms.uDistortion2.value = this.glitchDistortion2;
                this.videoGlitchMaterial.uniforms.uSpeed.value = this.glitchSpeed;
                this.videoGlitchMaterial.uniforms.uTime = time;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Blend it additively
                this.bloomCompositeMaterial.blending = AdditiveBlending;

                // Composite material
                this.compositeMaterial = new CompositeMaterial();

                // Chromatic aberration material
                this.caMaterial = new ChromaticAberrationMaterial();
                this.caMaterial.uniforms.uRedOffset.value = this.caRedOffset;
                this.caMaterial.uniforms.uGreenOffset.value = this.caGreenOffset;
                this.caMaterial.uniforms.uBlueOffset.value = this.caBlueOffset;
                this.caMaterial.uniforms.uIntensity.value = this.caIntensity;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);
                this.renderTargetC.setSize(width, height);
                this.renderTargetHologram.setSize(width, height);

                // Gaussian blur
                const blurWidth = Math.round(width * this.blurResolutionScale);
                const blurHeight = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(blurWidth, blurHeight);
                this.renderTargetBlurB.setSize(blurWidth, blurHeight);

                this.hBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);
                this.vBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetC = this.renderTargetC;
                const renderTargetHologram = this.renderTargetHologram;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Renderer state
                const currentOverrideMaterial = scene.overrideMaterial;
                const currentBackground = scene.background;
                renderer.getClearColor(this.currentClearColor);
                const currentClearAlpha = renderer.getClearAlpha();

                // Scene layer
                camera.layers.set(layers.default);

                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Hologram layer
                scene.background = null;
                renderer.setClearColor(this.clearColor, 1);

                scene.overrideMaterial = this.blackoutMaterial;
                renderer.setRenderTarget(renderTargetHologram);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = currentOverrideMaterial;

                camera.layers.set(layers.hologram);

                renderer.render(scene, camera);

                this.videoGlitchMaterial.uniforms.tMap.value = renderTargetHologram.texture;
                this.screen.material = this.videoGlitchMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Glow layer
                camera.layers.set(layers.default);

                scene.overrideMaterial = this.blackoutMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = currentOverrideMaterial;

                camera.layers.set(layers.glow);

                renderer.render(scene, camera);

                // Restore renderer settings
                scene.background = currentBackground;
                renderer.setClearColor(this.currentClearColor, currentClearAlpha);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Video glitch pass
                this.videoGlitchMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.videoGlitchMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Scene composite pass
                this.compositeMaterial.uniforms.tScene.value = renderTargetA.texture;
                this.compositeMaterial.uniforms.tHologram.value = renderTargetB.texture;
                this.compositeMaterial.uniforms.tGlow.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(renderTargetC);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetC.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetC);
                renderer.render(this.screen, this.screenCamera);

                // Chromatic aberration pass (render to screen)
                this.caMaterial.uniforms.tMap.value = renderTargetC.texture;
                this.screen.material = this.caMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };

            static glitchHologram = () => {
                clearTween(this.videoGlitchMaterial.uniforms.uDistortion2);
                clearTween(this.videoGlitchMaterial.uniforms.uSpeed);

                tween(this.videoGlitchMaterial.uniforms.uDistortion2, { value: 0.1 }, 120, 'easeOutCubic', () => {
                    tween(this.videoGlitchMaterial.uniforms.uDistortion2, { value: this.glitchDistortion2 }, 180, 'easeOutCubic');
                });

                tween(this.videoGlitchMaterial.uniforms.uSpeed, { value: 1.3 }, 120, 'easeOutCubic', () => {
                    tween(this.videoGlitchMaterial.uniforms.uSpeed, { value: this.glitchSpeed }, 180, 'easeOutCubic');
                });
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(colors.backgroundColor);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 1;
                this.camera.far = 40;
                this.camera.position.set(0, 6, 8);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                const hemisphereLight = new HemisphereLight(0x606060, 0x404040, 3);

                const directionalLight = new DirectionalLight(0xffffff, 2);
                directionalLight.position.set(5, 5, 5);

                this.scene.add(hemisphereLight);
                this.scene.add(directionalLight);

                // Important: Make sure your lights are on!
                // hemisphereLight.layers.enable(layers.hologram);
                // directionalLight.layers.enable(layers.hologram);
                // hemisphereLight.layers.enable(layers.glow);
                // directionalLight.layers.enable(layers.glow);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
                this.textureLoader.cache = true;

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initControls() {
                this.controls = new MapControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { renderer, scene, camera } = WorldController;

                PanelController.init(renderer, scene, camera, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update(time);
                RenderManager.update(time, delta, frame);
                PanelController.update(time);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_lensflare.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Lens Flare Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BlurMaterial, Color, ColorManagement, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, LensflareMaterial, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PointLight, RepeatWrapping, Scene, SceneCompositeAddMaterial, ShaderChunk, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getViewSize, ticker } from '../../build/alien.three.js';

        const colors = {
            lightColor: 0xf44336
        };

        const layers = {
            default: 0,
            occlusion: 1
        };

        class Ball extends Group {
            constructor() {
                super();

                this.position.z = -1;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 1.9, 2.2, 0);
                this.add(light);
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.25, 6);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(colors.lightColor),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.2 };
                    shader.uniforms.thicknessPower = { value: 2 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                // Occlusion mesh
                const occMesh = mesh.clone();
                occMesh.material = new MeshBasicMaterial({
                    color: new Color(colors.lightColor).multiply(new Color(0.55, 0.55, 1)) // Blue tint
                });
                occMesh.layers.set(layers.occlusion);
                this.add(occMesh);
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class Sphere extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.5, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu
                // Based on https://gist.github.com/mattdesl/2ee82157a86962347dedb6572142df7c

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.185 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 1 },
                    thicknessPower: { value: 20 },
                    thicknessScale: { value: 16 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).r;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += material.diffuseColor * directLight.color * scatteringIllu * thicknessAttenuation;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.uniforms = uniforms;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.sphere = new Sphere();
                this.add(this.sphere);

                this.ball = new Ball();
                this.add(this.ball);
            }

            // Public methods

            ready = () => Promise.all([
                this.sphere.ready(),
                this.ball.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;

                // Mouse light
                this.mouse = new Vector2();
                this.target = new Vector2();
                this.lightPosition = new Vector3();
                this.lerpSpeed = 0.25;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.view.visible) {
                    return;
                }

                this.target.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.target.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = () => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize(this.view.ball.position.z);

                this.halfWidth = x / 2;
                this.halfHeight = y / 2;
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.mouse.lerp(this.target, this.lerpSpeed);

                this.lightPosition.x = this.mouse.x * this.halfWidth;
                this.lightPosition.y = this.mouse.y * this.halfHeight;
                this.lightPosition.z = this.view.ball.position.z;

                this.view.ball.position.copy(this.lightPosition);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { lensflareMaterial, luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const { sphere } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Scale X',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: lensflareMaterial.uniforms.uScale.value.x,
                        callback: value => {
                            lensflareMaterial.uniforms.uScale.value.x = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale Y',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: lensflareMaterial.uniforms.uScale.value.y,
                        callback: value => {
                            lensflareMaterial.uniforms.uScale.value.y = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: lensflareMaterial.uniforms.uExposure.value,
                        callback: value => {
                            lensflareMaterial.uniforms.uExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: lensflareMaterial.uniforms.uClamp.value,
                        callback: value => {
                            lensflareMaterial.uniforms.uClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: sphere.uniforms.thicknessDistortion.value,
                        callback: value => {
                            sphere.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAmbient.value,
                        callback: value => {
                            sphere.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            sphere.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: sphere.uniforms.thicknessPower.value,
                        callback: value => {
                            sphere.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: sphere.uniforms.thicknessScale.value,
                        callback: value => {
                            sphere.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, view) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;

                // Lens flare
                this.lightPosition = new Vector3();
                this.lensflareScale = new Vector2(1.5, 1.5);
                this.lensflareExposure = 1;
                this.lensflareClamp = 1;
                this.blurResolutionScale = 0.25;
                this.blurAmount = 2.5;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Clear colors
                this.clearColor = new Color(0, 0, 0);
                this.currentClearColor = new Color();

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBlurA = this.renderTarget.clone();
                this.renderTargetBlurB = this.renderTarget.clone();

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;
                this.renderTargetBlurA.depthBuffer = true;

                // Occlusion material
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Lens flare material
                this.lensflareMaterial = new LensflareMaterial();
                this.lensflareMaterial.uniforms.uScale.value = this.lensflareScale;
                this.lensflareMaterial.uniforms.uExposure.value = this.lensflareExposure;
                this.lensflareMaterial.uniforms.uClamp.value = this.lensflareClamp;
                this.lensflareMaterial.uniforms.uResolution = resolution;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeAddMaterial({ dithering: true });
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static setLightPosition() {
                this.lightPosition.copy(this.view.ball.position).project(this.camera);

                const x = (this.lightPosition.x + 1) / 2;
                const y = (this.lightPosition.y + 1) / 2;

                this.lensflareMaterial.uniforms.uLightPosition.value.set(x, y);
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Gaussian blur
                const blurWidth = Math.round(width * this.blurResolutionScale);
                const blurHeight = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(blurWidth, blurHeight);
                this.renderTargetBlurB.setSize(blurWidth, blurHeight);

                this.hBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);
                this.vBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Renderer state
                const currentOverrideMaterial = scene.overrideMaterial;
                const currentBackground = scene.background;
                renderer.getClearColor(this.currentClearColor);
                const currentClearAlpha = renderer.getClearAlpha();

                // Scene layer
                camera.layers.set(layers.default);

                renderer.setRenderTarget(renderTarget);
                renderer.clear();
                renderer.render(scene, camera);

                // Occlusion layer
                scene.background = null;
                renderer.setClearColor(this.clearColor, 1);

                scene.overrideMaterial = this.blackoutMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = currentOverrideMaterial;

                camera.layers.set(layers.occlusion);

                renderer.render(scene, camera);

                // Restore renderer settings
                scene.background = currentBackground;
                renderer.setClearColor(this.currentClearColor, currentClearAlpha);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Lens flare pass
                this.lensflareMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.setLightPosition();
                this.screen.material = this.lensflareMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.compositeMaterial.uniforms.tAdd.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera, this.view);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_light_rays.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Light Rays Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, CopyMaterial, GLSL3, Group, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, brightness, getFullscreenTriangle, getViewSize, ticker } from '../../build/alien.three.js';

        // Based on https://www.youtube.com/watch?v=0D-J_Lbxeeg by akella

        const colors = {
            backgroundColor: 0x060606,
            lightColor: 0x3b5b89
        };

        import smootherstep from '../../src/shaders/modules/smootherstep/smootherstep.glsl.js';

        class GodRays extends Group {
            constructor() {
                super();

                this.initViews();
            }

            initViews() {
                const { time, getTexture } = WorldController;

                const texture = getTexture('perlin_noise.png');
                texture.wrapS = RepeatWrapping;
                texture.wrapT = RepeatWrapping;
                texture.generateMipmaps = false;

                const material = new RawShaderMaterial({
                    glslVersion: GLSL3,
                    uniforms: {
                        tNoise: { value: texture },
                        uLightPosition: { value: new Vector2(-10, 10) },
                        uLightColor: { value: new Color(colors.lightColor) },
                        uScale: { value: 0.2 },
                        uSpeed: { value: 0.05 },
                        uThreshold: { value: 0.2 },
                        uSmoothing: { value: 1 },
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        uniform mat4 modelMatrix;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;

                        out vec2 vUv;
                        out vec3 vWorldPosition;

                        void main() {
                            vUv = uv;
                            vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tNoise;
                        uniform vec2 uLightPosition;
                        uniform vec3 uLightColor;
                        uniform float uScale;
                        uniform float uSpeed;
                        uniform float uThreshold;
                        uniform float uSmoothing;
                        uniform float uTime;

                        in vec2 vUv;
                        in vec3 vWorldPosition;

                        out vec4 FragColor;

                        ${smootherstep}

                        void main() {
                            vec2 godray = vWorldPosition.xy - uLightPosition;
                            float uvDirection = atan(godray.y, godray.x) * uScale;

                            float c1 = texture(tNoise, vec2(uvDirection, 0.0) + 0.05 * uTime * uSpeed).r;
                            float c2 = texture(tNoise, vec2(0.0, uvDirection) + 0.05 * uTime * uSpeed * 1.5).g;
                            float v = min(c1, c2);
                            float alpha = smootherstep(uThreshold, uThreshold + uSmoothing, v);
                            float fade = smootherstep(0.15, 0.86, vUv.y);

                            FragColor = vec4(uLightColor, alpha * fade);
                        }
                    `,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false
                });

                const mesh = new Mesh(
                    new PlaneGeometry(),
                    material
                );
                mesh.renderOrder = -1; // Render first (default is 0)
                this.add(mesh);

                this.material = material;
                this.mesh = mesh;
            }

            // Public methods

            resize = () => {
                const { getViewSize } = WorldController;

                const { x, y } = getViewSize();
                this.mesh.scale.set(x, y, 1);
            };

            update = () => {
            };
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initViews();
            }

            initViews() {
                this.godrays = new GodRays();
                this.add(this.godrays);
            }

            // Public methods

            resize = () => {
                this.godrays.resize();
            };

            update = () => {
            };
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
                this.view.resize();
            };

            static update = () => {
                this.view.update();
            };
        }

        class PanelController {
            static init(scene, view, ui) {
                this.scene = scene;
                this.view = view;
                this.ui = ui;

                this.lastInvert = null;

                this.initPanel();
                this.setInvert(this.scene.background);
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const { godrays } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'color',
                        value: this.scene.background,
                        callback: value => {
                            this.scene.background.copy(value);

                            this.setInvert(value);
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'color',
                        value: godrays.material.uniforms.uLightColor.value,
                        callback: value => {
                            godrays.material.uniforms.uLightColor.value.copy(value);
                        }
                    },
                    {
                        type: 'slider',
                        name: 'X',
                        min: -10,
                        max: 10,
                        step: 0.1,
                        value: godrays.material.uniforms.uLightPosition.value.x,
                        callback: value => {
                            godrays.material.uniforms.uLightPosition.value.x = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Y',
                        min: -10,
                        max: 10,
                        step: 0.1,
                        value: godrays.material.uniforms.uLightPosition.value.y,
                        callback: value => {
                            godrays.material.uniforms.uLightPosition.value.y = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: godrays.material.uniforms.uScale.value,
                        callback: value => {
                            godrays.material.uniforms.uScale.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Speed',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: godrays.material.uniforms.uSpeed.value,
                        callback: value => {
                            godrays.material.uniforms.uSpeed.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: godrays.material.uniforms.uThreshold.value,
                        callback: value => {
                            godrays.material.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: godrays.material.uniforms.uSmoothing.value,
                        callback: value => {
                            godrays.material.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }

            // Public methods

            static setInvert = value => {
                // Light colour is inverted
                const invert = brightness(value) > 0.6;

                if (invert !== this.lastInvert) {
                    this.lastInvert = invert;

                    this.ui.invert(invert);
                }
            };
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0;
                this.luminositySmoothing = 1;
                this.bloomStrength = 1;
                this.bloomRadius = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                this.renderer.autoClear = false;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial({ dithering: true });
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeMaterial({ dithering: true });

                // Copy material
                this.copyMaterial = new CopyMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTargetB.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(colors.backgroundColor);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static getViewSize = object => getViewSize(this.camera, object);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { scene } = WorldController;

                PanelController.init(scene, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_matcap.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Matcap — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AssetLoader, Color, ColorManagement, Group, LinearSRGBColorSpace, Mesh, MeshMatcapMaterial, PerspectiveCamera, Scene, SphereGeometry, Texture, TextureLoader, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            async initMesh() {
                const { loadTexture, time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                const matcap = await loadTexture('matcaps/040full.jpg');
                // const matcap = await loadTexture('matcaps/defaultwax.jpg');

                const material = new MeshMatcapMaterial({ matcap });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            updateMatcap(texture) {
                if (this.mesh.material.matcap) {
                    this.mesh.material.matcap.dispose();
                }

                this.mesh.material.matcap = texture;
                this.mesh.material.needsUpdate = true;
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLoaders() {
                this.assetLoader = new AssetLoader();

                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static loadImage = path => this.assetLoader.loadImage(path);

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();
                this.initDragAndDrop();

                this.addListeners();
                this.onResize();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initDragAndDrop() {
                this.reader = new FileReader();
            }

            static addListeners() {
                document.addEventListener('dragover', this.onDragOver);
                document.addEventListener('drop', this.onDrop);
                this.reader.addEventListener('load', this.onLoad);
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
            };

            static onDragOver = e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            static onDrop = e => {
                e.preventDefault();

                this.reader.readAsDataURL(e.dataTransfer.files[0]);
            };

            static onLoad = async e => {
                const image = await WorldController.loadImage(e.target.result);

                const texture = new Texture(image);
                texture.needsUpdate = true;

                this.view.updateMatcap(texture);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_motion_blur.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Per-Object Motion Blur Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, Color, ColorManagement, DepthMaterial, DisplayOptions, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshMatcapMaterial, MeshStandardMaterial, MotionBlur, MotionBlurCompositeMaterial, NoBlending, NormalMaterial, OrbitControls, OrthographicCamera, PanelItem, PerspectiveCamera, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, SphereGeometry, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, ticker } from '../../build/alien.three.js';

        const layers = {
            default: 0,
            velocity: 1
        };

        const params = {
            animate: true,
            speed: 20
        };

        class Ball extends Group {
            constructor() {
                super();

                this.frameRotation = 0;
                this.position.x = 3;
                this.position.z = 3;
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.5, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    emissive: new Color(0xff0000),
                    metalness: 1.7,
                    roughness: 1.5,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.layers.enable(layers.velocity);
                this.add(mesh);
            }

            // Public methods

            update = () => {
                this.frameRotation -= 0.01 * params.speed;
                this.position.x = 3 * Math.sin(this.frameRotation);
                this.position.z = 3 * Math.cos(this.frameRotation);
            };

            ready = () => this.initMesh();
        }

        class Sphere extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(0x060606),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                mesh.layers.enable(layers.velocity);
                this.add(mesh);
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.sphere = new Sphere();
                this.add(this.sphere);

                this.ball = new Ball();
                this.add(this.ball);
            }

            // Public methods

            resize = () => {
            };

            update = () => {
                this.ball.update();
            };

            ready = () => Promise.all([
                this.sphere.ready(),
                this.ball.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;

                this.animatedOneFramePast = false;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                if (params.animate || !this.animatedOneFramePast) {
                    this.view.update();

                    this.animatedOneFramePast = !params.animate;
                }
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { motionBlur, luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const animateOptions = {
                    Off: false,
                    Animate: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: DisplayOptions,
                        value: getKeyByValue(DisplayOptions, RenderManager.display),
                        callback: value => {
                            RenderManager.display = DisplayOptions[value];
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Speed',
                        min: 0,
                        max: 100,
                        step: 0.1,
                        value: params.speed,
                        callback: value => {
                            params.speed = value;
                        }
                    },
                    {
                        type: 'list',
                        list: animateOptions,
                        value: getKeyByValue(animateOptions, params.animate),
                        callback: value => {
                            params.animate = animateOptions[value];
                            motionBlur.saveState = params.animate;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Interp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: motionBlur.interpolateGeometry,
                        callback: value => {
                            motionBlur.interpolateGeometry = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smear',
                        min: 0,
                        max: 4,
                        step: 0.02,
                        value: motionBlur.smearIntensity,
                        callback: value => {
                            motionBlur.smearIntensity = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        // Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/motionBlurPass
        // Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/shader-replacement

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                // Debug
                this.display = DisplayOptions.Default;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, textureLoader, getTexture } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Clear colors
                this.clearColor = new Color(0, 0, 0);
                this.currentClearColor = new Color();

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;

                // Motion blur
                this.motionBlur = new MotionBlur(this.renderer, this.scene, this.camera, layers.velocity);

                this.motionBlurCompositeMaterial = new MotionBlurCompositeMaterial(textureLoader, {
                    blueNoisePath: 'blue_noise.png'
                });
                this.motionBlurCompositeMaterial.uniforms.tVelocity.value = this.motionBlur.renderTarget.texture;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;

                // Debug materials
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });
                this.matcap1Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/040full.jpg') });
                this.matcap2Material = new MeshMatcapMaterial({ matcap: getTexture('matcaps/defaultwax.jpg') });
                this.normalMaterial = new NormalMaterial();
                this.depthMaterial = new DepthMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static rendererState() {
                this.currentOverrideMaterial = this.scene.overrideMaterial;
                this.currentBackground = this.scene.background;
                this.renderer.getClearColor(this.currentClearColor);
                this.currentClearAlpha = this.renderer.getClearAlpha();
            }

            static restoreRendererState() {
                this.scene.overrideMaterial = this.currentOverrideMaterial;
                this.scene.background = this.currentBackground;
                this.renderer.setClearColor(this.currentClearColor, this.currentClearAlpha);
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                this.motionBlur.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Renderer state
                this.rendererState();

                // Scene layer
                camera.layers.set(layers.default);

                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Post-processing
                scene.background = null;
                renderer.setClearColor(this.clearColor, 1);

                // Debug override material passes (render to screen)
                if (this.display === DisplayOptions.Depth) {
                    scene.overrideMaterial = this.depthMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Geometry) {
                    scene.overrideMaterial = this.normalMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Matcap1) {
                    scene.overrideMaterial = this.matcap1Material;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                } else if (this.display === DisplayOptions.Matcap2) {
                    scene.overrideMaterial = this.matcap2Material;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    this.restoreRendererState();
                    return;
                }

                // Motion blur layer
                camera.layers.set(layers.velocity);

                if (this.display === DisplayOptions.Velocity) {
                    // Debug pass (render to screen)
                    this.motionBlur.update(null);
                    this.restoreRendererState();
                    return;
                } else {
                    this.motionBlur.update();
                }

                this.motionBlurCompositeMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.motionBlurCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;

                if (this.display === DisplayOptions.Luma) {
                    // Debug pass (render to screen)
                    this.screen.material = this.blackoutMaterial;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.screen.material = this.luminosityMaterial;
                    this.screen.material.blending = AdditiveBlending;
                    renderer.render(this.screen, this.screenCamera);
                    this.screen.material.blending = NoBlending;
                    this.restoreRendererState();
                    return;
                } else {
                    this.screen.material = this.luminosityMaterial;
                    renderer.setRenderTarget(renderTargetBright);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;

                if (this.display === DisplayOptions.Bloom) {
                    // Debug pass (render to screen)
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                    this.restoreRendererState();
                    return;
                } else {
                    renderer.setRenderTarget(renderTargetsHorizontal[0]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);
                }

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTargetB.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Restore renderer settings
                this.restoreRendererState();
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                if (this.controls && this.controls.enabled) {
                    this.controls.update();
                }
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_noise.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Noise Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { ColorManagement, GLSL3, LinearSRGBColorSpace, Mesh, NoBlending, OrthographicCamera, PanelItem, RawShaderMaterial, UI, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://codepen.io/vaalentin/pen/MKMmXG

        import simplex2d from '../../src/shaders/modules/noise/simplex2d.glsl.js';

        class NoiseMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        uScale: { value: 2 },
                        uSpeed: { value: 0.5 },
                        uTime: WorldController.time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform float uScale;
                        uniform float uSpeed;
                        uniform float uTime;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${simplex2d}

                        float fbm(vec2 pos) {
                            float a = sin(uTime * uSpeed);
                            float b = cos(uTime * uSpeed);
                            mat2 m = mat2(-0.80, 0.36, -0.60, -0.48);

                            float total;

                            total = 0.5000 * snoise(pos) * a;
                            pos = m * pos * 2.02;

                            total += 0.2500 * snoise(pos) * b;
                            pos = m * pos * 2.03;

                            total += 0.1250 * snoise(pos) * a;
                            pos = m * pos * 2.01;

                            total += 0.0625 * snoise(pos) * b;

                            return total;
                        }

                        void main() {
                            vec2 pos = vUv.xy;

                            vec2 q = vec2(fbm(pos), fbm(pos));

                            float c = fbm(pos + sin(uTime * uSpeed) * uScale * q);

                            FragColor = vec4(vec3(c), 1.0);
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { screen } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Multiply',
                        min: -5,
                        max: 5,
                        step: 0.01,
                        value: screen.material.uniforms.uScale.value,
                        callback: value => {
                            screen.material.uniforms.uScale.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Speed',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: screen.material.uniforms.uSpeed.value,
                        callback: value => {
                            screen.material.uniforms.uSpeed.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, screen, screenCamera) {
                this.renderer = renderer;
                this.screen = screen;
                this.screenCamera = screenCamera;

                this.initRenderer();
            }

            static initRenderer() {
                this.screen.material = new NoiseMaterial();
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance'
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screenTriangle = getFullscreenTriangle();
                this.screen = new Mesh(this.screenTriangle, this.material);
                this.screen.frustumCulled = false;

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, screen, screenCamera } = WorldController;

                RenderManager.init(renderer, screen, screenCamera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_poisson_disc_blur.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Poisson Disc Blur Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { Color, ColorManagement, CopyMaterial, DirectionalLight, Group, HemisphereLight, LinearSRGBColorSpace, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PoissonDiscBlurMaterial, Scene, SphereGeometry, TextureLoader, UI, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                const material = new MeshStandardMaterial({ roughness: 0 });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { blurMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 50,
                        step: 0.1,
                        value: blurMaterial.uniforms.uRadius.value,
                        callback: value => {
                            blurMaterial.uniforms.uRadius.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution, time, textureLoader } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetA.depthBuffer = true;

                // Poisson-disc blur material
                this.blurMaterial = new PoissonDiscBlurMaterial(textureLoader, {
                    blueNoisePath: 'blue_noise.png'
                });
                this.blurMaterial.uniforms.uResolution = resolution;
                this.blurMaterial.uniforms.uTime = time;

                // Copy material
                this.copyMaterial = new CopyMaterial();
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.screen, this.screenCamera);

                // Poisson-disc blur pass (render to screen)
                this.blurMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.blurMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_radial_blur_rgbshift.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Radial Blur with RGB shift Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BufferGeometry, Color, ColorManagement, CopyMaterial, DepthTexture, DirectionalLight, EnvironmentTextureLoader, Float32BufferAttribute, GLSL3, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OrbitControls, OrthographicCamera, PanelItem, PerspectiveCamera, Points, RawShaderMaterial, RepeatWrapping, Scene, SphereGeometry, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://github.com/OGRECave/ogre/blob/master/Samples/Media/materials/programs/GLSL/Radial_Blur_FP.glsl
        // Based on https://stackoverflow.com/questions/4579020/how-do-i-use-a-glsl-shader-to-apply-a-radial-blur-to-an-entire-scene

        import blur from '../../src/shaders/modules/blur/radial-blur8-rgbshift.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: null },
                        uBlurDist: { value: 1 },
                        uBlurAmount: { value: 2.2 },
                        uRGBAmount: { value: 2.2 }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tMap;
                        uniform float uBlurDist;
                        uniform float uBlurAmount;
                        uniform float uRGBAmount;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${blur}

                        void main() {
                            vec2 dir = 0.5 - vUv;
                            float dist = length(dir);
                            dist = clamp(smoothstep(0.2, 0.7, dist), 0.0, 1.0);
                            float angle = atan(dir.y, dir.x);
                            float amount = 0.002 * dist * uRGBAmount;

                            FragColor = radialBlurRGB(tMap, vUv, 0.1 * dist * uBlurDist, uBlurAmount, angle, amount);
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        import simplex3d from '../../src/shaders/modules/noise/simplex3d.glsl.js';
        import depth from '../../src/shaders/modules/depth/depth.glsl.js';

        class Dust extends Group {
            constructor(numParticles) {
                super();

                this.numParticles = numParticles;

                this.initPoints();
            }

            initPoints() {
                const { camera, getTexture, resolution, time } = WorldController;

                const vertices = [];

                for (let i = 0; i < this.numParticles; i++) {
                    vertices[i * 3 + 0] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 1] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 2] = MathUtils.randFloatSpread(camera.far / 2);
                }

                const geometry = new BufferGeometry();
                geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));

                // Based on https://jsfiddle.net/m7tvxpbs/ by Mugen87

                const material = new RawShaderMaterial({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: getTexture('particle.png') },
                        tDepth: { value: null },
                        uScale: { value: window.devicePixelRatio / 2 },
                        uAlpha: { value: 1 },
                        uCameraNear: { value: camera.near },
                        uCameraFar: { value: camera.far },
                        uResolution: resolution,
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;

                        uniform mat4 modelMatrix;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;

                        uniform float uScale;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform float uTime;

                        out float vFade;

                        ${simplex3d}

                        void main() {
                            vec3 p = position;
                            p.x += snoise(position.xyz + uTime * 0.02);
                            p.y += snoise(position.yyz + uTime * 0.02);
                            p.z += snoise(position.zxy + uTime * 0.02);

                            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);

                            gl_PointSize = uScale * (150.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;

                            vec3 worldPosition = (modelMatrix * vec4(p, 1.0)).xyz;
                            float linearDepth = 1.0 / (uCameraFar - uCameraNear);
                            float linearPos = length(cameraPosition - worldPosition) * linearDepth;

                            vFade = 1.0 - linearPos * 0.75;
                            vFade *= smoothstep(0.09, 0.13, linearPos);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        #include <packing>

                        uniform sampler2D tMap;
                        uniform sampler2D tDepth;
                        uniform float uAlpha;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform vec2 uResolution;

                        in float vFade;

                        out vec4 FragColor;

                        ${depth}

                        float fadeEdge(float particleDepth, float sceneDepth) {
                            // Margin makes it blend through the solid objects a little bit more,
                            // creating illusion of density
                            float extraMargin = 0.015;
                            float a = (sceneDepth + extraMargin - particleDepth) * 120.0;

                            if (a <= 0.0) return 0.0;
                            if (a >= 1.0) return 1.0;

                            if (a < 0.5) a = 2.0 * a * a;
                            else a = -2.0 * pow(a - 1.0, 2.0) + 1.0;

                            return a;
                        }

                        void main() {
                            FragColor = texture(tMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));

                            vec2 uv = gl_FragCoord.xy / uResolution;
                            float particleDepth = getDepth(gl_FragCoord.z, uCameraNear, uCameraFar);
                            float sceneDepth = getDepth(tDepth, uv, uCameraNear, uCameraFar);
                            float alphaScale = fadeEdge(particleDepth, sceneDepth);

                            FragColor.a *= alphaScale;
                            FragColor.a *= vFade;
                            FragColor.a *= uAlpha;
                        }
                    `,
                    transparent: true,
                    blending: AdditiveBlending,
                    depthTest: false,
                    depthWrite: false
                });

                const points = new Points(geometry, material);
                this.add(points);

                this.material = material;
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(0x060606),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distance',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uBlurDist.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBlurDist.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBlurAmount.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBlurAmount.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uRGBAmount.value,
                        callback: value => {
                            compositeMaterial.uniforms.uRGBAmount.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, dust) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.dust = dust;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetA.depthTexture = new DepthTexture();

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Blend it additively
                this.bloomCompositeMaterial.blending = AdditiveBlending;

                // Dust scene
                this.dustScene = new Scene();
                this.dustScene.add(this.dust);

                this.dust.material.uniforms.tDepth.value = this.renderTargetA.depthTexture;

                // Copy material
                this.copyMaterial = new CopyMaterial();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.screen, this.screenCamera);

                // Dust scene
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.dustScene, camera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.dust = new Dust(1000);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera, this.dust);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_radial_glow.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Radial Glow Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, GLSL3, Group, HemisphereLight, IcosahedronGeometry, LightOptions, LightPanelController, LinearSRGBColorSpace, LuminosityMaterial, MaterialPanelController, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OrbitControls, OrthographicCamera, Panel, PanelItem, PerspectiveCamera, Point3D, RawShaderMaterial, RepeatWrapping, Scene, ScenePanel, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByLight, getKeyByValue, ticker, tween } from '../../build/alien.three.js';

        const isOrbit = /[?&]orbit/.test(location.search);

        const colors = {
            backgroundColor: 0x010204,
            lightColor: 0x323850
        };

        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class CompositeMaterial extends RawShaderMaterial {
            constructor() {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tScene: { value: null },
                        tBloom: { value: null },
                        uLightPosition: { value: new Vector2(0.5, 0.5) },
                        uLightColor: { value: new Color(colors.lightColor) },
                        uPower: { value: 1.5 },
                        uAmount: { value: 0.3 },
                        uResolution: { value: new Vector2() }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tScene;
                        uniform sampler2D tBloom;
                        uniform vec2 uLightPosition;
                        uniform vec3 uLightColor;
                        uniform float uPower;
                        uniform float uAmount;
                        uniform vec2 uResolution;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${dither}

                        void main() {
                            FragColor = texture(tScene, vUv);

                            FragColor.rgb += texture(tBloom, vUv).rgb;

                            // Radial gradient for fake volumetric light
                            vec2 uv = vUv - uLightPosition;
                            uv.x *= uResolution.x / uResolution.y;

                            float amount = length(uv);
                            amount = pow(amount, uPower);
                            amount *= 1.0 - uAmount;

                            FragColor.rgb += clamp(uLightColor * (1.0 - amount), 0.0, 1.0);

                            FragColor.rgb = dither(FragColor.rgb);
                            FragColor.a = 1.0;
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        class DarkPlanet extends Group {
            constructor() {
                super();

                // 25 degree tilt like Mars
                this.rotation.z = MathUtils.degToRad(25);
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(1, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    name: 'Dark Planet',
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3),
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = () => {
                // Counter clockwise rotation
                this.mesh.rotation.y += 0.005;
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.darkPlanet = new DarkPlanet();
                this.add(this.darkPlanet);
            }

            // Public methods

            resize = () => {
            };

            update = () => {
                this.darkPlanet.update();
            };

            ready = () => this.darkPlanet.ready();
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class ScenePanelController {
            static init(view) {
                this.view = view;

                this.initPanel();

                this.addListeners();
            }

            static initPanel() {
                const { darkPlanet } = this.view;

                const objects = [darkPlanet];

                objects.forEach(object => {
                    object.point = new Point3D(object.mesh);
                    object.add(object.point);

                    MaterialPanelController.init(object.mesh, object.point);
                });
            }

            static addListeners() {
                Point3D.events.on('change', this.onChange);
            }

            // Event handlers

            static onChange = ({ selected }) => {
                if (selected.length) {
                    CameraController.enabled = false;
                } else {
                    CameraController.enabled = true;
                }
            };
        }

        class PostPanel extends Panel {
            constructor() {
                super();

                this.initPanel();
            }

            initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const postOptions = {
                    Off: false,
                    On: true
                };

                const postItems = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                const items = [
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        name: 'Post',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: (value, item) => {
                            if (!item.hasContent()) {
                                const postPanel = new Panel();
                                postPanel.animateIn(true);

                                postItems.forEach(data => {
                                    postPanel.add(new PanelItem(data));
                                });

                                item.setContent(postPanel);
                            }

                            RenderManager.enabled = postOptions[value];

                            if (RenderManager.enabled) {
                                item.toggleContent(true);
                            } else {
                                item.toggleContent(false);
                            }
                        }
                    }
                ];

                items.forEach(data => {
                    this.add(new PanelItem(data));
                });
            }
        }

        class PanelController {
            static init(renderer, scene, camera, view, ui) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;
                this.ui = ui;

                this.lights = [];

                this.initControllers();
                this.initPanel();
            }

            static initControllers() {
                Point3D.init(this.renderer, this.scene, this.camera, {
                    container: this.ui
                });

                ScenePanelController.init(this.view);
                LightPanelController.init(this.scene);
            }

            static initPanel() {
                const { compositeMaterial } = RenderManager;

                const sceneOptions = {
                    Scene: ScenePanel,
                    Post: PostPanel
                };

                this.scene.traverse(object => {
                    if (object.isLight) {
                        const key = getKeyByLight(LightOptions, object);

                        sceneOptions[key] = [object, LightOptions[key][1]];

                        this.lights.push(object);
                    }
                });

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'color',
                        value: compositeMaterial.uniforms.uLightColor.value,
                        callback: value => {
                            compositeMaterial.uniforms.uLightColor.value.copy(value);
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 0,
                        max: 6,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uPower.value,
                        callback: value => {
                            compositeMaterial.uniforms.uPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Amount',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: compositeMaterial.uniforms.uAmount.value,
                        callback: value => {
                            compositeMaterial.uniforms.uAmount.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: sceneOptions,
                        value: 'Scene',
                        callback: (value, item) => {
                            switch (value) {
                                case 'Scene':
                                case 'Post': {
                                    const ScenePanel = sceneOptions[value];

                                    const scenePanel = new ScenePanel(this.scene, this.ui);
                                    scenePanel.animateIn(true);

                                    item.setContent(scenePanel);
                                    break;
                                }
                                default: {
                                    const [light, LightPanel] = sceneOptions[value];

                                    const lightPanel = new LightPanel(LightPanelController, light);
                                    lightPanel.animateIn(true);

                                    item.setContent(lightPanel);
                                    break;
                                }
                            }
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }

            // Public methods

            static update = time => {
                if (!this.ui) {
                    return;
                }

                Point3D.update(time);
            };
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, light) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.light = light;

                // Volumetric light
                this.lightPosition = new Vector3();

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial({ dithering: true });
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new CompositeMaterial();
                this.compositeMaterial.uniforms.uResolution = resolution;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static setLightPosition() {
                this.lightPosition.copy(this.light.position).project(this.camera);

                const x = (this.lightPosition.x + 1) / 2;
                const y = (this.lightPosition.y + 1) / 2;

                this.compositeMaterial.uniforms.uLightPosition.value.set(x, y);
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Volumetric light pass
                this.setLightPosition();

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                if (isOrbit) {
                    return;
                }

                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static start = () => {
                if (isOrbit) {
                    return;
                }

                this.camera.fov = 75;
                this.camera.updateProjectionMatrix();
            };

            static animateIn = () => {
                if (isOrbit) {
                    return;
                }

                this.enabled = true;

                tween(this.camera, { fov: 30 }, 7000, 'easeInOutCubic', null, () => {
                    this.camera.updateProjectionMatrix();
                });
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(colors.backgroundColor);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0, 5, -2);
                this.scene.add(light);

                this.light = light;
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static initControls() {
                if (!isOrbit) {
                    return;
                }

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                if (this.controls && this.controls.enabled) {
                    this.controls.update();
                }
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.start();

                this.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera, light } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera, light);
            }

            static initPanel() {
                const { renderer, scene, camera } = WorldController;

                PanelController.init(renderer, scene, camera, this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                PanelController.update(time);
                this.ui.update();
            };

            // Public methods

            static animateIn = () => {
                CameraController.animateIn();
                SceneController.animateIn();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_reflection_diffuse.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Reflection Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Fog, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Reflector, RepeatWrapping, SVGLoader, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // https://vimeo.com/69949278

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { camera, loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.position.set(0, 1.4, -11);
                group.scale.y *= -1;
                group.lookAt(camera.position);

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/polished_concrete_basecolor.jpg'),
                    loadTexture('pbr/polished_concrete_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/polished_concrete_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const uniforms = {
                    mirror: { value: 0 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture2D(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);

                this.uniforms = uniforms;
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new Triangle();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { floor } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Mirror',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: floor.uniforms.mirror.value,
                        callback: value => {
                            floor.uniforms.mirror.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: floor.uniforms.mixStrength.value,
                        callback: value => {
                            floor.uniforms.mixStrength.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_reflection_dudv.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Reflection Shader DuDv — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Reflector, ReflectorDudvMaterial, RepeatWrapping, SVGLoader, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // https://vimeo.com/69949278

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { camera, loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.position.set(0, 1.4, -11);
                group.scale.y *= -1;
                group.lookAt(camera.position);

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector({ blurIterations: 4 });
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 3);

                const material = new ReflectorDudvMaterial({
                    map,
                    reflectivity: 0.5
                });
                material.uniforms.tReflect = { value: this.reflector.renderTarget.texture };
                material.uniforms.tReflectBlur = this.reflector.renderTargetUniform;
                material.uniforms.uMatrix = this.reflector.textureMatrixUniform;

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);

                this.material = material;
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new Triangle();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { floor } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Reflect',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: floor.material.uniforms.uReflectivity.value,
                        callback: value => {
                            floor.material.uniforms.uReflectivity.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_reflection_metalness.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Reflection Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, EnvironmentTextureLoader, Fog, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Reflector, RepeatWrapping, SVGLoader, Scene, SceneCompositeDistortionMaterial, StandardMaterialPanel, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // https://vimeo.com/69949278

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { camera, loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.position.set(0, 1.4, -11);
                group.scale.y *= -1;
                group.lookAt(camera.position);

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/concrete_wet_floor_basecolor.jpg'),
                    loadTexture('pbr/concrete_wet_floor_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/concrete_wet_floor_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    normalMap,
                    normalScale: new Vector2(-3, -3)
                });

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture2D(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        totalEmissiveRadiance += reflectColor.rgb * metalnessFactor;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);

                this.material = material;
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new Triangle();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { floor } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'content',
                        callback: (value, item) => {
                            const materialPanel = new StandardMaterialPanel(floor);
                            materialPanel.animateIn(true);

                            item.setContent(materialPanel);
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');

                this.svgLoader = new SVGLoader();
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('arches_pinetree.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_reflection_normalmap.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Reflection Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Fog, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Reflector, RepeatWrapping, SVGLoader, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // https://vimeo.com/69949278

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { camera, loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.position.set(0, 1.4, -11);
                group.scale.y *= -1;
                group.lookAt(camera.position);

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const normalMap = await loadTexture('pbr/polished_concrete_normal.jpg');
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(8, 8);

                const material = new MeshStandardMaterial({
                    color: new Color(0x111111),
                    metalness: 0,
                    roughness: 1,
                    normalMap,
                    normalScale: new Vector2(5, 5)
                });

                const uniforms = {
                    mirror: { value: 1 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture2D(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);

                this.uniforms = uniforms;
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new Triangle();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { floor } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Mirror',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: floor.uniforms.mirror.value,
                        callback: value => {
                            floor.uniforms.mirror.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: floor.uniforms.mixStrength.value,
                        callback: value => {
                            floor.uniforms.mixStrength.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_reflection.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Reflection Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, DirectionalLight, Fog, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Reflector, ReflectorMaterial, RepeatWrapping, SVGLoader, Scene, SceneCompositeDistortionMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // https://vimeo.com/69949278

        class Triangle extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { camera, loadSVG } = WorldController;

                const data = await loadSVG('data:image/svg+xml;utf8,<svg><path d="M 3 0 L 0 5 H 6 Z" stroke-width="0.25"/></svg>');
                const paths = data.paths;

                const group = new Group();
                group.position.set(0, 1.4, -11);
                group.scale.y *= -1;
                group.lookAt(camera.position);

                for (let i = 0, l = paths.length; i < l; i++) {
                    const path = paths[i];

                    const material = new MeshBasicMaterial();

                    for (let j = 0, jl = path.subPaths.length; j < jl; j++) {
                        const subPath = path.subPaths[j];
                        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);

                        if (geometry) {
                            geometry.center();

                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                }

                this.add(group);
            }

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { scene, loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Textures
                const [map, normalMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/concrete_wet_floor_basecolor.jpg'),
                    // loadTexture('waternormals.jpg')
                    loadTexture('pbr/concrete_wet_floor_normal.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;

                const { fog } = scene;

                const material = new ReflectorMaterial({
                    map,
                    normalMap,
                    normalScale: new Vector2(5, 5),
                    reflectivity: 0.5,
                    mirror: 1,
                    mixStrength: 4,
                    fog,
                    dithering: true
                });
                material.uniforms.tReflect = this.reflector.renderTargetUniform;
                material.uniforms.uMatrix = this.reflector.textureMatrixUniform;

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);

                this.material = material;
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.triangle = new Triangle();
                this.add(this.triangle);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.triangle.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { floor } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Reflect',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: floor.material.uniforms.uReflectivity.value,
                        callback: value => {
                            floor.material.uniforms.uReflectivity.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Mirror',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: floor.material.uniforms.uMirror.value,
                        callback: value => {
                            floor.material.uniforms.uMirror.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: floor.material.uniforms.uMixStrength.value,
                        callback: value => {
                            floor.material.uniforms.uMixStrength.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 14;
                } else {
                    this.camera.position.z = 10;
                }

                this.origin.z = this.camera.position.z;

                this.camera.lookAt(this.lookAt);
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.svgLoader = new SVGLoader();
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadSVG = path => this.svgLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_single_pass_blur.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Single Pass Blur Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { Color, ColorManagement, CopyMaterial, DirectionalLight, Group, HemisphereLight, LinearSRGBColorSpace, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, Scene, SinglePassBlurMaterial, SphereGeometry, UI, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                const material = new MeshStandardMaterial({ roughness: 0 });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { blurMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Blur',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: blurMaterial.uniforms.uBlurAmount.value,
                        callback: value => {
                            blurMaterial.uniforms.uBlurAmount.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.blurAmount = 10;
                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetA.depthBuffer = true;

                // Gaussian blur material
                this.blurMaterial = new SinglePassBlurMaterial();
                this.blurMaterial.uniforms.uBlurAmount.value = this.blurAmount;
                this.blurMaterial.uniforms.uResolution = resolution;

                // Copy material
                this.copyMaterial = new CopyMaterial();
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.screen, this.screenCamera);

                // Gaussian blur pass (render to screen)
                this.blurMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.blurMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_smaa.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>SMAA Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { Color, ColorManagement, DirectionalLight, Group, HemisphereLight, LinearSRGBColorSpace, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, SMAABlendMaterial, SMAAEdgesMaterial, SMAAWeightsMaterial, Scene, SphereGeometry, TextureLoader, UI, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, getKeyByValue, ticker } from '../../build/alien.three.js';

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                const material = new MeshStandardMaterial({ roughness: 0 });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const postOptions = {
                    Off: false,
                    SMAA: true
                };

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'list',
                        list: postOptions,
                        value: getKeyByValue(postOptions, RenderManager.enabled),
                        callback: value => {
                            RenderManager.enabled = postOptions[value];
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        // Based on https://github.com/pmndrs/postprocessing by vanruesc
        // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/postprocessing/SMAAPass.js by mpk

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, texelSize, textureLoader } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetEdges = this.renderTarget.clone();
                this.renderTargetWeights = this.renderTarget.clone();

                this.renderTarget.depthBuffer = true;

                // SMAA edge detection material
                this.edgesMaterial = new SMAAEdgesMaterial();
                this.edgesMaterial.uniforms.uTexelSize = texelSize;

                // SMAA weights material
                this.weightsMaterial = new SMAAWeightsMaterial(textureLoader, {
                    areaTexturePath: 'smaa/area.png',
                    searchTexturePath: 'smaa/search.png'
                });
                this.weightsMaterial.uniforms.uTexelSize = texelSize;

                // SMAA material
                this.smaaMaterial = new SMAABlendMaterial();
                this.smaaMaterial.uniforms.tWeightMap.value = this.renderTargetWeights.texture;
                this.smaaMaterial.uniforms.uTexelSize = texelSize;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);
                this.renderTargetEdges.setSize(width, height);
                this.renderTargetWeights.setSize(width, height);
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetEdges = this.renderTargetEdges;
                const renderTargetWeights = this.renderTargetWeights;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // SMAA edge detection pass
                this.edgesMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.edgesMaterial;
                renderer.setRenderTarget(renderTargetEdges);
                renderer.render(this.screen, this.screenCamera);

                // SMAA weights pass
                this.weightsMaterial.uniforms.tMap.value = renderTargetEdges.texture;
                this.screen.material = this.weightsMaterial;
                renderer.setRenderTarget(renderTargetWeights);
                renderer.render(this.screen, this.screenCamera);

                // SMAA pass (render to screen)
                this.smaaMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.smaaMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance'
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_soft_particles.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Soft Particles Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BufferGeometry, Color, ColorManagement, CopyMaterial, DepthTexture, DirectionalLight, EnvironmentTextureLoader, Float32BufferAttribute, GLSL3, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrbitControls, OrthographicCamera, PanelItem, PerspectiveCamera, Points, RawShaderMaterial, RepeatWrapping, Scene, SceneCompositeMaterial, SphereGeometry, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import simplex3d from '../../src/shaders/modules/noise/simplex3d.glsl.js';
        import depth from '../../src/shaders/modules/depth/depth.glsl.js';

        class Dust extends Group {
            constructor(numParticles) {
                super();

                this.numParticles = numParticles;

                this.initPoints();
            }

            initPoints() {
                const { camera, getTexture, resolution, time } = WorldController;

                const vertices = [];

                for (let i = 0; i < this.numParticles; i++) {
                    vertices[i * 3 + 0] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 1] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 2] = MathUtils.randFloatSpread(camera.far / 2);
                }

                const geometry = new BufferGeometry();
                geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));

                // Based on https://jsfiddle.net/m7tvxpbs/ by Mugen87

                const material = new RawShaderMaterial({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: getTexture('particle.png') },
                        tDepth: { value: null },
                        uScale: { value: window.devicePixelRatio / 2 },
                        uAlpha: { value: 1 },
                        uCameraNear: { value: camera.near },
                        uCameraFar: { value: camera.far },
                        uResolution: resolution,
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;

                        uniform mat4 modelMatrix;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;

                        uniform float uScale;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform float uTime;

                        out float vFade;

                        ${simplex3d}

                        void main() {
                            vec3 p = position;
                            p.x += snoise(position.xyz + uTime * 0.02);
                            p.y += snoise(position.yyz + uTime * 0.02);
                            p.z += snoise(position.zxy + uTime * 0.02);

                            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);

                            gl_PointSize = uScale * (150.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;

                            vec3 worldPosition = (modelMatrix * vec4(p, 1.0)).xyz;
                            float linearDepth = 1.0 / (uCameraFar - uCameraNear);
                            float linearPos = length(cameraPosition - worldPosition) * linearDepth;

                            vFade = 1.0 - linearPos * 0.75;
                            vFade *= smoothstep(0.09, 0.13, linearPos);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        #include <packing>

                        uniform sampler2D tMap;
                        uniform sampler2D tDepth;
                        uniform float uAlpha;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform vec2 uResolution;

                        in float vFade;

                        out vec4 FragColor;

                        ${depth}

                        float fadeEdge(float particleDepth, float sceneDepth) {
                            // Margin makes it blend through the solid objects a little bit more,
                            // creating illusion of density
                            float extraMargin = 0.015;
                            float a = (sceneDepth + extraMargin - particleDepth) * 120.0;

                            if (a <= 0.0) return 0.0;
                            if (a >= 1.0) return 1.0;

                            if (a < 0.5) a = 2.0 * a * a;
                            else a = -2.0 * pow(a - 1.0, 2.0) + 1.0;

                            return a;
                        }

                        void main() {
                            FragColor = texture(tMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));

                            vec2 uv = gl_FragCoord.xy / uResolution;
                            float particleDepth = getDepth(gl_FragCoord.z, uCameraNear, uCameraFar);
                            float sceneDepth = getDepth(tDepth, uv, uCameraNear, uCameraFar);
                            float alphaScale = fadeEdge(particleDepth, sceneDepth);

                            FragColor.a *= alphaScale;
                            FragColor.a *= vFade;
                            FragColor.a *= uAlpha;
                        }
                    `,
                    transparent: true,
                    blending: AdditiveBlending,
                    depthTest: false,
                    depthWrite: false
                });

                const points = new Points(geometry, material);
                this.add(points);

                this.material = material;
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(0x060606),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, dust) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.dust = dust;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetA.depthTexture = new DepthTexture();

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Dust scene
                this.dustScene = new Scene();
                this.dustScene.add(this.dust);

                this.dust.material.uniforms.tDepth.value = this.renderTargetA.depthTexture;

                // Copy material
                this.copyMaterial = new CopyMaterial();

                // Composite material
                this.compositeMaterial = new SceneCompositeMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Dust scene
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.dustScene, camera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTargetB.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.dust = new Dust(1000);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera, this.dust);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_soft_shadows.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Soft Shadows Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        :root {
            --bg-color: #fff;
            --ui-color: #000;
            --ui-color-triplet: 0 0 0;
        }
    </style>

    <script type="module">
        import { BasicShadowMap, BufferGeometryLoader, BufferGeometryLoaderThread, Color, ColorManagement, DirectionalLight, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, Mesh, MeshPhongMaterial, OrbitControls, PanelItem, PerspectiveCamera, PlaneGeometry, Reflector, RepeatWrapping, Scene, ShadowMaterial, SoftShadows, SphereGeometry, TextureLoader, UI, Vector2, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://threejs.org/examples/#webgl_shadowmap_pcss by spidersharma03

        class Sphere extends Group {
            constructor() {
                super();

                this.position.y = 0.8;

                this.initMesh();
            }

            initMesh() {
                const mesh = new Mesh(
                    new SphereGeometry(0.5, 80, 40),
                    new MeshPhongMaterial({ color: Math.random() * 0xffffff })
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = time => {
                this.mesh.position.y = Math.sin(time) * 0.6;
            };
        }

        import dither from '../../src/shaders/modules/dither/dither.glsl.js';

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 3);

                const material = new ShadowMaterial({
                    toneMapped: false
                });

                material.onBeforeCompile = shader => {
                    map.updateMatrix();

                    shader.uniforms.map = { value: map };
                    shader.uniforms.reflectMap = { value: this.reflector.renderTarget.texture };
                    shader.uniforms.reflectMapBlur = this.reflector.renderTargetUniform;
                    shader.uniforms.uvTransform = { value: map.matrix };
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat3 uvTransform;
                        uniform mat4 textureMatrix;

                        out vec2 vUv;
                        out vec4 vCoord;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vUv = (uvTransform * vec3(uv, 1)).xy;
                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D map;
                        uniform sampler2D reflectMap;
                        uniform sampler2D reflectMapBlur;

                        in vec2 vUv;
                        in vec4 vCoord;

                        ${dither}

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );',
                        /* glsl */ `
                        vec2 reflectionUv = vCoord.xy / vCoord.w;

                        vec4 dudv = texture(map, vUv);
                        vec4 color = texture(reflectMap, reflectionUv);

                        vec4 blur;

                        blur = texture(reflectMapBlur, reflectionUv + dudv.rg / 256.0);
                        color = mix(color, blur, smoothstep(1.0, 0.1, dudv.g));

                        blur = texture(reflectMapBlur, reflectionUv);
                        color = mix(color, blur, smoothstep(0.5, 1.0, dudv.r));

                        gl_FragColor = color * mix(0.6, 0.75, dudv.g);

                        gl_FragColor.rgb -= (1.0 - getShadowMask()) * 0.125;

                        gl_FragColor.rgb = dither(gl_FragColor.rgb);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -0.54;
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.sphere = new Sphere();
                this.add(this.sphere);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            update = time => {
                this.sphere.update(time);
            };

            ready = () => Promise.all([
                this.floor.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = time => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update(time);
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(light, ui) {
                this.light = light;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Penumbra',
                        min: 20,
                        max: 108,
                        step: 1,
                        value: this.light.shadow.camera.far,
                        callback: value => {
                            this.light.shadow.camera.far = value;
                            this.light.shadow.camera.updateProjectionMatrix();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.renderer.render(this.scene, this.camera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initShadows();
                this.initLights();
                this.initLoaders();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0xffffff);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.set(0, 3, 8);
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initShadows() {
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = BasicShadowMap;

                SoftShadows.init({
                    size: 0.004,
                    frustum: 3.75,
                    near: 9.5,
                    samples: 4,
                    rings: 3
                });
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(5, 5, 5);
                light.castShadow = true;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                light.shadow.camera.near = 0.1;
                light.shadow.camera.far = 50;
                this.scene.add(light);

                this.light = light;
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.bufferGeometryLoader = new BufferGeometryLoader();
                this.bufferGeometryLoader.setPath('../assets/geometry/');
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static getBufferGeometry = (path, callback) => this.bufferGeometryLoader.load(path, callback);

            static loadBufferGeometry = path => this.bufferGeometryLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                SceneController.animateIn();

                this.initPanel();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
                BufferGeometryLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                const { light } = WorldController;

                PanelController.init(light, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                SceneController.update(time);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_subsurface_scattering.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Subsurface Scattering Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, Color, ColorManagement, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, PointLight, Reflector, ReflectorDudvMaterial, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, ShaderChunk, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        const colors = {
            lightColor: 0xf44336
        };

        class Ball extends Group {
            constructor() {
                super();

                this.frameRotation = 0;
                this.position.x = 1;
                this.position.z = 1;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 0.9, 4.4, 0);
                this.add(light);
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.25, 6);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(colors.lightColor),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.7 };
                    shader.uniforms.thicknessPower = { value: 2 };
                    shader.uniforms.thicknessScale = { value: 32 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }

            // Public methods

            update = () => {
                this.frameRotation += 0.01;
                this.position.x = 1 * Math.sin(this.frameRotation);
                this.position.z = 1 * Math.cos(this.frameRotation);
            };

            ready = () => this.initMesh();
        }

        class Sphere extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.5, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu
                // Based on https://gist.github.com/mattdesl/2ee82157a86962347dedb6572142df7c

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.185 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 1 },
                    thicknessPower: { value: 20 },
                    thicknessScale: { value: 16 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).r;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += material.diffuseColor * directLight.color * scatteringIllu * thicknessAttenuation;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.uniforms = uniforms;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector({ blurIterations: 6 });
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                const map = await loadTexture('waterdudv.jpg');
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(6, 6);

                const material = new ReflectorDudvMaterial({
                    map,
                    reflectivity: 0.5
                });
                material.uniforms.tReflect = { value: this.reflector.renderTarget.texture };
                material.uniforms.tReflectBlur = this.reflector.renderTargetUniform;
                material.uniforms.uMatrix = this.reflector.textureMatrixUniform;

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -0.54;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.sphere = new Sphere();
                this.add(this.sphere);

                this.ball = new Ball();
                this.add(this.ball);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            update = () => {
                this.ball.update();
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.sphere.ready(),
                this.ball.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const { sphere } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: sphere.uniforms.thicknessDistortion.value,
                        callback: value => {
                            sphere.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAmbient.value,
                        callback: value => {
                            sphere.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            sphere.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: sphere.uniforms.thicknessPower.value,
                        callback: value => {
                            sphere.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: sphere.uniforms.thicknessScale.value,
                        callback: value => {
                            sphere.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_text.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Text Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BufferAttribute, BufferGeometry, Color, ColorManagement, DirectionalLight, Fog, Group, HemisphereLight, LinearFilter, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PlaneGeometry, Reflector, RepeatWrapping, Scene, SceneCompositeDistortionMaterial, Text, TextMaterial, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        // Based on https://oframe.github.io/ogl/examples/?src=msdf-text.html by gordonnl

        /*

        Instructions to generate required MSDF assets

        1) Install `msdf-bmfont`:
        https://github.com/soimy/msdf-bmfont-xml

        2) Using a .ttf font file, run the following command:
        `msdf-bmfont -f json -m 512,512 -d 2 --pot --smart-size Roboto-Bold.ttf`

        3) Outputs a .png bitmap spritesheet and a .json with character parameters.

        */

        class Text2D extends Group {
            constructor() {
                super();

                this.count = 0;
                this.time = 0;
                this.prev = 0;
                this.fps = 0;
            }

            async initMesh() {
                const { loadTexture, camera } = WorldController;

                const map = await loadTexture('fonts/Roboto-Bold.png');
                map.minFilter = LinearFilter;
                map.generateMipmaps = false;

                const material = new TextMaterial({ map });
                material.uniforms.uAlpha.value = 0.94;

                const font = await (await fetch('../assets/textures/fonts/Roboto-Bold.json')).json();

                const text = new Text({
                    font,
                    text: this.fps.toString(),
                    width: 4,
                    align: 'center',
                    letterSpacing: -0.05,
                    size: 2,
                    lineHeight: 1.1
                });

                const geometry = new BufferGeometry();

                const mesh = new Mesh(geometry, material);
                mesh.frustumCulled = false;
                mesh.position.set(0, 1.4, -11);
                mesh.lookAt(camera.position);

                this.add(mesh);

                this.text = text;
                this.geometry = geometry;

                this.update();
            }

            // Public methods

            update = () => {
                this.time = performance.now();

                if (this.time - 1000 > this.prev) {
                    this.prev = this.time;
                    this.fps = this.count;
                    this.count = 0;
                }

                this.count++;

                this.text.update({ text: this.fps.toString() });

                this.geometry.setAttribute('position', new BufferAttribute(this.text.buffers.position, 3));
                this.geometry.setAttribute('uv', new BufferAttribute(this.text.buffers.uv, 2));
                this.geometry.setAttribute('id', new BufferAttribute(this.text.buffers.id, 1));
                this.geometry.setIndex(new BufferAttribute(this.text.buffers.index, 1));
            };

            ready = () => this.initMesh();
        }

        class Floor extends Group {
            constructor() {
                super();

                this.initReflector();
            }

            initReflector() {
                this.reflector = new Reflector();
            }

            async initMesh() {
                const { loadTexture } = WorldController;

                const geometry = new PlaneGeometry(100, 100);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/polished_concrete_basecolor.jpg'),
                    loadTexture('pbr/polished_concrete_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/polished_concrete_orm.jpg')
                ]);

                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(16, 16);

                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(16, 16);

                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(16, 16);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const uniforms = {
                    mirror: { value: 0 },
                    mixStrength: { value: 10 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms.reflectMap = this.reflector.renderTargetUniform;
                    shader.uniforms.textureMatrix = this.reflector.textureMatrixUniform;

                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform mat4 textureMatrix;

                        out vec4 vCoord;
                        out vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <project_vertex>',
                        /* glsl */ `
                        #include <project_vertex>

                        vCoord = textureMatrix * vec4(transformed, 1.0);
                        vToEye = cameraPosition - (modelMatrix * vec4(transformed, 1.0)).xyz;
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D reflectMap;
                        uniform float mirror;
                        uniform float mixStrength;

                        in vec4 vCoord;
                        in vec3 vToEye;

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <emissivemap_fragment>',
                        /* glsl */ `
                        #include <emissivemap_fragment>

                        vec4 normalColor = texture2D(normalMap, vNormalMapUv * normalScale);
                        vec3 reflectNormal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
                        vec3 reflectCoord = vCoord.xyz / vCoord.w;
                        vec2 reflectUv = reflectCoord.xy + reflectCoord.z * reflectNormal.xz * 0.05;
                        vec4 reflectColor = texture2D(reflectMap, reflectUv);

                        // Fresnel term
                        vec3 toEye = normalize(vToEye);
                        float theta = max(dot(toEye, normal), 0.0);
                        float reflectance = pow((1.0 - theta), 5.0);

                        reflectColor = mix(vec4(0), reflectColor, reflectance);

                        diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectColor.rgb * mixStrength);
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                mesh.position.y = -1.6;
                mesh.rotation.x = -Math.PI / 2;
                mesh.add(this.reflector);

                mesh.onBeforeRender = (renderer, scene, camera) => {
                    this.visible = false;
                    this.reflector.update(renderer, scene, camera);
                    this.visible = true;
                };

                this.add(mesh);
            }

            // Public methods

            resize = (width, height) => {
                width = Math.round(width / 2);
                height = 1024;

                this.reflector.setSize(width, height);
            };

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.floor = new Floor();
                this.add(this.floor);

                this.text = new Text2D();
                this.add(this.text);
            }

            // Public methods

            resize = (width, height) => {
                this.floor.resize(width, height);
            };

            ready = () => Promise.all([
                this.floor.ready(),
                this.text.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = (width, height) => {
                this.view.resize(width, height);
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.view.text.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial, compositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Chroma',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: compositeMaterial.uniforms.uBloomDistortion.value,
                        callback: value => {
                            compositeMaterial.uniforms.uBloomDistortion.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;
                this.bloomDistortion = 1;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeDistortionMaterial({ dithering: true });
                this.compositeMaterial.uniforms.uBloomDistortion.value = this.bloomDistortion;
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(5, 1);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.scene.fog = new Fog(this.scene.background, 1, 100);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 10;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize(width, height);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_tilt_shift.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Tilt-shift Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BufferGeometry, Color, ColorManagement, CopyMaterial, DepthTexture, DirectionalLight, EnvironmentTextureLoader, Float32BufferAttribute, GLSL3, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, OrbitControls, OrthographicCamera, PanelItem, PerspectiveCamera, Points, RawShaderMaterial, RepeatWrapping, Scene, SphereGeometry, TextureLoader, TiltShiftMaterial, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import simplex3d from '../../src/shaders/modules/noise/simplex3d.glsl.js';
        import depth from '../../src/shaders/modules/depth/depth.glsl.js';

        class Dust extends Group {
            constructor(numParticles) {
                super();

                this.numParticles = numParticles;

                this.initPoints();
            }

            initPoints() {
                const { camera, getTexture, resolution, time } = WorldController;

                const vertices = [];

                for (let i = 0; i < this.numParticles; i++) {
                    vertices[i * 3 + 0] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 1] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 2] = MathUtils.randFloatSpread(camera.far / 2);
                }

                const geometry = new BufferGeometry();
                geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));

                // Based on https://jsfiddle.net/m7tvxpbs/ by Mugen87

                const material = new RawShaderMaterial({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: getTexture('particle.png') },
                        tDepth: { value: null },
                        uScale: { value: window.devicePixelRatio / 2 },
                        uAlpha: { value: 1 },
                        uCameraNear: { value: camera.near },
                        uCameraFar: { value: camera.far },
                        uResolution: resolution,
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;

                        uniform mat4 modelMatrix;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;

                        uniform float uScale;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform float uTime;

                        out float vFade;

                        ${simplex3d}

                        void main() {
                            vec3 p = position;
                            p.x += snoise(position.xyz + uTime * 0.02);
                            p.y += snoise(position.yyz + uTime * 0.02);
                            p.z += snoise(position.zxy + uTime * 0.02);

                            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);

                            gl_PointSize = uScale * (150.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;

                            vec3 worldPosition = (modelMatrix * vec4(p, 1.0)).xyz;
                            float linearDepth = 1.0 / (uCameraFar - uCameraNear);
                            float linearPos = length(cameraPosition - worldPosition) * linearDepth;

                            vFade = 1.0 - linearPos * 0.75;
                            vFade *= smoothstep(0.09, 0.13, linearPos);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        #include <packing>

                        uniform sampler2D tMap;
                        uniform sampler2D tDepth;
                        uniform float uAlpha;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform vec2 uResolution;

                        in float vFade;

                        out vec4 FragColor;

                        ${depth}

                        float fadeEdge(float particleDepth, float sceneDepth) {
                            // Margin makes it blend through the solid objects a little bit more,
                            // creating illusion of density
                            float extraMargin = 0.015;
                            float a = (sceneDepth + extraMargin - particleDepth) * 120.0;

                            if (a <= 0.0) return 0.0;
                            if (a >= 1.0) return 1.0;

                            if (a < 0.5) a = 2.0 * a * a;
                            else a = -2.0 * pow(a - 1.0, 2.0) + 1.0;

                            return a;
                        }

                        void main() {
                            FragColor = texture(tMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));

                            vec2 uv = gl_FragCoord.xy / uResolution;
                            float particleDepth = getDepth(gl_FragCoord.z, uCameraNear, uCameraFar);
                            float sceneDepth = getDepth(tDepth, uv, uCameraNear, uCameraFar);
                            float alphaScale = fadeEdge(particleDepth, sceneDepth);

                            FragColor.a *= alphaScale;
                            FragColor.a *= vFade;
                            FragColor.a *= uAlpha;
                        }
                    `,
                    transparent: true,
                    blending: AdditiveBlending,
                    depthTest: false,
                    depthWrite: false
                });

                const points = new Points(geometry, material);
                this.add(points);

                this.material = material;
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(0x060606),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { hTiltShiftMaterial, vTiltShiftMaterial, luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Blur',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: hTiltShiftMaterial.uniforms.uBlurAmount.value,
                        callback: value => {
                            hTiltShiftMaterial.uniforms.uBlurAmount.value = value;
                            vTiltShiftMaterial.uniforms.uBlurAmount.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Focus',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: hTiltShiftMaterial.uniforms.uFocus.value,
                        callback: value => {
                            hTiltShiftMaterial.uniforms.uFocus.value = value;
                            vTiltShiftMaterial.uniforms.uFocus.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, dust) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.dust = dust;

                // Gaussian blur
                this.blurAmount = 7;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetA.depthTexture = new DepthTexture();

                // Tilt-shift Gaussian blur materials
                this.hTiltShiftMaterial = new TiltShiftMaterial(BlurDirectionX);
                this.hTiltShiftMaterial.uniforms.uBlurAmount.value = this.blurAmount;
                this.hTiltShiftMaterial.uniforms.uResolution = resolution;

                this.vTiltShiftMaterial = new TiltShiftMaterial(BlurDirectionY);
                this.vTiltShiftMaterial.uniforms.uBlurAmount.value = this.blurAmount;
                this.vTiltShiftMaterial.uniforms.uResolution = resolution;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Blend it additively
                this.bloomCompositeMaterial.blending = AdditiveBlending;

                // Dust scene
                this.dustScene = new Scene();
                this.dustScene.add(this.dust);

                this.dust.material.uniforms.tDepth.value = this.renderTargetA.depthTexture;

                // Copy material
                this.copyMaterial = new CopyMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.screen, this.screenCamera);

                // Dust scene
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.dustScene, camera);

                // Tilt-shift pass Gaussian blur (horizontal and vertical)
                this.hTiltShiftMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.hTiltShiftMaterial;
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vTiltShiftMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.vTiltShiftMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Copy pass (render to screen)
                this.copyMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.dust = new Dust(1000);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera, this.dust);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_unreal_bloom.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Unreal Bloom Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { Color, ColorManagement, DirectionalLight, Group, HemisphereLight, LinearSRGBColorSpace, LuminosityMaterial, Mesh, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, Scene, SceneCompositeMaterial, SphereGeometry, UI, UnrealBloomBlurMaterial, UnrealBloomCompositeMaterial, Vector2, Vector3, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import periodic3d from '../../src/shaders/modules/noise/periodic3d.glsl.js';

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const { time } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                const material = new MeshStandardMaterial({ roughness: 0 });

                // Based on https://github.com/spite/perlin-experiments

                material.onBeforeCompile = shader => {
                    shader.uniforms.time = time;

                    shader.vertexShader = shader.vertexShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform float time;

                        ${periodic3d}

                        void main() {
                        `
                    );

                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        /* glsl */ `
                        float f = 0.05 * pnoise(vec3(2.0 * normal + time), vec3(10.0));
                        vec3 transformed = position + f * normal;
                        `
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            bloomCompositeMaterial.uniforms.uBloomStrength.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            bloomCompositeMaterial.uniforms.uBloomRadius.value = value;
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/postprocessing/UnrealBloomPass.js by spidersharma03 and bhouston

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];
                const bloomTintColors = [
                    new Vector3(1, 1, 1),
                    new Vector3(1, 1, 1),
                    new Vector3(1, 1, 1),
                    new Vector3(1, 1, 1),
                    new Vector3(1, 1, 1)
                ];

                this.bloomCompositeMaterial = new UnrealBloomCompositeMaterial(this.nMips);
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomStrength.value = this.bloomStrength;
                this.bloomCompositeMaterial.uniforms.uBloomRadius.value = this.bloomRadius;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = bloomFactors;
                this.bloomCompositeMaterial.uniforms.uBloomTintColors.value = bloomTintColors;

                // Composite material
                this.compositeMaterial = new SceneCompositeMaterial();
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 1.2);
                light.position.set(1, 1, 1);
                this.scene.add(light);
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_vignette_blur.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Vignette Blur Post-processing — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { AdditiveBlending, BloomCompositeMaterial, BufferGeometry, Color, ColorManagement, CopyMaterial, DepthTexture, DirectionalLight, EnvironmentTextureLoader, Float32BufferAttribute, GLSL3, Group, HemisphereLight, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshStandardMaterial, NoBlending, OrbitControls, OrthographicCamera, PanelItem, PerspectiveCamera, Points, RawShaderMaterial, RepeatWrapping, Scene, SphereGeometry, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        import smootherstep from '../../src/shaders/modules/smootherstep/smootherstep.glsl.js';
        import blur from '../../src/shaders/modules/blur/blur.glsl.js';

        class BlurMaterial extends RawShaderMaterial {
            constructor(direction = new Vector2(0.5, 0.5)) {
                super({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: null },
                        uBlurAmount: { value: 1 },
                        uInnerRadius: { value: 0.5 },
                        uOuterRadius: { value: 1 },
                        uDirection: { value: direction },
                        uResolution: { value: new Vector2() }
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;
                        in vec2 uv;

                        out vec2 vUv;

                        void main() {
                            vUv = uv;

                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        uniform sampler2D tMap;
                        uniform float uBlurAmount;
                        uniform float uInnerRadius;
                        uniform float uOuterRadius;
                        uniform vec2 uDirection;
                        uniform vec2 uResolution;

                        in vec2 vUv;

                        out vec4 FragColor;

                        ${smootherstep}
                        ${blur}

                        void main() {
                            float center = length(vUv - 0.5);

                            FragColor = blur(tMap, vUv, uResolution, uBlurAmount * smootherstep(uInnerRadius, uOuterRadius, center) * uDirection);
                        }
                    `,
                    blending: NoBlending,
                    depthTest: false,
                    depthWrite: false
                });
            }
        }

        import simplex3d from '../../src/shaders/modules/noise/simplex3d.glsl.js';
        import depth from '../../src/shaders/modules/depth/depth.glsl.js';

        class Dust extends Group {
            constructor(numParticles) {
                super();

                this.numParticles = numParticles;

                this.initPoints();
            }

            initPoints() {
                const { camera, getTexture, resolution, time } = WorldController;

                const vertices = [];

                for (let i = 0; i < this.numParticles; i++) {
                    vertices[i * 3 + 0] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 1] = MathUtils.randFloatSpread(camera.far / 2);
                    vertices[i * 3 + 2] = MathUtils.randFloatSpread(camera.far / 2);
                }

                const geometry = new BufferGeometry();
                geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));

                // Based on https://jsfiddle.net/m7tvxpbs/ by Mugen87

                const material = new RawShaderMaterial({
                    glslVersion: GLSL3,
                    uniforms: {
                        tMap: { value: getTexture('particle.png') },
                        tDepth: { value: null },
                        uScale: { value: window.devicePixelRatio / 2 },
                        uAlpha: { value: 1 },
                        uCameraNear: { value: camera.near },
                        uCameraFar: { value: camera.far },
                        uResolution: resolution,
                        uTime: time
                    },
                    vertexShader: /* glsl */ `
                        in vec3 position;

                        uniform mat4 modelMatrix;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;

                        uniform float uScale;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform float uTime;

                        out float vFade;

                        ${simplex3d}

                        void main() {
                            vec3 p = position;
                            p.x += snoise(position.xyz + uTime * 0.02);
                            p.y += snoise(position.yyz + uTime * 0.02);
                            p.z += snoise(position.zxy + uTime * 0.02);

                            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);

                            gl_PointSize = uScale * (150.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;

                            vec3 worldPosition = (modelMatrix * vec4(p, 1.0)).xyz;
                            float linearDepth = 1.0 / (uCameraFar - uCameraNear);
                            float linearPos = length(cameraPosition - worldPosition) * linearDepth;

                            vFade = 1.0 - linearPos * 0.75;
                            vFade *= smoothstep(0.09, 0.13, linearPos);
                        }
                    `,
                    fragmentShader: /* glsl */ `
                        precision highp float;

                        #include <packing>

                        uniform sampler2D tMap;
                        uniform sampler2D tDepth;
                        uniform float uAlpha;
                        uniform float uCameraNear;
                        uniform float uCameraFar;
                        uniform vec2 uResolution;

                        in float vFade;

                        out vec4 FragColor;

                        ${depth}

                        float fadeEdge(float particleDepth, float sceneDepth) {
                            // Margin makes it blend through the solid objects a little bit more,
                            // creating illusion of density
                            float extraMargin = 0.015;
                            float a = (sceneDepth + extraMargin - particleDepth) * 120.0;

                            if (a <= 0.0) return 0.0;
                            if (a >= 1.0) return 1.0;

                            if (a < 0.5) a = 2.0 * a * a;
                            else a = -2.0 * pow(a - 1.0, 2.0) + 1.0;

                            return a;
                        }

                        void main() {
                            FragColor = texture(tMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));

                            vec2 uv = gl_FragCoord.xy / uResolution;
                            float particleDepth = getDepth(gl_FragCoord.z, uCameraNear, uCameraFar);
                            float sceneDepth = getDepth(tDepth, uv, uCameraNear, uCameraFar);
                            float alphaScale = fadeEdge(particleDepth, sceneDepth);

                            FragColor.a *= alphaScale;
                            FragColor.a *= vFade;
                            FragColor.a *= uAlpha;
                        }
                    `,
                    transparent: true,
                    blending: AdditiveBlending,
                    depthTest: false,
                    depthWrite: false
                });

                const points = new Points(geometry, material);
                this.add(points);

                this.material = material;
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new SphereGeometry(1, 80, 80);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(0x060606),
                    metalness: 1,
                    roughness: 1,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(1, 1)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                const mesh = new Mesh(geometry, material);
                this.add(mesh);
            }
        }

        class PanelController {
            static init(ui) {
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { hBlurMaterial, vBlurMaterial, luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Blur',
                        min: 0,
                        max: 10,
                        step: 0.1,
                        value: hBlurMaterial.uniforms.uBlurAmount.value,
                        callback: value => {
                            hBlurMaterial.uniforms.uBlurAmount.value = value;
                            vBlurMaterial.uniforms.uBlurAmount.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Inner',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: hBlurMaterial.uniforms.uInnerRadius.value,
                        callback: value => {
                            hBlurMaterial.uniforms.uInnerRadius.value = value;
                            vBlurMaterial.uniforms.uInnerRadius.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Outer',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: hBlurMaterial.uniforms.uOuterRadius.value,
                        callback: value => {
                            hBlurMaterial.uniforms.uOuterRadius.value = value;
                            vBlurMaterial.uniforms.uOuterRadius.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, dust) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.dust = dust;

                // Gaussian blur
                this.blurAmount = 2.2;
                this.innerRadius = 0.22;
                this.outerRadius = 0.66;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle, resolution } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTargetA = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetB = this.renderTargetA.clone();

                this.renderTargetBright = this.renderTargetA.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTargetA.clone());
                    this.renderTargetsVertical.push(this.renderTargetA.clone());
                }

                this.renderTargetA.depthBuffer = true;
                this.renderTargetA.depthTexture = new DepthTexture();

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;
                this.hBlurMaterial.uniforms.uInnerRadius.value = this.innerRadius;
                this.hBlurMaterial.uniforms.uOuterRadius.value = this.outerRadius;
                this.hBlurMaterial.uniforms.uResolution = resolution;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;
                this.vBlurMaterial.uniforms.uInnerRadius.value = this.innerRadius;
                this.vBlurMaterial.uniforms.uOuterRadius.value = this.outerRadius;
                this.vBlurMaterial.uniforms.uResolution = resolution;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Blend it additively
                this.bloomCompositeMaterial.blending = AdditiveBlending;

                // Dust scene
                this.dustScene = new Scene();
                this.dustScene.add(this.dust);

                this.dust.material.uniforms.tDepth.value = this.renderTargetA.depthTexture;

                // Copy material
                this.copyMaterial = new CopyMaterial();
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTargetA.setSize(width, height);
                this.renderTargetB.setSize(width, height);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTargetA = this.renderTargetA;
                const renderTargetB = this.renderTargetB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Scene pass
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(scene, camera);

                // Copy pass
                this.copyMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.screen, this.screenCamera);

                // Dust scene
                renderer.setRenderTarget(renderTargetB);
                renderer.render(this.dustScene, camera);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetA.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Copy pass (render to screen)
                this.copyMaterial.uniforms.tMap.value = renderTargetB.texture;
                this.screen.material = this.copyMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));

                const light = new DirectionalLight(0xffffff, 2);
                light.position.set(0.6, 0.5, 1);
                this.scene.add(light);
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 0.5;
            }

            static initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                // this.controls.enableZoom = false;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                if (width < height) {
                    this.camera.position.z = 10;
                } else {
                    this.camera.position.z = 8;
                }

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;

                this.controls.update();
            };

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                this.initPanel();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.dust = new Dust(1000);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                RenderManager.init(renderer, scene, camera, this.dust);
            }

            static initPanel() {
                PanelController.init(this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/shader_volumetric_light.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Volumetric Light Shader — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="module">
        import { BloomCompositeMaterial, BlurMaterial, Color, ColorManagement, EnvironmentTextureLoader, Group, HemisphereLight, IcosahedronGeometry, ImageBitmapLoaderThread, LinearSRGBColorSpace, LuminosityMaterial, MathUtils, Mesh, MeshBasicMaterial, MeshStandardMaterial, OrthographicCamera, PanelItem, PerspectiveCamera, PointLight, RepeatWrapping, Scene, SceneCompositeAddMaterial, ShaderChunk, TextureLoader, UI, UnrealBloomBlurMaterial, Vector2, Vector3, VolumetricLightMaterial, WebGLRenderTarget, WebGLRenderer, getFullscreenTriangle, ticker } from '../../build/alien.three.js';

        const colors = {
            lightColor: 0xf44336
        };

        const layers = {
            default: 0,
            occlusion: 1
        };

        class Ball extends Group {
            constructor() {
                super();

                this.frameRotation = 0;
                this.position.x = 1;
                this.position.z = 1;

                this.initLight();
            }

            initLight() {
                const light = new PointLight(colors.lightColor, 1.9, 2.2, 0);
                this.add(light);
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.25, 6);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color(colors.lightColor),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu

                material.onBeforeCompile = shader => {
                    shader.uniforms.thicknessMap = { value: thicknessMap };
                    shader.uniforms.thicknessDistortion = { value: 0.1 };
                    shader.uniforms.thicknessAmbient = { value: 0 };
                    shader.uniforms.thicknessAttenuation = { value: 0.2 };
                    shader.uniforms.thicknessPower = { value: 2 };
                    shader.uniforms.thicknessScale = { value: 16 };

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).g;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                // Occlusion mesh
                const occMesh = mesh.clone();
                occMesh.material = new MeshBasicMaterial({ color: colors.lightColor });
                occMesh.layers.set(layers.occlusion);
                this.add(occMesh);
            }

            // Public methods

            update = () => {
                this.frameRotation += 0.01;
                this.position.x = 1 * Math.sin(this.frameRotation);
                this.position.z = 1 * Math.cos(this.frameRotation);
            };

            ready = () => this.initMesh();
        }

        class Sphere extends Group {
            constructor() {
                super();
            }

            async initMesh() {
                const { anisotropy, loadTexture } = WorldController;

                const geometry = new IcosahedronGeometry(0.5, 12);

                // Second set of UVs for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                geometry.attributes.uv1 = geometry.attributes.uv;

                // Textures
                const [map, normalMap, ormMap, thicknessMap] = await Promise.all([
                    // loadTexture('uv.jpg'),
                    loadTexture('pbr/pitted_metal_basecolor.jpg'),
                    loadTexture('pbr/pitted_metal_normal.jpg'),
                    // https://occlusion-roughness-metalness.glitch.me/
                    loadTexture('pbr/pitted_metal_orm.jpg'),
                    loadTexture('pbr/pitted_metal_height.jpg')
                ]);

                map.anisotropy = anisotropy;
                map.wrapS = RepeatWrapping;
                map.wrapT = RepeatWrapping;
                map.repeat.set(2, 1);

                normalMap.anisotropy = anisotropy;
                normalMap.wrapS = RepeatWrapping;
                normalMap.wrapT = RepeatWrapping;
                normalMap.repeat.set(2, 1);

                ormMap.anisotropy = anisotropy;
                ormMap.wrapS = RepeatWrapping;
                ormMap.wrapT = RepeatWrapping;
                ormMap.repeat.set(2, 1);

                thicknessMap.anisotropy = anisotropy;
                thicknessMap.wrapS = RepeatWrapping;
                thicknessMap.wrapT = RepeatWrapping;
                thicknessMap.repeat.set(2, 1);

                const material = new MeshStandardMaterial({
                    color: new Color().offsetHSL(0, 0, -0.65),
                    metalness: 0.7,
                    roughness: 2,
                    map,
                    metalnessMap: ormMap,
                    roughnessMap: ormMap,
                    aoMap: ormMap,
                    aoMapIntensity: 1,
                    normalMap,
                    normalScale: new Vector2(3, 3)
                });

                // Second channel for aoMap and lightMap
                // https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.aoMap
                material.aoMap.channel = 1;

                // Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/SubsurfaceScatteringShader.js by daoshengmu
                // Based on https://gist.github.com/mattdesl/2ee82157a86962347dedb6572142df7c

                const uniforms = {
                    thicknessMap: { value: thicknessMap },
                    thicknessDistortion: { value: 0.185 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 1 },
                    thicknessPower: { value: 20 },
                    thicknessScale: { value: 16 }
                };

                material.onBeforeCompile = shader => {
                    shader.uniforms = Object.assign(shader.uniforms, uniforms);

                    shader.fragmentShader = shader.fragmentShader.replace(
                        'void main() {',
                        /* glsl */ `
                        uniform sampler2D thicknessMap;
                        uniform float thicknessDistortion;
                        uniform float thicknessAmbient;
                        uniform float thicknessAttenuation;
                        uniform float thicknessPower;
                        uniform float thicknessScale;

                        void RE_Direct_Scattering(IncidentLight directLight, vec2 uv, vec3 geometryPosition, vec3 geometryNormal, vec3 geometryViewDir, vec3 geometryClearcoatNormal, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
                            vec3 thickness = directLight.color * texture(thicknessMap, uv).r;
                            vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                            float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
                            reflectedLight.directDiffuse += material.diffuseColor * directLight.color * scatteringIllu * thicknessAttenuation;
                        }

                        void main() {
                        `
                    );

                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <lights_fragment_begin>',
                        ShaderChunk.lights_fragment_begin.replaceAll(
                            'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                            /* glsl */ `
                            RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                            RE_Direct_Scattering(directLight, vAoMapUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
                            `
                        )
                    );
                };

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.uniforms = uniforms;
            }

            // Public methods

            ready = () => this.initMesh();
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.visible = false;

                this.initViews();
            }

            initViews() {
                this.sphere = new Sphere();
                this.add(this.sphere);

                this.ball = new Ball();
                this.add(this.ball);
            }

            // Public methods

            update = () => {
                this.ball.update();
            };

            ready = () => Promise.all([
                this.sphere.ready(),
                this.ball.ready()
            ]);
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static resize = () => {
            };

            static update = () => {
                if (!this.view.visible) {
                    return;
                }

                this.view.update();
            };

            static animateIn = () => {
                this.view.visible = true;
            };

            static ready = () => this.view.ready();
        }

        class PanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const { vlMaterial, luminosityMaterial, bloomCompositeMaterial } = RenderManager;

                const { sphere } = this.view;

                const items = [
                    {
                        name: 'FPS'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Exp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uExposure.value,
                        callback: value => {
                            vlMaterial.uniforms.uExposure.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Decay',
                        min: 0.6,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDecay.value,
                        callback: value => {
                            vlMaterial.uniforms.uDecay.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Density',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uDensity.value,
                        callback: value => {
                            vlMaterial.uniforms.uDensity.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Weight',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uWeight.value,
                        callback: value => {
                            vlMaterial.uniforms.uWeight.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Clamp',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: vlMaterial.uniforms.uClamp.value,
                        callback: value => {
                            vlMaterial.uniforms.uClamp.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Distort',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: sphere.uniforms.thicknessDistortion.value,
                        callback: value => {
                            sphere.uniforms.thicknessDistortion.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Ambient',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAmbient.value,
                        callback: value => {
                            sphere.uniforms.thicknessAmbient.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Atten',
                        min: 0,
                        max: 5,
                        step: 0.01,
                        value: sphere.uniforms.thicknessAttenuation.value,
                        callback: value => {
                            sphere.uniforms.thicknessAttenuation.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Power',
                        min: 1,
                        max: 32,
                        step: 0.1,
                        value: sphere.uniforms.thicknessPower.value,
                        callback: value => {
                            sphere.uniforms.thicknessPower.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Scale',
                        min: 0,
                        max: 64,
                        step: 0.1,
                        value: sphere.uniforms.thicknessScale.value,
                        callback: value => {
                            sphere.uniforms.thicknessScale.value = value;
                        }
                    },
                    {
                        type: 'divider'
                    },
                    {
                        type: 'slider',
                        name: 'Thresh',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uThreshold.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uThreshold.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Smooth',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: luminosityMaterial.uniforms.uSmoothing.value,
                        callback: value => {
                            luminosityMaterial.uniforms.uSmoothing.value = value;
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Strength',
                        min: 0,
                        max: 2,
                        step: 0.01,
                        value: RenderManager.bloomStrength,
                        callback: value => {
                            RenderManager.bloomStrength = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    },
                    {
                        type: 'slider',
                        name: 'Radius',
                        min: 0,
                        max: 1,
                        step: 0.01,
                        value: RenderManager.bloomRadius,
                        callback: value => {
                            RenderManager.bloomRadius = value;
                            bloomCompositeMaterial.uniforms.uBloomFactors.value = RenderManager.bloomFactors();
                        }
                    }
                ];

                items.forEach(data => {
                    this.ui.addPanel(new PanelItem(data));
                });
            }
        }

        const BlurDirectionX = new Vector2(1, 0);
        const BlurDirectionY = new Vector2(0, 1);

        class RenderManager {
            static init(renderer, scene, camera, view) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;

                // Volumetric light
                this.lightPosition = new Vector3();
                this.vlExposure = 0.1;
                this.vlDecay = 1;
                this.vlDensity = 1;
                this.vlWeight = 0.4;
                this.vlClamp = 1;
                this.blurResolutionScale = 0.25;
                this.blurAmount = 2.5;

                // Unreal bloom
                this.luminosityThreshold = 0.1;
                this.luminositySmoothing = 1;
                this.bloomStrength = 0.3;
                this.bloomRadius = 0.2;

                this.enabled = true;

                this.initRenderer();
            }

            static initRenderer() {
                const { screenTriangle } = WorldController;

                // Manually clear
                this.renderer.autoClear = false;

                // Clear colors
                this.clearColor = new Color(0, 0, 0);
                this.currentClearColor = new Color();

                // Fullscreen triangle
                this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.screen = new Mesh(screenTriangle);
                this.screen.frustumCulled = false;

                // Render targets
                this.renderTarget = new WebGLRenderTarget(1, 1, {
                    depthBuffer: false
                });

                this.renderTargetBlurA = this.renderTarget.clone();
                this.renderTargetBlurB = this.renderTarget.clone();

                this.renderTargetBright = this.renderTarget.clone();
                this.renderTargetsHorizontal = [];
                this.renderTargetsVertical = [];
                this.nMips = 5;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal.push(this.renderTarget.clone());
                    this.renderTargetsVertical.push(this.renderTarget.clone());
                }

                this.renderTarget.depthBuffer = true;
                this.renderTargetBlurA.depthBuffer = true;

                // Occlusion material
                this.blackoutMaterial = new MeshBasicMaterial({ color: 0x000000 });

                // Gaussian blur materials
                this.hBlurMaterial = new BlurMaterial(BlurDirectionX);
                this.hBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                this.vBlurMaterial = new BlurMaterial(BlurDirectionY);
                this.vBlurMaterial.uniforms.uBlurAmount.value = this.blurAmount;

                // Volumetric light material
                this.vlMaterial = new VolumetricLightMaterial();
                this.vlMaterial.uniforms.uExposure.value = this.vlExposure;
                this.vlMaterial.uniforms.uDecay.value = this.vlDecay;
                this.vlMaterial.uniforms.uDensity.value = this.vlDensity;
                this.vlMaterial.uniforms.uWeight.value = this.vlWeight;
                this.vlMaterial.uniforms.uClamp.value = this.vlClamp;

                // Luminosity high pass material
                this.luminosityMaterial = new LuminosityMaterial();
                this.luminosityMaterial.uniforms.uThreshold.value = this.luminosityThreshold;
                this.luminosityMaterial.uniforms.uSmoothing.value = this.luminositySmoothing;

                // Separable Gaussian blur materials
                this.blurMaterials = [];

                const kernelSizeArray = [3, 5, 7, 9, 11];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.blurMaterials.push(new UnrealBloomBlurMaterial(kernelSizeArray[i]));
                }

                // Unreal bloom composite material
                this.bloomCompositeMaterial = new BloomCompositeMaterial();
                this.bloomCompositeMaterial.uniforms.tBlur1.value = this.renderTargetsVertical[0].texture;
                this.bloomCompositeMaterial.uniforms.tBlur2.value = this.renderTargetsVertical[1].texture;
                this.bloomCompositeMaterial.uniforms.tBlur3.value = this.renderTargetsVertical[2].texture;
                this.bloomCompositeMaterial.uniforms.tBlur4.value = this.renderTargetsVertical[3].texture;
                this.bloomCompositeMaterial.uniforms.tBlur5.value = this.renderTargetsVertical[4].texture;
                this.bloomCompositeMaterial.uniforms.uBloomFactors.value = this.bloomFactors();

                // Composite material
                this.compositeMaterial = new SceneCompositeAddMaterial({ dithering: true });
            }

            static bloomFactors() {
                const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];

                for (let i = 0, l = this.nMips; i < l; i++) {
                    const factor = bloomFactors[i];
                    bloomFactors[i] = this.bloomStrength * MathUtils.lerp(factor, 1.2 - factor, this.bloomRadius);
                }

                return bloomFactors;
            }

            static setLightPosition() {
                this.lightPosition.copy(this.view.ball.position).project(this.camera);

                const x = (this.lightPosition.x + 1) / 2;
                const y = (this.lightPosition.y + 1) / 2;

                this.vlMaterial.uniforms.uLightPosition.value.set(x, y);
            }

            // Public methods

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);

                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.renderTarget.setSize(width, height);

                // Gaussian blur
                const blurWidth = Math.round(width * this.blurResolutionScale);
                const blurHeight = Math.round(height * this.blurResolutionScale);

                this.renderTargetBlurA.setSize(blurWidth, blurHeight);
                this.renderTargetBlurB.setSize(blurWidth, blurHeight);

                this.hBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);
                this.vBlurMaterial.uniforms.uResolution.value.set(blurWidth, blurHeight);

                // Unreal bloom
                width = Math.round(width / 2);
                height = Math.round(height / 2);

                this.renderTargetBright.setSize(width, height);

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.renderTargetsHorizontal[i].setSize(width, height);
                    this.renderTargetsVertical[i].setSize(width, height);

                    this.blurMaterials[i].uniforms.uResolution.value.set(width, height);

                    width = Math.round(width / 2);
                    height = Math.round(height / 2);
                }
            };

            static update = () => {
                const renderer = this.renderer;
                const scene = this.scene;
                const camera = this.camera;

                if (!this.enabled) {
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(scene, camera);
                    return;
                }

                const renderTarget = this.renderTarget;
                const renderTargetBlurA = this.renderTargetBlurA;
                const renderTargetBlurB = this.renderTargetBlurB;
                const renderTargetBright = this.renderTargetBright;
                const renderTargetsHorizontal = this.renderTargetsHorizontal;
                const renderTargetsVertical = this.renderTargetsVertical;

                // Renderer state
                const currentOverrideMaterial = scene.overrideMaterial;
                const currentBackground = scene.background;
                renderer.getClearColor(this.currentClearColor);
                const currentClearAlpha = renderer.getClearAlpha();

                // Scene layer
                camera.layers.set(layers.default);

                renderer.setRenderTarget(renderTarget);
                renderer.clear();
                renderer.render(scene, camera);

                // Occlusion layer
                scene.background = null;
                renderer.setClearColor(this.clearColor, 1);

                scene.overrideMaterial = this.blackoutMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(scene, camera);
                scene.overrideMaterial = currentOverrideMaterial;

                camera.layers.set(layers.occlusion);

                renderer.render(scene, camera);

                // Restore renderer settings
                scene.background = currentBackground;
                renderer.setClearColor(this.currentClearColor, currentClearAlpha);

                // Two pass Gaussian blur (horizontal and vertical)
                this.hBlurMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.screen.material = this.hBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                this.vBlurMaterial.uniforms.tMap.value = renderTargetBlurB.texture;
                this.screen.material = this.vBlurMaterial;
                renderer.setRenderTarget(renderTargetBlurA);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Volumetric light pass
                this.vlMaterial.uniforms.tMap.value = renderTargetBlurA.texture;
                this.setLightPosition();
                this.screen.material = this.vlMaterial;
                renderer.setRenderTarget(renderTargetBlurB);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Extract bright areas
                this.luminosityMaterial.uniforms.tMap.value = renderTarget.texture;
                this.screen.material = this.luminosityMaterial;
                renderer.setRenderTarget(renderTargetBright);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Blur all the mips progressively
                let inputRenderTarget = renderTargetBright;

                for (let i = 0, l = this.nMips; i < l; i++) {
                    this.screen.material = this.blurMaterials[i];

                    this.blurMaterials[i].uniforms.tMap.value = inputRenderTarget.texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionX;
                    renderer.setRenderTarget(renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    this.blurMaterials[i].uniforms.tMap.value = this.renderTargetsHorizontal[i].texture;
                    this.blurMaterials[i].uniforms.uDirection.value = BlurDirectionY;
                    renderer.setRenderTarget(renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.screen, this.screenCamera);

                    inputRenderTarget = renderTargetsVertical[i];
                }

                // Composite all the mips
                this.screen.material = this.bloomCompositeMaterial;
                renderer.setRenderTarget(renderTargetsHorizontal[0]);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);

                // Composite pass (render to screen)
                this.compositeMaterial.uniforms.tScene.value = renderTarget.texture;
                this.compositeMaterial.uniforms.tBloom.value = renderTargetsHorizontal[0].texture;
                this.compositeMaterial.uniforms.tAdd.value = renderTargetBlurB.texture;
                this.screen.material = this.compositeMaterial;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(this.screen, this.screenCamera);
            };
        }

        class CameraController {
            static init(camera) {
                this.camera = camera;

                this.mouse = new Vector2();
                this.lookAt = new Vector3(0, 0, -2);
                this.origin = new Vector3();
                this.target = new Vector3();
                this.targetXY = new Vector2(2, 0.4);
                this.origin.copy(this.camera.position);

                this.lerpSpeed = 0.02;
                this.enabled = false;

                this.addListeners();
            }

            static addListeners() {
                window.addEventListener('pointermove', this.onPointerMove);
            }

            // Event handlers

            static onPointerMove = ({ clientX, clientY }) => {
                if (!this.enabled) {
                    return;
                }

                this.mouse.x = (clientX / document.documentElement.clientWidth) * 2 - 1;
                this.mouse.y = 1 - (clientY / document.documentElement.clientHeight) * 2;
            };

            // Public methods

            static resize = (width, height) => {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            };

            static update = () => {
                if (!this.enabled) {
                    return;
                }

                this.target.x = this.origin.x + this.targetXY.x * this.mouse.x;
                this.target.y = this.origin.y + this.targetXY.y * this.mouse.y;
                this.target.z = this.origin.z;

                this.camera.position.lerp(this.target, this.lerpSpeed);
                this.camera.lookAt(this.lookAt);
            };

            static animateIn = () => {
                this.enabled = true;
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initLoaders();
                this.initEnvironment();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({
                    powerPreference: 'high-performance',
                    antialias: true
                });

                // Output canvas
                this.element = this.renderer.domElement;

                // Disable color management
                ColorManagement.enabled = false;
                this.renderer.outputColorSpace = LinearSRGBColorSpace;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);
                this.camera = new PerspectiveCamera(30);
                this.camera.near = 0.5;
                this.camera.far = 40;
                this.camera.position.z = 8;
                this.camera.lookAt(this.scene.position);

                // Global geometries
                this.screenTriangle = getFullscreenTriangle();

                // Global uniforms
                this.resolution = { value: new Vector2() };
                this.texelSize = { value: new Vector2() };
                this.aspect = { value: 1 };
                this.time = { value: 0 };
                this.frame = { value: 0 };

                // Global settings
                this.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0x606060, 0x404040, 3));
            }

            static initLoaders() {
                this.textureLoader = new TextureLoader();
                this.textureLoader.setPath('../assets/textures/');

                this.environmentLoader = new EnvironmentTextureLoader(this.renderer);
                this.environmentLoader.setPath('../assets/textures/env/');
            }

            static async initEnvironment() {
                this.scene.environment = await this.loadEnvironmentTexture('jewelry_black_contrast.jpg');
                this.scene.environmentIntensity = 1.2;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static resize = (width, height, dpr) => {
                width = Math.round(width * dpr);
                height = Math.round(height * dpr);

                this.resolution.value.set(width, height);
                this.texelSize.value.set(1 / width, 1 / height);
                this.aspect.value = width / height;
            };

            static update = (time, delta, frame) => {
                this.time.value = time;
                this.frame.value = frame;
            };

            static ready = () => Promise.all([
                this.textureLoader.ready(),
                this.environmentLoader.ready()
            ]);

            // Global handlers

            static getTexture = (path, callback) => this.textureLoader.load(path, callback);

            static loadTexture = path => this.textureLoader.loadAsync(path);

            static loadEnvironmentTexture = path => this.environmentLoader.loadAsync(path);
        }

        class App {
            static async init() {
                this.initThread();
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();

                await SceneController.ready();
                await WorldController.ready();

                this.initPanel();

                CameraController.animateIn();
                SceneController.animateIn();
            }

            static initThread() {
                ImageBitmapLoaderThread.init();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.ui = new UI({ fps: true });
                this.ui.animateIn();
                document.body.appendChild(this.ui.element);
            }

            static initControllers() {
                const { renderer, scene, camera } = WorldController;

                CameraController.init(camera);
                SceneController.init(this.view);
                RenderManager.init(renderer, scene, camera, this.view);
            }

            static initPanel() {
                PanelController.init(this.view, this.ui);
            }

            static addListeners() {
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            }

            // Event handlers

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                SceneController.resize();
                RenderManager.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update();
                RenderManager.update(time, delta, frame);
                this.ui.update();
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/test_oimophysics.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>OimoPhysics — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.js",
                "oimophysics": "https://cdn.jsdelivr.net/gh/saharan/OimoPhysics@v1.2.3/bin/js_modules/OimoPhysics.js",
                "@alienkitty/alien.js/three/oimophysics": "../../src/three.oimophysics.js"
            }
        }
    </script>

    <script type="module">
        import { OimoPhysics } from '@alienkitty/alien.js/three/oimophysics';

        const physics = new OimoPhysics();
        console.log(physics.getGravity());
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/three/test_wobble.html
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Wobble — Alien.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono">
    <link rel="stylesheet" href="../assets/css/style.css">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.js",
                "three/addons/": "https://unpkg.com/three/examples/jsm/",
                "@alienkitty/space.js/three": "https://unpkg.com/@alienkitty/space.js/src/three.js",
                "@alienkitty/alien.js/three": "../../src/three.js"
            }
        }
    </script>

    <script type="module">
        import { Vector3 } from 'three';
        import { Wobble } from '@alienkitty/alien.js/three';

        const position = new Vector3();
        const wobble = new Wobble(position);
        wobble.scale = 100;

        function animate(time) {
            requestAnimationFrame(animate);

            console.log(position);
            wobble.update(time * 0.001 * 0.5); // seconds * 0.5
        }

        requestAnimationFrame(animate);
    </script>
</head>
<body>
</body>
</html>



---
File: /examples/rollup.config.js
---

import resolve from '@rollup/plugin-node-resolve';

export default {
  input: '../src/all.three.js',
  treeshake: {
    // Needed for OimoPhysics
    correctVarValueBeforeDeclaration: true
  },
  output: {
    file: '../build/alien.three.js',
    format: 'es'
  },
  plugins: [
    resolve({
      browser: true
    })
  ]
};



---
File: /src/ogl/programs/FXAAProgram.js
---

import { Program, Vec2 } from 'ogl';

import { vertexShader, fragmentShader } from '../../shaders/FXAAShader.js';

export class FXAAProgram extends Program {
    constructor(gl) {
        super(gl, {
            uniforms: {
                tMap: { value: null },
                uResolution: { value: new Vec2() }
            },
            vertex: `#version 300 es${vertexShader}`,
            fragment: `#version 300 es${fragmentShader}`,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/ogl/programs/Programs.js
---

export { FXAAProgram } from './FXAAProgram.js';



---
File: /src/shaders/modules/aastep/aastep.glsl.js
---

// From https://github.com/glslify/glsl-aastep by mattdesl

export default /* glsl */ `
float aastep(float threshold, float value) {
    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;
    return smoothstep(threshold - afwidth, threshold + afwidth, value);
}
`;



---
File: /src/shaders/modules/badtv/badtv.glsl.js
---

// Based on https://github.com/felixturner/bad-tv-shader

import simplex2d from '../noise/simplex2d.glsl.js';

export default /* glsl */ `
${simplex2d}

vec4 getBadTV(sampler2D image, vec2 uv, float time, float distortion, float distortion2, float speed, float rollSpeed) {
    vec2 p = uv;
    float ty = time * speed;
    float yt = p.y - ty;

    // Smooth distortion
    float offset = snoise(vec2(yt * 3.0, 0.0)) * 0.2;

    // Boost distortion
    offset = offset * distortion * offset * distortion * offset;

    // Add fine grain distortion
    offset += snoise(vec2(yt * 50.0, 0.0)) * distortion2 * 0.001;

    // Combine distortion on X with roll on Y
    return texture(image, vec2(fract(p.x + offset), fract(p.y - time * rollSpeed)));
}
`;



---
File: /src/shaders/modules/blending/add.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendAdd(vec4 x, vec4 y, float opacity) {
    return min(x + y, 1.0) * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/alpha.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec3 blendAlpha(vec3 x, vec3 y, float opacity) {
    return y * opacity + x * (1.0 - opacity);
}

vec4 blendAlpha(vec4 x, vec4 y, float opacity) {
    float a = min(y.a, opacity);
    return vec4(blendAlpha(x.rgb, y.rgb, a), max(x.a, a));
}
`;



---
File: /src/shaders/modules/blending/average.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendAverage(vec4 x, vec4 y, float opacity) {
    return (x + y) * 0.5 * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/color-burn.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
float blendColorBurn(float x, float y) {
    return (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);
}

vec4 blendColorBurn(vec4 x, vec4 y, float opacity) {
    vec4 z = vec4(blendColorBurn(x.r, y.r), blendColorBurn(x.g, y.g), blendColorBurn(x.b, y.b), blendColorBurn(x.a, y.a));
    return z * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/color-dodge.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
float blendColorDodge(float x, float y) {
    return (y == 1.0) ? y : min(x / (1.0 - y), 1.0);
}

vec4 blendColorDodge(vec4 x, vec4 y, float opacity) {
    vec4 z = vec4(blendColorDodge(x.r, y.r), blendColorDodge(x.g, y.g), blendColorDodge(x.b, y.b), blendColorDodge(x.a, y.a));
    return z * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/darken.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendDarken(vec4 x, vec4 y, float opacity) {
    return min(x, y) * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/difference.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendDifference(vec4 x, vec4 y, float opacity) {
    return abs(x - y) * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/divide.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
float blendDivide(float x, float y) {
    return (y > 0.0) ? min(x / y, 1.0) : 1.0;
}

vec4 blendDivide(vec4 x, vec4 y, float opacity) {
    vec4 z = vec4(blendDivide(x.r, y.r), blendDivide(x.g, y.g), blendDivide(x.b, y.b), blendDivide(x.a, y.a));
    return z * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/exclusion.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendExclusion(vec4 x, vec4 y, float opacity) {
    return (x + y - 2.0 * x * y) * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/lighten.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendLighten(vec4 x, vec4 y, float opacity) {
    return max(x, y) * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/multiply.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendMultiply(vec4 x, vec4 y, float opacity) {
    return x * y * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/negation.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendNegation(vec4 x, vec4 y, float opacity) {
    return (1.0 - abs(1.0 - x - y)) * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/normal.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendNormal(vec4 x, vec4 y, float opacity) {
    return y * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/overlay.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
float blendOverlay(float x, float y) {
    return (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));
}

vec4 blendOverlay(vec4 x, vec4 y, float opacity) {
    vec4 z = vec4(blendOverlay(x.r, y.r), blendOverlay(x.g, y.g), blendOverlay(x.b, y.b), blendOverlay(x.a, y.a));
    return z * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/reflect.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
float blendReflect(float x, float y) {
    return (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);
}

vec4 blendReflect(vec4 x, vec4 y, float opacity) {
    vec4 z = vec4(blendReflect(x.r, y.r), blendReflect(x.g, y.g), blendReflect(x.b, y.b), blendReflect(x.a, y.a));
    return z * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/screen.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendScreen(vec4 x, vec4 y, float opacity) {
    return (1.0 - (1.0 - x) * (1.0 - y)) * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/soft-light.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
float blendSoftLight(float x, float y) {
    return (y < 0.5) ?
        (2.0 * x * y + x * x * (1.0 - 2.0 * y)) :
        (sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));
}

vec4 blendSoftLight(vec4 x, vec4 y, float opacity) {
    vec4 z = vec4(blendSoftLight(x.r, y.r), blendSoftLight(x.g, y.g), blendSoftLight(x.b, y.b), blendSoftLight(x.a, y.a));
    return z * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blending/subtract.glsl.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc

export default /* glsl */ `
vec4 blendSubtract(vec4 x, vec4 y, float opacity) {
    return max(x + y - 1.0, 0.0) * opacity + x * (1.0 - opacity);
}
`;



---
File: /src/shaders/modules/blur/blur.glsl.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/HorizontalBlurShader.js by zz85

export default /* glsl */ `
vec4 blur(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
    vec4 sum = vec4(0.0);

    vec2 texcoord = 1.0 / resolution;

    sum += texture(image, uv - 4.0 * texcoord * direction) * 0.051;
    sum += texture(image, uv - 3.0 * texcoord * direction) * 0.0918;
    sum += texture(image, uv - 2.0 * texcoord * direction) * 0.12245;
    sum += texture(image, uv - 1.0 * texcoord * direction) * 0.1531;
    sum += texture(image, uv) * 0.1633;
    sum += texture(image, uv + 1.0 * texcoord * direction) * 0.1531;
    sum += texture(image, uv + 2.0 * texcoord * direction) * 0.12245;
    sum += texture(image, uv + 3.0 * texcoord * direction) * 0.0918;
    sum += texture(image, uv + 4.0 * texcoord * direction) * 0.051;

    return sum;
}
`;



---
File: /src/shaders/modules/blur/blur13.glsl.js
---

// From https://github.com/Jam3/glsl-fast-gaussian-blur by mattdesl

export default /* glsl */ `
vec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
  vec4 color = vec4(0.0);
  vec2 off1 = vec2(1.411764705882353) * direction;
  vec2 off2 = vec2(3.2941176470588234) * direction;
  vec2 off3 = vec2(5.176470588235294) * direction;
  color += texture(image, uv) * 0.1964825501511404;
  color += texture(image, uv + (off1 / resolution)) * 0.2969069646728344;
  color += texture(image, uv - (off1 / resolution)) * 0.2969069646728344;
  color += texture(image, uv + (off2 / resolution)) * 0.09447039785044732;
  color += texture(image, uv - (off2 / resolution)) * 0.09447039785044732;
  color += texture(image, uv + (off3 / resolution)) * 0.010381362401148057;
  color += texture(image, uv - (off3 / resolution)) * 0.010381362401148057;
  return color;
}
`;



---
File: /src/shaders/modules/blur/blur5.glsl.js
---

// From https://github.com/Jam3/glsl-fast-gaussian-blur by mattdesl

export default /* glsl */ `
vec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
  vec4 color = vec4(0.0);
  vec2 off1 = vec2(1.3333333333333333) * direction;
  color += texture(image, uv) * 0.29411764705882354;
  color += texture(image, uv + (off1 / resolution)) * 0.35294117647058826;
  color += texture(image, uv - (off1 / resolution)) * 0.35294117647058826;
  return color;
}
`;



---
File: /src/shaders/modules/blur/blur9.glsl.js
---

// From https://github.com/Jam3/glsl-fast-gaussian-blur by mattdesl

export default /* glsl */ `
vec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
  vec4 color = vec4(0.0);
  vec2 off1 = vec2(1.3846153846) * direction;
  vec2 off2 = vec2(3.2307692308) * direction;
  color += texture(image, uv) * 0.2270270270;
  color += texture(image, uv + (off1 / resolution)) * 0.3162162162;
  color += texture(image, uv - (off1 / resolution)) * 0.3162162162;
  color += texture(image, uv + (off2 / resolution)) * 0.0702702703;
  color += texture(image, uv - (off2 / resolution)) * 0.0702702703;
  return color;
}
`;



---
File: /src/shaders/modules/blur/poisson-disc-blur12.glsl.js
---

// Based on https://www.shadertoy.com/view/lsfGWn by hornet
// Based on https://github.com/spite/Wagner
// Based on https://github.com/spite/codevember-2016

export default /* glsl */ `
const int NUM_TAPS = 12;

vec4 poissonSample(sampler2D image, vec2 uv, vec2 resolution, float radius, vec4 basis) {
    float max_siz = radius;
    vec2 fTaps_Poisson[NUM_TAPS];

    fTaps_Poisson[0]  = vec2(-.326,-.406);
    fTaps_Poisson[1]  = vec2(-.840,-.074);
    fTaps_Poisson[2]  = vec2(-.696, .457);
    fTaps_Poisson[3]  = vec2(-.203, .621);
    fTaps_Poisson[4]  = vec2( .962,-.195);
    fTaps_Poisson[5]  = vec2( .473,-.480);
    fTaps_Poisson[6]  = vec2( .519, .767);
    fTaps_Poisson[7]  = vec2( .185,-.893);
    fTaps_Poisson[8]  = vec2( .507, .064);
    fTaps_Poisson[9]  = vec2( .896, .412);
    fTaps_Poisson[10] = vec2(-.322,-.933);
    fTaps_Poisson[11] = vec2(-.792,-.598);

    vec4 sum = vec4(0);

    for (int i = 0; i < NUM_TAPS; i++) {
        vec2 ofs = fTaps_Poisson[i];
        ofs = vec2(dot(ofs, basis.xz), dot(ofs, basis.yw));
        vec2 texcoord = uv + max_siz * ofs / resolution.xy;
        sum += texture(image, texcoord, -10.0);
    }

    return sum / float(NUM_TAPS);
}
`;



---
File: /src/shaders/modules/blur/poisson-disc-blur27.glsl.js
---

// Based on https://www.shadertoy.com/view/lsfGWn by hornet
// Based on https://github.com/spite/Wagner
// Based on https://github.com/spite/codevember-2016

export default /* glsl */ `
const int NUM_TAPS = 27;
const float rcp_maxdist = 1.0 / 4.22244;

vec4 poissonSample(sampler2D image, vec2 uv, vec2 resolution, float radius, vec4 basis) {
    float max_siz = radius;
    vec2 fTaps_Poisson[NUM_TAPS];

    fTaps_Poisson[0]  = rcp_maxdist * vec2(  -0.8835609, 2.523391 );
    fTaps_Poisson[1]  = rcp_maxdist * vec2(  -1.387375, 1.056318 );
    fTaps_Poisson[2]  = rcp_maxdist * vec2(  -2.854452, 1.313645 );
    fTaps_Poisson[3]  = rcp_maxdist * vec2(  0.6326182, 1.14569 );
    fTaps_Poisson[4]  = rcp_maxdist * vec2(  1.331515, 3.637297 );
    fTaps_Poisson[5]  = rcp_maxdist * vec2(  -2.175307, 3.885795 );
    fTaps_Poisson[6]  = rcp_maxdist * vec2(  -0.5396664, 4.1938 );
    fTaps_Poisson[7]  = rcp_maxdist * vec2(  -0.6708734, -0.36875 );
    fTaps_Poisson[8]  = rcp_maxdist * vec2(  -2.083908, -0.6921188 );
    fTaps_Poisson[9]  = rcp_maxdist * vec2(  -3.219028, 2.85465 );
    fTaps_Poisson[10] = rcp_maxdist * vec2(  -1.863933, -2.742254 );
    fTaps_Poisson[11] = rcp_maxdist * vec2(  -4.125739, -1.283028 );
    fTaps_Poisson[12] = rcp_maxdist * vec2(  -3.376766, -2.81844 );
    fTaps_Poisson[13] = rcp_maxdist * vec2(  -3.974553, 0.5459405 );
    fTaps_Poisson[14] = rcp_maxdist * vec2(  3.102514, 1.717692 );
    fTaps_Poisson[15] = rcp_maxdist * vec2(  2.951887, 3.186624 );
    fTaps_Poisson[16] = rcp_maxdist * vec2(  1.33941, -0.166395 );
    fTaps_Poisson[17] = rcp_maxdist * vec2(  2.814727, -0.3216669 );
    fTaps_Poisson[18] = rcp_maxdist * vec2(  0.7786853, -2.235639 );
    fTaps_Poisson[19] = rcp_maxdist * vec2(  -0.7396695, -1.702466 );
    fTaps_Poisson[20] = rcp_maxdist * vec2(  0.4621856, -3.62525 );
    fTaps_Poisson[21] = rcp_maxdist * vec2(  4.181541, 0.5883132 );
    fTaps_Poisson[22] = rcp_maxdist * vec2(  4.22244, -1.11029 );
    fTaps_Poisson[23] = rcp_maxdist * vec2(  2.116917, -1.789436 );
    fTaps_Poisson[24] = rcp_maxdist * vec2(  1.915774, -3.425885 );
    fTaps_Poisson[25] = rcp_maxdist * vec2(  3.142686, -2.656329 );
    fTaps_Poisson[26] = rcp_maxdist * vec2(  -1.108632, -4.023479 );

    vec4 sum = vec4(0);

    for (int i = 0; i < NUM_TAPS; i++) {
        vec2 ofs = fTaps_Poisson[i];
        ofs = vec2(dot(ofs, basis.xz), dot(ofs, basis.yw));
        vec2 texcoord = uv + max_siz * ofs / resolution.xy;
        sum += texture(image, texcoord, -16.0);
    }

    return sum / float(NUM_TAPS);
}
`;



---
File: /src/shaders/modules/blur/radial-blur10-rgbshift.glsl.js
---

// Based on https://github.com/OGRECave/ogre/blob/master/Samples/Media/materials/programs/GLSL/Radial_Blur_FP.glsl
// Based on https://stackoverflow.com/questions/4579020/how-do-i-use-a-glsl-shader-to-apply-a-radial-blur-to-an-entire-scene

import rgbshift from '../rgbshift/rgbshift.glsl.js';

export default /* glsl */ `
${rgbshift}

vec4 radialBlurRGB(sampler2D image, vec2 uv, float sampleDist, float sampleStrength, float rgbAngle, float rgbAmount) {
    float samples[10];
    samples[0] = -0.08;
    samples[1] = -0.05;
    samples[2] = -0.03;
    samples[3] = -0.02;
    samples[4] = -0.01;
    samples[5] =  0.01;
    samples[6] =  0.02;
    samples[7] =  0.03;
    samples[8] =  0.05;
    samples[9] =  0.08;

    vec2 dir = 0.5 - uv;
    float dist = sqrt(dir.x * dir.x + dir.y * dir.y);
    dir = dir / dist;

    vec4 color = getRGB(image, uv, rgbAngle, rgbAmount);
    vec4 sum = color;

    for (int i = 0; i < 10; i++) {
        sum += getRGB(image, uv + dir * samples[i] * sampleDist, rgbAngle, rgbAmount);
    }

    sum /= 10.0;
    float t = clamp(dist * sampleStrength, 0.0, 1.0);

    return mix(color, sum, t);
}
`;



---
File: /src/shaders/modules/blur/radial-blur10.glsl.js
---

// Based on https://github.com/OGRECave/ogre/blob/master/Samples/Media/materials/programs/GLSL/Radial_Blur_FP.glsl
// Based on https://stackoverflow.com/questions/4579020/how-do-i-use-a-glsl-shader-to-apply-a-radial-blur-to-an-entire-scene

export default /* glsl */ `
vec4 radialBlur(sampler2D image, vec2 uv, float sampleDist, float sampleStrength) {
    float samples[10];
    samples[0] = -0.08;
    samples[1] = -0.05;
    samples[2] = -0.03;
    samples[3] = -0.02;
    samples[4] = -0.01;
    samples[5] =  0.01;
    samples[6] =  0.02;
    samples[7] =  0.03;
    samples[8] =  0.05;
    samples[9] =  0.08;

    vec2 dir = 0.5 - uv;
    float dist = sqrt(dir.x * dir.x + dir.y * dir.y);
    dir = dir / dist;

    vec4 color = texture(image, uv);
    vec4 sum = color;

    for (int i = 0; i < 10; i++) {
        sum += texture(image, uv + dir * samples[i] * sampleDist);
    }

    sum /= 10.0;
    float t = clamp(dist * sampleStrength, 0.0, 1.0);

    return mix(color, sum, t);
}
`;



---
File: /src/shaders/modules/blur/radial-blur8-rgbshift.glsl.js
---

// Based on https://github.com/OGRECave/ogre/blob/master/Samples/Media/materials/programs/GLSL/Radial_Blur_FP.glsl
// Based on https://stackoverflow.com/questions/4579020/how-do-i-use-a-glsl-shader-to-apply-a-radial-blur-to-an-entire-scene

import rgbshift from '../rgbshift/rgbshift.glsl.js';

export default /* glsl */ `
${rgbshift}

vec4 radialBlurRGB(sampler2D image, vec2 uv, float sampleDist, float sampleStrength, float rgbAngle, float rgbAmount) {
    float samples[8];
    samples[0] = -0.05;
    samples[1] = -0.03;
    samples[2] = -0.02;
    samples[3] = -0.01;
    samples[4] =  0.01;
    samples[5] =  0.02;
    samples[6] =  0.03;
    samples[7] =  0.05;

    vec2 dir = 0.5 - uv;
    float dist = sqrt(dir.x * dir.x + dir.y * dir.y);
    dir = dir / dist;

    vec4 color = getRGB(image, uv, rgbAngle, rgbAmount);
    vec4 sum = color;

    for (int i = 0; i < 8; i++) {
        sum += getRGB(image, uv + dir * samples[i] * sampleDist, rgbAngle, rgbAmount);
    }

    sum /= 8.0;
    float t = clamp(dist * sampleStrength, 0.0, 1.0);

    return mix(color, sum, t);
}
`;



---
File: /src/shaders/modules/blur/radial-blur8.glsl.js
---

// Based on https://github.com/OGRECave/ogre/blob/master/Samples/Media/materials/programs/GLSL/Radial_Blur_FP.glsl
// Based on https://stackoverflow.com/questions/4579020/how-do-i-use-a-glsl-shader-to-apply-a-radial-blur-to-an-entire-scene

export default /* glsl */ `
vec4 radialBlur(sampler2D image, vec2 uv, float sampleDist, float sampleStrength) {
    float samples[8];
    samples[0] = -0.05;
    samples[1] = -0.03;
    samples[2] = -0.02;
    samples[3] = -0.01;
    samples[4] =  0.01;
    samples[5] =  0.02;
    samples[6] =  0.03;
    samples[7] =  0.05;

    vec2 dir = 0.5 - uv;
    float dist = sqrt(dir.x * dir.x + dir.y * dir.y);
    dir = dir / dist;

    vec4 color = texture(image, uv);
    vec4 sum = color;

    for (int i = 0; i < 8; i++) {
        sum += texture(image, uv + dir * samples[i] * sampleDist);
    }

    sum /= 8.0;
    float t = clamp(dist * sampleStrength, 0.0, 1.0);

    return mix(color, sum, t);
}
`;



---
File: /src/shaders/modules/blur/unreal-blur.glsl.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/postprocessing/UnrealBloomPass.js by spidersharma03 and bhouston

export default /* glsl */ `
float gaussianPdf(float x, float sigma) {
    return 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;
}

vec4 blur(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
    vec2 invSize = 1.0 / resolution;
    float fSigma = float(SIGMA);
    float weightSum = gaussianPdf(0.0, fSigma);
    vec3 diffuseSum = texture(image, uv).rgb * weightSum;

    for (int i = 1; i < KERNEL_RADIUS; i++) {
        float x = float(i);
        float w = gaussianPdf(x, fSigma);
        vec2 uvOffset = direction * invSize * x;
        vec3 sample1 = texture(image, uv + uvOffset).rgb;
        vec3 sample2 = texture(image, uv - uvOffset).rgb;
        diffuseSum += (sample1 + sample2) * w;
        weightSum += 2.0 * w;
    }

    return vec4(diffuseSum / weightSum, 1.0);
}
`;



---
File: /src/shaders/modules/brightness-contrast/brightness-contrast.glsl.js
---

// Based on https://github.com/spite/Wagner

export default /* glsl */ `
vec3 getBrightnessContrast(vec3 rgb, float brightness, float contrast) {
    rgb *= contrast;
    rgb += brightness;
    return rgb;
}
`;



---
File: /src/shaders/modules/conditionals/when_and.glsl.js
---

// From https://github.com/dmnsgn/glsl-conditionals

export default /* glsl */ `
float when_and(float a, float b) {
  return a * b;
}

vec2 when_and(vec2 a, vec2 b) {
  return a * b;
}

vec3 when_and(vec3 a, vec3 b) {
  return a * b;
}

vec4 when_and(vec4 a, vec4 b) {
  return a * b;
}
`;



---
File: /src/shaders/modules/conditionals/when_eq.glsl.js
---

// From https://github.com/dmnsgn/glsl-conditionals

export default /* glsl */ `
float when_eq(float x, float y) {
  return 1.0 - abs(sign(x - y));
}

vec2 when_eq(vec2 x, vec2 y) {
  return 1.0 - abs(sign(x - y));
}

vec3 when_eq(vec3 x, vec3 y) {
  return 1.0 - abs(sign(x - y));
}

vec4 when_eq(vec4 x, vec4 y) {
  return 1.0 - abs(sign(x - y));
}
`;



---
File: /src/shaders/modules/conditionals/when_ge.glsl.js
---

// From https://github.com/dmnsgn/glsl-conditionals

import when_lt from './when_lt.glsl.js';

export default /* glsl */ `
${when_lt}

float when_ge(float x, float y) {
  return 1.0 - when_lt(x, y);
}

vec2 when_ge(vec2 x, vec2 y) {
  return 1.0 - when_lt(x, y);
}

vec3 when_ge(vec3 x, vec3 y) {
  return 1.0 - when_lt(x, y);
}

vec4 when_ge(vec4 x, vec4 y) {
  return 1.0 - when_lt(x, y);
}
`;



---
File: /src/shaders/modules/conditionals/when_gt.glsl.js
---

// From https://github.com/dmnsgn/glsl-conditionals

export default /* glsl */ `
float when_gt(float x, float y) {
  return max(sign(x - y), 0.0);
}

vec2 when_gt(vec2 x, vec2 y) {
  return max(sign(x - y), 0.0);
}

vec3 when_gt(vec3 x, vec3 y) {
  return max(sign(x - y), 0.0);
}

vec4 when_gt(vec4 x, vec4 y) {
  return max(sign(x - y), 0.0);
}
`;



---
File: /src/shaders/modules/conditionals/when_le.glsl.js
---

// From https://github.com/dmnsgn/glsl-conditionals

import when_gt from './when_gt.glsl.js';

export default /* glsl */ `
${when_gt}

float when_le(float x, float y) {
  return 1.0 - when_gt(x, y);
}

vec2 when_le(vec2 x, vec2 y) {
  return 1.0 - when_gt(x, y);
}

vec3 when_le(vec3 x, vec3 y) {
  return 1.0 - when_gt(x, y);
}

vec4 when_le(vec4 x, vec4 y) {
  return 1.0 - when_gt(x, y);
}
`;



---
File: /src/shaders/modules/conditionals/when_lt.glsl.js
---

// From https://github.com/dmnsgn/glsl-conditionals

export default /* glsl */ `
float when_lt(float x, float y) {
  return max(sign(y - x), 0.0);
}

vec2 when_lt(vec2 x, vec2 y) {
  return max(sign(y - x), 0.0);
}

vec3 when_lt(vec3 x, vec3 y) {
  return max(sign(y - x), 0.0);
}

vec4 when_lt(vec4 x, vec4 y) {
  return max(sign(y - x), 0.0);
}
`;



---
File: /src/shaders/modules/conditionals/when_neq.glsl.js
---

// From https://github.com/dmnsgn/glsl-conditionals

export default /* glsl */ `
float when_neq(float x, float y) {
  return abs(sign(x - y));
}

vec2 when_neq(vec2 x, vec2 y) {
  return abs(sign(x - y));
}

vec3 when_neq(vec3 x, vec3 y) {
  return abs(sign(x - y));
}

vec4 when_neq(vec4 x, vec4 y) {
  return abs(sign(x - y));
}
`;



---
File: /src/shaders/modules/conditionals/when_not.glsl.js
---

// From https://github.com/dmnsgn/glsl-conditionals

export default /* glsl */ `
float when_not(float a, float b) {
  returnreturn 1.0 - a;
}

vec2 when_not(vec2 a, vec2 b) {
  return 1.0 - a;
}

vec3 when_not(vec3 a, vec3 b) {
  return 1.0 - a;
}

vec4 when_not(vec4 a, vec4 b) {
  return 1.0 - a;
}
`;



---
File: /src/shaders/modules/conditionals/when_or.glsl.js
---

// From https://github.com/dmnsgn/glsl-conditionals

export default /* glsl */ `
float when_or(float a, float b) {
  return min(a + b, 1.0);
}

vec2 when_or(vec2 a, vec2 b) {
  return min(a + b, 1.0);
}

vec3 when_or(vec3 a, vec3 b) {
  return min(a + b, 1.0);
}

vec4 when_or(vec4 a, vec4 b) {
  return min(a + b, 1.0);
}
`;



---
File: /src/shaders/modules/conditionals/when_xor.glsl.js
---

// From https://github.com/dmnsgn/glsl-conditionals

export default /* glsl */ `
float when_xor(float a, float b) {
  return (a + b) % 2.0;
}

vec2 when_xor(vec2 a, vec2 b) {
  return (a + b) % 2.0;
}

vec3 when_xor(vec3 a, vec3 b) {
  return (a + b) % 2.0;
}

vec4 when_xor(vec4 a, vec4 b) {
  return (a + b) % 2.0;
}
`;



---
File: /src/shaders/modules/depth/depth.glsl.js
---

// Based on https://threejs.org/examples/#webgl_depth_texture by mattdesl

export default /* glsl */ `
float getDepth(float fragCoordZ, float near, float far) {
    float viewZ = perspectiveDepthToViewZ(fragCoordZ, near, far);
    return viewZToOrthographicDepth(viewZ, near, far);
}

float getDepth(sampler2D tex, vec2 coord, float near, float far) {
    float fragCoordZ = texture(tex, coord).x;
    return getDepth(fragCoordZ, near, far);
}
`;



---
File: /src/shaders/modules/desaturate/desaturate.glsl.js
---

// From https://gamedev.net/forums/topic/645131-color-saturation-in-glsl/

export default /* glsl */ `
vec3 desaturate(vec3 color, float amount) {
    vec3 gray = vec3(dot(vec3(0.2126, 0.7152, 0.0722), color));
    return vec3(mix(color, gray, amount));
}
`;



---
File: /src/shaders/modules/dither/dither.glsl.js
---

// Based on https://www.shadertoy.com/view/MslGR8 by hornet

import random from '../random/random.glsl.js';

export default /* glsl */ `
${random}

vec3 dither(vec3 color) {
    // Calculate grid position
    float grid_position = random(gl_FragCoord.xy);

    // Shift the individual colors differently, thus making it even harder to see the dithering pattern
    vec3 dither_shift_RGB = vec3(0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0);

    // Modify shift acording to grid position
    dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);

    // Shift the color by dither_shift
    return color + dither_shift_RGB;
}
`;



---
File: /src/shaders/modules/easing/back-in-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
#ifndef PI
#define PI 3.141592653589793
#endif

float backOut(float t) {
  float f = t < 0.5
    ? 2.0 * t
    : 1.0 - (2.0 * t - 1.0);

  float g = pow(f, 3.0) - f * sin(f * PI);

  return t < 0.5
    ? 0.5 * g
    : 0.5 * (1.0 - g) + 0.5;
}
`;



---
File: /src/shaders/modules/easing/back-in.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
#ifndef PI
#define PI 3.141592653589793
#endif

float backIn(float t) {
  return pow(t, 3.0) - t * sin(t * PI);
}
`;



---
File: /src/shaders/modules/easing/back-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
#ifndef PI
#define PI 3.141592653589793
#endif

float backOut(float t) {
  float f = 1.0 - t;
  return 1.0 - (pow(f, 3.0) - f * sin(f * PI));
}
`;



---
File: /src/shaders/modules/easing/bounce-in-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

import bounceOut from './bounce-out.glsl.js';

export default /* glsl */ `
${bounceOut}

float bounceInOut(float t) {
  return t < 0.5
    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))
    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;
}
`;



---
File: /src/shaders/modules/easing/bounce-in.glsl.js
---

// From https://github.com/glslify/glsl-easings

import bounceOut from './bounce-out.glsl.js';

export default /* glsl */ `
${bounceOut}

float bounceIn(float t) {
  return 1.0 - bounceOut(1.0 - t);
}
`;



---
File: /src/shaders/modules/easing/bounce-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
#ifndef PI
#define PI 3.141592653589793
#endif

float bounceOut(float t) {
  const float a = 4.0 / 11.0;
  const float b = 8.0 / 11.0;
  const float c = 9.0 / 10.0;

  const float ca = 4356.0 / 361.0;
  const float cb = 35442.0 / 1805.0;
  const float cc = 16061.0 / 1805.0;

  float t2 = t * t;

  return t < a
    ? 7.5625 * t2
    : t < b
      ? 9.075 * t2 - 9.9 * t + 3.4
      : t < c
        ? ca * t2 - cb * t + cc
        : 10.8 * t * t - 20.52 * t + 10.72;
}
`;



---
File: /src/shaders/modules/easing/circular-in-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float circularInOut(float t) {
  return t < 0.5
    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))
    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);
}
`;



---
File: /src/shaders/modules/easing/circular-in.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float circularIn(float t) {
  return 1.0 - sqrt(1.0 - t * t);
}
`;



---
File: /src/shaders/modules/easing/circular-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float circularOut(float t) {
  return sqrt((2.0 - t) * t);
}
`;



---
File: /src/shaders/modules/easing/cubic-in-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float cubicInOut(float t) {
  return t < 0.5
    ? 4.0 * t * t * t
    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;
}
`;



---
File: /src/shaders/modules/easing/cubic-in.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float cubicIn(float t) {
  return t * t * t;
}
`;



---
File: /src/shaders/modules/easing/cubic-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float cubicOut(float t) {
  float f = t - 1.0;
  return f * f * f + 1.0;
}
`;



---
File: /src/shaders/modules/easing/elastic-in-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
#ifndef HALF_PI
#define HALF_PI 1.5707963267948966
#endif

float elasticInOut(float t) {
  return t < 0.5
    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))
    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;
}
`;



---
File: /src/shaders/modules/easing/elastic-in.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
#ifndef HALF_PI
#define HALF_PI 1.5707963267948966
#endif

float elasticIn(float t) {
  return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));
}
`;



---
File: /src/shaders/modules/easing/elastic-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
#ifndef HALF_PI
#define HALF_PI 1.5707963267948966
#endif

float elasticOut(float t) {
  return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;
}
`;



---
File: /src/shaders/modules/easing/exponential-in-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float exponentialInOut(float t) {
  return t == 0.0 || t == 1.0
    ? t
    : t < 0.5
      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)
      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;
}
`;



---
File: /src/shaders/modules/easing/exponential-in.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float exponentialIn(float t) {
  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));
}
`;



---
File: /src/shaders/modules/easing/exponential-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float exponentialOut(float t) {
  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);
}
`;



---
File: /src/shaders/modules/easing/linear.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float linear(float t) {
  return t;
}
`;



---
File: /src/shaders/modules/easing/quadratic-in-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float quadraticInOut(float t) {
  float p = 2.0 * t * t;
  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;
}
`;



---
File: /src/shaders/modules/easing/quadratic-in.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float quadraticIn(float t) {
  return t * t;
}
`;



---
File: /src/shaders/modules/easing/quadratic-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float quadraticOut(float t) {
  return -t * (t - 2.0);
}
`;



---
File: /src/shaders/modules/easing/quartic-in-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float quarticInOut(float t) {
  return t < 0.5
    ? +8.0 * pow(t, 4.0)
    : -8.0 * pow(t - 1.0, 4.0) + 1.0;
}
`;



---
File: /src/shaders/modules/easing/quartic-in.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float quarticIn(float t) {
  return pow(t, 4.0);
}
`;



---
File: /src/shaders/modules/easing/quartic-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float quarticOut(float t) {
  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;
}
`;



---
File: /src/shaders/modules/easing/quintic-in-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float qinticInOut(float t) {
  return t < 0.5
    ? +16.0 * pow(t, 5.0)
    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;
}
`;



---
File: /src/shaders/modules/easing/quintic-in.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float qinticIn(float t) {
  return pow(t, 5.0);
}
`;



---
File: /src/shaders/modules/easing/quintic-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
float qinticOut(float t) {
  return 1.0 - (pow(t - 1.0, 5.0));
}
`;



---
File: /src/shaders/modules/easing/sine-in-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
#ifndef PI
#define PI 3.141592653589793
#endif

float sineInOut(float t) {
  return -0.5 * (cos(PI * t) - 1.0);
}
`;



---
File: /src/shaders/modules/easing/sine-in.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
#ifndef HALF_PI
#define HALF_PI 1.5707963267948966
#endif

float sineIn(float t) {
  return sin((t - 1.0) * HALF_PI) + 1.0;
}
`;



---
File: /src/shaders/modules/easing/sine-out.glsl.js
---

// From https://github.com/glslify/glsl-easings

export default /* glsl */ `
#ifndef HALF_PI
#define HALF_PI 1.5707963267948966
#endif

float sineOut(float t) {
  return sin(t * HALF_PI);
}
`;



---
File: /src/shaders/modules/encodings/encodings.glsl.js
---

// From https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/ACESFilmicToneMappingShader.js by WestLangley
// From https://oframe.github.io/ogl/examples/?src=pbr.html by gordonnl

export default /* glsl */ `
vec3 RRTAndODTFit(vec3 v) {
    vec3 a = v * (v + 0.0245786) - 0.000090537;
    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
    return a / b;
}

vec3 ACESFilmicToneMapping(vec3 color) {
    // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
    const mat3 ACESInputMat = mat3(
        vec3(0.59719, 0.07600, 0.02840), // Transposed from source
        vec3(0.35458, 0.90834, 0.13383),
        vec3(0.04823, 0.01566, 0.83777)
    );

    // ODT_SAT => XYZ => D60_2_D65 => sRGB
    const mat3 ACESOutputMat = mat3(
        vec3( 1.60475, -0.10208, -0.00327), // Transposed from source
        vec3(-0.53108,  1.10813, -0.07276),
        vec3(-0.07367, -0.00605,  1.07602)
    );

    color = ACESInputMat * color;

    // Apply RRT and ODT
    color = RRTAndODTFit(color);

    color = ACESOutputMat * color;

    // Clamp to [0, 1]
    return clamp(color, 0.0, 1.0);
}

vec4 SRGBtoLinear(vec4 srgb) {
    vec3 linOut = pow(srgb.xyz, vec3(2.2));
    return vec4(linOut, srgb.w);;
}

vec4 RGBMToLinear(vec4 value) {
    float maxRange = 6.0;
    return vec4(value.xyz * value.w * maxRange, 1.0);
}

vec3 linearToSRGB(vec3 color) {
    return pow(color, vec3(1.0 / 2.2));
}
`;



---
File: /src/shaders/modules/fbm/fbm1d.glsl.js
---

// From https://www.shadertoy.com/view/4dS3Wd by morgan3d

import noise from '../noise/noise1d.glsl.js';

export default /* glsl */ `
#define NUM_OCTAVES 5

${noise}

float fbm(float x) {
    float v = 0.0;
    float a = 0.5;
    float shift = float(100);
    for (int i = 0; i < NUM_OCTAVES; ++i) {
        v += a * noise(x);
        x = x * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}
`;



---
File: /src/shaders/modules/fbm/fbm2d.glsl.js
---

// From https://www.shadertoy.com/view/4dS3Wd by morgan3d

import noise from '../noise/noise2d.glsl.js';

export default /* glsl */ `
#define NUM_OCTAVES 5

${noise}

float fbm(vec2 x) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100);
    // Rotate to reduce axial bias
    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
    for (int i = 0; i < NUM_OCTAVES; ++i) {
        v += a * noise(x);
        x = rot * x * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}
`;



---
File: /src/shaders/modules/fbm/fbm3d.glsl.js
---

// From https://www.shadertoy.com/view/4dS3Wd by morgan3d

import noise from '../noise/noise3d.glsl.js';

export default /* glsl */ `
#define NUM_OCTAVES 5

${noise}

float fbm(vec3 x) {
    float v = 0.0;
    float a = 0.5;
    vec3 shift = vec3(100);
    for (int i = 0; i < NUM_OCTAVES; ++i) {
        v += a * noise(x);
        x = x * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}
`;



---
File: /src/shaders/modules/fresnel/fresnel.glsl.js
---

export default /* glsl */ `
float getFresnel(vec3 viewDir, vec3 worldNormal, float power) {
    return pow(1.0 - abs(dot(viewDir, worldNormal)), power);
}
`;



---
File: /src/shaders/modules/fxaa/fxaa.glsl.js
---

// From https://github.com/mattdesl/glsl-fxaa

export default /* glsl */ `
#ifndef FXAA_REDUCE_MIN
    #define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
    #define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
    #define FXAA_SPAN_MAX     8.0
#endif

vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,
            vec2 v_rgbNW, vec2 v_rgbNE,
            vec2 v_rgbSW, vec2 v_rgbSE,
            vec2 v_rgbM) {
    vec4 color;
    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);
    vec3 rgbNW = texture(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture(tex, v_rgbSE).xyz;
    vec4 texColor = texture(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
              dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
        texture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
        texture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
        texture(tex, fragCoord * inverseVP + dir * -0.5).xyz +
        texture(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}
`;



---
File: /src/shaders/modules/hsv/hsv2rgb.glsl.js
---

// Based on https://github.com/yuichiroharai/glsl-y-hsv

export default /* glsl */ `
vec3 hsv2rgb(vec3 hsv) {
    vec3 rgb = clamp(abs(mod(hsv.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);

    return hsv.z * mix(vec3(1.0), rgb, hsv.y);
}
`;



---
File: /src/shaders/modules/hsv/hsv2rgbSmooth.glsl.js
---

// Based on https://github.com/yuichiroharai/glsl-y-hsv

export default /* glsl */ `
vec3 hsv2rgbSmooth(vec3 hsv) {
    vec3 rgb = clamp(abs(mod(hsv.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);

    rgb = rgb * rgb * (3.0 - 2.0 * rgb); // Cubic smoothing

    return hsv.z * mix(vec3(1.0), rgb, hsv.y);
}
`;



---
File: /src/shaders/modules/hsv/lerpHSV.glsl.js
---

// Based on https://github.com/yuichiroharai/glsl-y-hsv

export default /* glsl */ `
vec3 lerpHSV(vec3 hsv1, vec3 hsv2, float rate) {
    float hue = (mod(mod((hsv2.x - hsv1.x), 1.0) + 1.5, 1.0) - 0.5) * rate + hsv1.x;

    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));
}
`;



---
File: /src/shaders/modules/hsv/rgb2hsv.glsl.js
---

// From http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl by sam

export default /* glsl */ `
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;

    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
`;



---
File: /src/shaders/modules/lensflare/lensflare.glsl.js
---

// Based on https://www.shadertoy.com/view/4sX3Rs by mu6k

export default /* glsl */ `
vec3 lensflare(vec2 uv, vec2 pos) {
    vec2 uvd = uv * length(uv);

    float f21 = max(1.0 / (1.0 + 32.0 * pow(length(uvd + 0.8 * pos), 2.0)), 0.0) * 0.25;
    float f22 = max(1.0 / (1.0 + 32.0 * pow(length(uvd + 0.85 * pos), 2.0)), 0.0) * 0.23;
    float f23 = max(1.0 / (1.0 + 32.0 * pow(length(uvd + 0.9 * pos), 2.0)), 0.0) * 0.21;

    vec2 uvx = mix(uv, uvd, -0.5);
    float f41 = max(0.01 - pow(length(uvx + 0.4 * pos), 2.4), 0.0) * 6.0;
    float f42 = max(0.01 - pow(length(uvx + 0.45 * pos), 2.4), 0.0) * 5.0;
    float f43 = max(0.01 - pow(length(uvx + 0.5 * pos), 2.4), 0.0) * 3.0;

    uvx = mix(uv, uvd, -0.4);
    float f51 = max(0.01 - pow(length(uvx + 0.2 * pos), 5.5), 0.0) * 2.0;
    float f52 = max(0.01 - pow(length(uvx + 0.4 * pos), 5.5), 0.0) * 2.0;
    float f53 = max(0.01 - pow(length(uvx + 0.6 * pos), 5.5), 0.0) * 2.0;

    uvx = mix(uv, uvd, -0.5);
    float f61 = max(0.01 - pow(length(uvx - 0.3 * pos), 1.6), 0.0) * 6.0;
    float f62 = max(0.01 - pow(length(uvx - 0.325 * pos), 1.6), 0.0) * 3.0;
    float f63 = max(0.01 - pow(length(uvx - 0.35 * pos), 1.6), 0.0) * 5.0;

    return vec3(f21 + f41 + f51 + f61, f22 + f42 + f52 + f62, f23 + f43 + f53 + f63);
}
`;



---
File: /src/shaders/modules/levels/levels.glsl.js
---

// From https://gist.github.com/activetheory/b68c2d639e2bd272b2a7

export default /* glsl */ `
float levelChannel(float inPixel, float inBlack, float inGamma, float inWhite, float outBlack, float outWhite) {
    return (pow(((inPixel * 255.0) - inBlack) / (inWhite - inBlack), inGamma) * (outWhite - outBlack) + outBlack) / 255.0;
}

vec3 levels(vec3 inPixel, float inBlack, float inGamma, float inWhite, float outBlack, float outWhite) {
    vec3 o = vec3(1.0);
    o.r = levelChannel(inPixel.r, inBlack, inGamma, inWhite, outBlack, outWhite);
    o.g = levelChannel(inPixel.g, inBlack, inGamma, inWhite, outBlack, outWhite);
    o.b = levelChannel(inPixel.b, inBlack, inGamma, inWhite, outBlack, outWhite);
    return o;
}
`;



---
File: /src/shaders/modules/map/map.glsl.js
---

// From https://github.com/msfeldstein/glsl-map

export default /* glsl */ `
float map(float value, float inMin, float inMax, float outMin, float outMax) {
  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

vec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {
  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

vec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {
  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

vec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {
  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}
`;



---
File: /src/shaders/modules/noise/blue-noise.glsl.js
---

export default /* glsl */ `
float getBlueNoise(sampler2D tex, vec2 coord, vec2 resolution, vec2 offset) {
    return texture(tex, coord / resolution + offset).r;
}

float getBlueNoise(sampler2D tex, vec2 coord, vec2 resolution) {
    return getBlueNoise(tex, coord, resolution, vec2(0));
}

float getBlueNoise(sampler2D tex, float t, vec2 resolution) {
    return getBlueNoise(tex, vec2(t, 0.0), resolution, vec2(0));
}
`;



---
File: /src/shaders/modules/noise/classic2d.glsl.js
---

// From https://github.com/hughsk/glsl-noise

export default /* glsl */ `
//
// GLSL textureless classic 2D noise "cnoise",
// with an RSL-style periodic variant "pnoise".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/ashima/webgl-noise
//

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec2 fade(vec2 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise
float cnoise(vec2 P)
{
  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
  Pi = mod289(Pi); // To avoid truncation effects in permutation
  vec4 ix = Pi.xzxz;
  vec4 iy = Pi.yyww;
  vec4 fx = Pf.xzxz;
  vec4 fy = Pf.yyww;

  vec4 i = permute(permute(ix) + iy);

  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
  vec4 gy = abs(gx) - 0.5 ;
  vec4 tx = floor(gx + 0.5);
  gx = gx - tx;

  vec2 g00 = vec2(gx.x,gy.x);
  vec2 g10 = vec2(gx.y,gy.y);
  vec2 g01 = vec2(gx.z,gy.z);
  vec2 g11 = vec2(gx.w,gy.w);

  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;

  float n00 = dot(g00, vec2(fx.x, fy.x));
  float n10 = dot(g10, vec2(fx.y, fy.y));
  float n01 = dot(g01, vec2(fx.z, fy.z));
  float n11 = dot(g11, vec2(fx.w, fy.w));

  vec2 fade_xy = fade(Pf.xy);
  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}
`;



---
File: /src/shaders/modules/noise/classic3d.glsl.js
---

// From https://github.com/hughsk/glsl-noise

export default /* glsl */ `
//
// GLSL textureless classic 3D noise "cnoise",
// with an RSL-style periodic variant "pnoise".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/ashima/webgl-noise
//

vec3 mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise
float cnoise(vec3 P)
{
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}
`;



---
File: /src/shaders/modules/noise/classic4d.glsl.js
---

// From https://github.com/hughsk/glsl-noise

export default /* glsl */ `
//
// GLSL textureless classic 4D noise "cnoise",
// with an RSL-style periodic variant "pnoise".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/ashima/webgl-noise
//

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 fade(vec4 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise
float cnoise(vec4 P)
{
  vec4 Pi0 = floor(P); // Integer part for indexing
  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec4 Pf0 = fract(P); // Fractional part for interpolation
  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = vec4(Pi0.zzzz);
  vec4 iz1 = vec4(Pi1.zzzz);
  vec4 iw0 = vec4(Pi0.wwww);
  vec4 iw1 = vec4(Pi1.wwww);

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);
  vec4 ixy00 = permute(ixy0 + iw0);
  vec4 ixy01 = permute(ixy0 + iw1);
  vec4 ixy10 = permute(ixy1 + iw0);
  vec4 ixy11 = permute(ixy1 + iw1);

  vec4 gx00 = ixy00 * (1.0 / 7.0);
  vec4 gy00 = floor(gx00) * (1.0 / 7.0);
  vec4 gz00 = floor(gy00) * (1.0 / 6.0);
  gx00 = fract(gx00) - 0.5;
  gy00 = fract(gy00) - 0.5;
  gz00 = fract(gz00) - 0.5;
  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  vec4 sw00 = step(gw00, vec4(0.0));
  gx00 -= sw00 * (step(0.0, gx00) - 0.5);
  gy00 -= sw00 * (step(0.0, gy00) - 0.5);

  vec4 gx01 = ixy01 * (1.0 / 7.0);
  vec4 gy01 = floor(gx01) * (1.0 / 7.0);
  vec4 gz01 = floor(gy01) * (1.0 / 6.0);
  gx01 = fract(gx01) - 0.5;
  gy01 = fract(gy01) - 0.5;
  gz01 = fract(gz01) - 0.5;
  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  vec4 sw01 = step(gw01, vec4(0.0));
  gx01 -= sw01 * (step(0.0, gx01) - 0.5);
  gy01 -= sw01 * (step(0.0, gy01) - 0.5);

  vec4 gx10 = ixy10 * (1.0 / 7.0);
  vec4 gy10 = floor(gx10) * (1.0 / 7.0);
  vec4 gz10 = floor(gy10) * (1.0 / 6.0);
  gx10 = fract(gx10) - 0.5;
  gy10 = fract(gy10) - 0.5;
  gz10 = fract(gz10) - 0.5;
  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  vec4 sw10 = step(gw10, vec4(0.0));
  gx10 -= sw10 * (step(0.0, gx10) - 0.5);
  gy10 -= sw10 * (step(0.0, gy10) - 0.5);

  vec4 gx11 = ixy11 * (1.0 / 7.0);
  vec4 gy11 = floor(gx11) * (1.0 / 7.0);
  vec4 gz11 = floor(gy11) * (1.0 / 6.0);
  gx11 = fract(gx11) - 0.5;
  gy11 = fract(gy11) - 0.5;
  gz11 = fract(gz11) - 0.5;
  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  vec4 sw11 = step(gw11, vec4(0.0));
  gx11 -= sw11 * (step(0.0, gx11) - 0.5);
  gy11 -= sw11 * (step(0.0, gy11) - 0.5);

  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);

  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  g0000 *= norm00.x;
  g0100 *= norm00.y;
  g1000 *= norm00.z;
  g1100 *= norm00.w;

  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  g0001 *= norm01.x;
  g0101 *= norm01.y;
  g1001 *= norm01.z;
  g1101 *= norm01.w;

  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  g0010 *= norm10.x;
  g0110 *= norm10.y;
  g1010 *= norm10.z;
  g1110 *= norm10.w;

  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
  g0011 *= norm11.x;
  g0111 *= norm11.y;
  g1011 *= norm11.z;
  g1111 *= norm11.w;

  float n0000 = dot(g0000, Pf0);
  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
  float n1111 = dot(g1111, Pf1);

  vec4 fade_xyzw = fade(Pf0);
  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return 2.2 * n_xyzw;
}
`;



---
File: /src/shaders/modules/noise/noise1d.glsl.js
---

// From https://www.shadertoy.com/view/4dS3Wd by morgan3d

export default /* glsl */ `
// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW
float hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }
float hash(vec2 p) { vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }

float noise(float x) {
    float i = floor(x);
    float f = fract(x);
    float u = f * f * (3.0 - 2.0 * f);
    return mix(hash(i), hash(i + 1.0), u);
}
`;



---
File: /src/shaders/modules/noise/noise2d.glsl.js
---

// From https://www.shadertoy.com/view/4dS3Wd by morgan3d

export default /* glsl */ `
// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW
float hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }
float hash(vec2 p) { vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }

float noise(vec2 x) {
    vec2 i = floor(x);
    vec2 f = fract(x);

    // Four corners in 2D of a tile
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}
`;



---
File: /src/shaders/modules/noise/noise3d.glsl.js
---

// From https://www.shadertoy.com/view/4dS3Wd by morgan3d

export default /* glsl */ `
// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW
float hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }
float hash(vec2 p) { vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }

float noise(vec3 x) {
    const vec3 step = vec3(110, 241, 171);

    vec3 i = floor(x);
    vec3 f = fract(x);

    // For performance, compute the base input to a 1D hash from the integer part of the argument and the
    // incremental change to the 1D based on the 3D -> 1D wrapping
    float n = dot(i, step);

    vec3 u = f * f * (3.0 - 2.0 * f);
    return mix(mix(mix(hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),
                   mix(hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
               mix(mix(hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),
                   mix(hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
}
`;



---
File: /src/shaders/modules/noise/periodic2d.glsl.js
---

// From https://github.com/hughsk/glsl-noise

export default /* glsl */ `
//
// GLSL textureless classic 2D noise "cnoise",
// with an RSL-style periodic variant "pnoise".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/ashima/webgl-noise
//

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec2 fade(vec2 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise, periodic variant
float pnoise(vec2 P, vec2 rep)
{
  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period
  Pi = mod289(Pi);        // To avoid truncation effects in permutation
  vec4 ix = Pi.xzxz;
  vec4 iy = Pi.yyww;
  vec4 fx = Pf.xzxz;
  vec4 fy = Pf.yyww;

  vec4 i = permute(permute(ix) + iy);

  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
  vec4 gy = abs(gx) - 0.5 ;
  vec4 tx = floor(gx + 0.5);
  gx = gx - tx;

  vec2 g00 = vec2(gx.x,gy.x);
  vec2 g10 = vec2(gx.y,gy.y);
  vec2 g01 = vec2(gx.z,gy.z);
  vec2 g11 = vec2(gx.w,gy.w);

  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;

  float n00 = dot(g00, vec2(fx.x, fy.x));
  float n10 = dot(g10, vec2(fx.y, fy.y));
  float n01 = dot(g01, vec2(fx.z, fy.z));
  float n11 = dot(g11, vec2(fx.w, fy.w));

  vec2 fade_xy = fade(Pf.xy);
  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}
`;



---
File: /src/shaders/modules/noise/periodic3d.glsl.js
---

// From https://github.com/hughsk/glsl-noise

export default /* glsl */ `
//
// GLSL textureless classic 3D noise "cnoise",
// with an RSL-style periodic variant "pnoise".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/ashima/webgl-noise
//

vec3 mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise, periodic variant
float pnoise(vec3 P, vec3 rep)
{
  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}
`;



---
File: /src/shaders/modules/noise/periodic4d.glsl.js
---

// From https://github.com/hughsk/glsl-noise

export default /* glsl */ `
//
// GLSL textureless classic 4D noise "cnoise",
// with an RSL-style periodic variant "pnoise".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/ashima/webgl-noise
//

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 fade(vec4 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise, periodic version
float pnoise(vec4 P, vec4 rep)
{
  vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep
  vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec4 Pf0 = fract(P); // Fractional part for interpolation
  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = vec4(Pi0.zzzz);
  vec4 iz1 = vec4(Pi1.zzzz);
  vec4 iw0 = vec4(Pi0.wwww);
  vec4 iw1 = vec4(Pi1.wwww);

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);
  vec4 ixy00 = permute(ixy0 + iw0);
  vec4 ixy01 = permute(ixy0 + iw1);
  vec4 ixy10 = permute(ixy1 + iw0);
  vec4 ixy11 = permute(ixy1 + iw1);

  vec4 gx00 = ixy00 * (1.0 / 7.0);
  vec4 gy00 = floor(gx00) * (1.0 / 7.0);
  vec4 gz00 = floor(gy00) * (1.0 / 6.0);
  gx00 = fract(gx00) - 0.5;
  gy00 = fract(gy00) - 0.5;
  gz00 = fract(gz00) - 0.5;
  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  vec4 sw00 = step(gw00, vec4(0.0));
  gx00 -= sw00 * (step(0.0, gx00) - 0.5);
  gy00 -= sw00 * (step(0.0, gy00) - 0.5);

  vec4 gx01 = ixy01 * (1.0 / 7.0);
  vec4 gy01 = floor(gx01) * (1.0 / 7.0);
  vec4 gz01 = floor(gy01) * (1.0 / 6.0);
  gx01 = fract(gx01) - 0.5;
  gy01 = fract(gy01) - 0.5;
  gz01 = fract(gz01) - 0.5;
  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  vec4 sw01 = step(gw01, vec4(0.0));
  gx01 -= sw01 * (step(0.0, gx01) - 0.5);
  gy01 -= sw01 * (step(0.0, gy01) - 0.5);

  vec4 gx10 = ixy10 * (1.0 / 7.0);
  vec4 gy10 = floor(gx10) * (1.0 / 7.0);
  vec4 gz10 = floor(gy10) * (1.0 / 6.0);
  gx10 = fract(gx10) - 0.5;
  gy10 = fract(gy10) - 0.5;
  gz10 = fract(gz10) - 0.5;
  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  vec4 sw10 = step(gw10, vec4(0.0));
  gx10 -= sw10 * (step(0.0, gx10) - 0.5);
  gy10 -= sw10 * (step(0.0, gy10) - 0.5);

  vec4 gx11 = ixy11 * (1.0 / 7.0);
  vec4 gy11 = floor(gx11) * (1.0 / 7.0);
  vec4 gz11 = floor(gy11) * (1.0 / 6.0);
  gx11 = fract(gx11) - 0.5;
  gy11 = fract(gy11) - 0.5;
  gz11 = fract(gz11) - 0.5;
  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  vec4 sw11 = step(gw11, vec4(0.0));
  gx11 -= sw11 * (step(0.0, gx11) - 0.5);
  gy11 -= sw11 * (step(0.0, gy11) - 0.5);

  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);

  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  g0000 *= norm00.x;
  g0100 *= norm00.y;
  g1000 *= norm00.z;
  g1100 *= norm00.w;

  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  g0001 *= norm01.x;
  g0101 *= norm01.y;
  g1001 *= norm01.z;
  g1101 *= norm01.w;

  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  g0010 *= norm10.x;
  g0110 *= norm10.y;
  g1010 *= norm10.z;
  g1110 *= norm10.w;

  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
  g0011 *= norm11.x;
  g0111 *= norm11.y;
  g1011 *= norm11.z;
  g1111 *= norm11.w;

  float n0000 = dot(g0000, Pf0);
  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
  float n1111 = dot(g1111, Pf1);

  vec4 fade_xyzw = fade(Pf0);
  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return 2.2 * n_xyzw;
}
`;



---
File: /src/shaders/modules/noise/simplex2d.glsl.js
---

// From https://github.com/hughsk/glsl-noise

export default /* glsl */ `
//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}
`;



---
File: /src/shaders/modules/noise/simplex3d.glsl.js
---

// From https://github.com/hughsk/glsl-noise

export default /* glsl */ `
//
// Description : Array and textureless GLSL 2D/3D/4D simplex
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
     return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(vec3 v)
  {
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
  //   x1 = x0 - i1  + 1.0 * C.xxx;
  //   x2 = x0 - i2  + 2.0 * C.xxx;
  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

// Permutations
  i = mod289(i);
  vec4 p = permute( permute( permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

// Gradients: 7x7 points over a square, mapped onto an octahedron.
// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857; // 1.0/7.0
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

//Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) );
  }
`;



---
File: /src/shaders/modules/noise/simplex4d.glsl.js
---

// From https://github.com/hughsk/glsl-noise

export default /* glsl */ `
//
// Description : Array and textureless GLSL 2D/3D/4D simplex
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0; }

float mod289(float x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0; }

vec4 permute(vec4 x) {
     return mod289(((x*34.0)+1.0)*x);
}

float permute(float x) {
     return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float taylorInvSqrt(float r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 grad4(float j, vec4 ip)
  {
  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
  vec4 p,s;

  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
  s = vec4(lessThan(p, vec4(0.0)));
  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;

  return p;
  }

// (sqrt(5) - 1)/4 = F4, used once below
#define F4 0.309016994374947451

float snoise(vec4 v)
  {
  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4
                        0.276393202250021,  // 2 * G4
                        0.414589803375032,  // 3 * G4
                       -0.447213595499958); // -1 + 4 * G4

// First corner
  vec4 i  = floor(v + dot(v, vec4(F4)) );
  vec4 x0 = v -   i + dot(i, C.xxxx);

// Other corners

// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
  vec4 i0;
  vec3 isX = step( x0.yzw, x0.xxx );
  vec3 isYZ = step( x0.zww, x0.yyz );
//  i0.x = dot( isX, vec3( 1.0 ) );
  i0.x = isX.x + isX.y + isX.z;
  i0.yzw = 1.0 - isX;
//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
  i0.y += isYZ.x + isYZ.y;
  i0.zw += 1.0 - isYZ.xy;
  i0.z += isYZ.z;
  i0.w += 1.0 - isYZ.z;

  // i0 now contains the unique values 0,1,2,3 in each channel
  vec4 i3 = clamp( i0, 0.0, 1.0 );
  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

  //  x0 = x0 - 0.0 + 0.0 * C.xxxx
  //  x1 = x0 - i1  + 1.0 * C.xxxx
  //  x2 = x0 - i2  + 2.0 * C.xxxx
  //  x3 = x0 - i3  + 3.0 * C.xxxx
  //  x4 = x0 - 1.0 + 4.0 * C.xxxx
  vec4 x1 = x0 - i1 + C.xxxx;
  vec4 x2 = x0 - i2 + C.yyyy;
  vec4 x3 = x0 - i3 + C.zzzz;
  vec4 x4 = x0 + C.wwww;

// Permutations
  i = mod289(i);
  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
  vec4 j1 = permute( permute( permute( permute (
             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));

// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
// 7*7*6 = 294, which is close to the ring size 17*17 = 289.
  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

  vec4 p0 = grad4(j0,   ip);
  vec4 p1 = grad4(j1.x, ip);
  vec4 p2 = grad4(j1.y, ip);
  vec4 p3 = grad4(j1.z, ip);
  vec4 p4 = grad4(j1.w, ip);

// Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;
  p4 *= taylorInvSqrt(dot(p4,p4));

// Mix contributions from the five corners
  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
  m0 = m0 * m0;
  m1 = m1 * m1;
  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;

  }
`;



---
File: /src/shaders/modules/parabola/parabola.glsl.js
---

// From https://www.iquilezles.org/www/articles/functions/functions.htm

export default /* glsl */ `
float parabola(float x, float k) {
    return pow(4.0 * x * (1.0 - x), k);
}

float pcurve(float x, float a, float b) {
    float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));
    return k * pow(x, a) * pow(1.0 - x, b);
}
`;



---
File: /src/shaders/modules/random/random.glsl.js
---

// From https://github.com/mattdesl/glsl-random

export default /* glsl */ `
float random(vec2 co) {
    float a = 12.9898;
    float b = 78.233;
    float c = 43758.5453;
    float dt = dot(co.xy, vec2(a, b));
    float sn = mod(dt, 3.14);
    return fract(sin(sn) * c);
}
`;



---
File: /src/shaders/modules/rgbshift/rgbshift.glsl.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/RGBShiftShader.js by felixturner

export default /* glsl */ `
vec4 getRGB(sampler2D image, vec2 uv, float angle, float amount) {
    vec2 offset = vec2(cos(angle), sin(angle)) * amount;
    vec4 r = texture(image, uv + offset);
    vec4 g = texture(image, uv);
    vec4 b = texture(image, uv - offset);
    return vec4(r.r, g.g, b.b, g.a);
}
`;



---
File: /src/shaders/modules/smootherstep/smootherstep.glsl.js
---

// From https://www.shadertoy.com/view/MlyBWK by v_coda

export default /* glsl */ `
float smootherstep(float edge0, float edge1, float x) {
    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);
}
`;



---
File: /src/shaders/modules/transformUV/rotateUV.glsl.js
---

export default /* glsl */ `
vec2 rotateUV(vec2 uv, float rotation, vec2 mid) {
    return vec2(
        cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,
        cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y
    );
}

vec2 rotateUV(vec2 uv, float rotation, float mid) {
    return rotateUV(uv, rotation, vec2(mid));
}

vec2 rotateUV(vec2 uv, float rotation) {
    return rotateUV(uv, rotation, vec2(0.5));
}
`;



---
File: /src/shaders/modules/transformUV/scaleUV.glsl.js
---

export default /* glsl */ `
vec2 scaleUV(vec2 uv, float scale, vec2 mid) {
    uv -= mid;
    uv *= 1.0 / scale;
    uv += mid;
    return uv;
}

vec2 scaleUV(vec2 uv, float scale, float mid) {
    return scaleUV(uv, scale, vec2(mid));
}

vec2 scaleUV(vec2 uv, float scale) {
    return scaleUV(uv, scale, vec2(0.5));
}
`;



---
File: /src/shaders/ACESFilmicToneMappingShader.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/ACESFilmicToneMappingShader.js by WestLangley

import encodings from './modules/encodings/encodings.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uExposure;

in vec2 vUv;

out vec4 FragColor;

${encodings}

void main() {
    FragColor = texture(tMap, vUv);

    FragColor.rgb *= uExposure / 0.6; // Pre-exposed, outside of the tone mapping function

    FragColor = vec4(ACESFilmicToneMapping(FragColor.rgb), FragColor.a);
}
`;



---
File: /src/shaders/AfterimageShader.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/AfterimageShader.js by HypnosNova

import when_gt from './modules/conditionals/when_gt.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tOld;
uniform sampler2D tNew;
uniform float uDamping;

in vec2 vUv;

out vec4 FragColor;

${when_gt}

void main() {
    vec4 texelOld = texture(tOld, vUv);
    vec4 texelNew = texture(tNew, vUv);

    texelOld *= uDamping * when_gt(texelOld, vec4(0.1));

    FragColor = max(texelNew, texelOld);
}
`;



---
File: /src/shaders/BadTVShader.js
---

import badtv from './modules/badtv/badtv.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uDistortion;
uniform float uDistortion2;
uniform float uSpeed;
uniform float uRollSpeed;
uniform float uTime;

in vec2 vUv;

out vec4 FragColor;

${badtv}

void main() {
    FragColor = getBadTV(tMap, vUv, uTime, uDistortion, uDistortion2, uSpeed, uRollSpeed);
}
`;



---
File: /src/shaders/BasicLightingShader.js
---

export const vertexShader = /* glsl */ `
in vec3 position;
in vec3 normal;
in vec2 uv;

#ifdef USE_INSTANCING
    in mat4 instanceMatrix;
#endif

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

uniform mat3 uMapTransform;

out vec2 vUv;
out vec3 vNormal;

void main() {
    vUv = (uMapTransform * vec3(uv, 1.0)).xy;
    vNormal = normalize(normalMatrix * normal);

    vec4 mvPosition = vec4(position, 1.0);

    #ifdef USE_INSTANCING
        mvPosition = instanceMatrix * mvPosition;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * mvPosition;
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform vec3 uLightPosition;
uniform float uLightIntensity;
uniform float uAlpha;

in vec2 vUv;
in vec3 vNormal;

out vec4 FragColor;

void main() {
    vec3 normal = normalize(vNormal);

    vec3 light = normalize(uLightPosition);
    float shading = dot(normal, light) * uLightIntensity;

    FragColor = texture(tMap, vUv);
    FragColor.rgb += shading;
    FragColor.a *= uAlpha;
}
`;



---
File: /src/shaders/BasicShader.js
---

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

#ifdef USE_INSTANCING
    in mat4 instanceMatrix;
#endif

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

uniform mat3 uMapTransform;

out vec2 vUv;

void main() {
    vUv = (uMapTransform * vec3(uv, 1.0)).xy;

    vec4 mvPosition = vec4(position, 1.0);

    #ifdef USE_INSTANCING
        mvPosition = instanceMatrix * mvPosition;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * mvPosition;
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uAlpha;

in vec2 vUv;

out vec4 FragColor;

void main() {
    FragColor = texture(tMap, vUv);
    FragColor.a *= uAlpha;
}
`;



---
File: /src/shaders/BloomCompositeShader.js
---

import dither from './modules/dither/dither.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tBlur1;
uniform sampler2D tBlur2;
uniform sampler2D tBlur3;
uniform sampler2D tBlur4;
uniform sampler2D tBlur5;
uniform float uBloomFactors[NUM_MIPS];

in vec2 vUv;

out vec4 FragColor;

${dither}

void main() {
    FragColor = uBloomFactors[0] * texture(tBlur1, vUv) +
                uBloomFactors[1] * texture(tBlur2, vUv) +
                uBloomFactors[2] * texture(tBlur3, vUv) +
                uBloomFactors[3] * texture(tBlur4, vUv) +
                uBloomFactors[4] * texture(tBlur5, vUv);

    #ifdef DITHERING
        FragColor.rgb = dither(FragColor.rgb);
    #endif

    FragColor.a = 1.0;
}
`;



---
File: /src/shaders/BlurShader.js
---

import blur from './modules/blur/blur.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uBlurAmount;
uniform vec2 uDirection;
uniform vec2 uResolution;

in vec2 vUv;

out vec4 FragColor;

${blur}

void main() {
    FragColor = blur(tMap, vUv, uResolution, uBlurAmount * uDirection);
}
`;



---
File: /src/shaders/BokehBlurShader1.js
---

// Based on https://www.shadertoy.com/view/4lVfDt by battlebottle

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

#define PI          3.14
#define TWO_PI      6.28
#define MAX_SAMPLES 28.0

uniform sampler2D tMap;
uniform float uScale;
uniform vec2 uResolution;

in vec2 vUv;

out vec4 FragColor;

const float blurRadMax = 0.08;
const float blurCircles = 4.0;

void main() {
    float blurRadius = blurRadMax * uScale;

    float totalSamples = 0.0;
    vec3 colAcum = vec3(0.0);

    for (float currentCircle = 0.0; currentCircle < blurCircles; currentCircle++) {
        float samplesForCurrentCircle = (pow(currentCircle + 1.0, 2.0) - pow(currentCircle, 2.0)) * 4.0;
        float currentRadius = (blurRadius / blurCircles) * (currentCircle + 0.5);

        for (float currentSample = 0.0; currentSample < MAX_SAMPLES; currentSample++) {
            if (currentSample >= samplesForCurrentCircle) break;

            vec2 samplePoint = vec2(0.0, currentRadius);
            float angle = TWO_PI * ((currentSample + 0.5) / samplesForCurrentCircle);

            float s = sin(angle);
            float c = cos(angle);
            mat2 m = mat2(c, -s, s, c);
            samplePoint = m * samplePoint;

            samplePoint *= vec2(uResolution.y / uResolution.x, 1.0);

            totalSamples++;
            colAcum += texture(tMap, vUv + samplePoint, blurRadius * 30.0).rgb;
        }
    }

    FragColor = vec4(colAcum / totalSamples, 1.0);
}
`;



---
File: /src/shaders/BokehBlurShader2.js
---

// Based on https://www.shadertoy.com/view/4lVfDt by battlebottle

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

#define PI          3.14
#define TWO_PI      6.28
#define MAX_SAMPLES 20.0

uniform sampler2D tMap;
uniform float uScale;
uniform vec2 uResolution;

in vec2 vUv;

out vec4 FragColor;

const float blurRadMax = 0.08;
const float blurCircles = 3.0;

void main() {
    float blurRadius = blurRadMax * uScale * 0.3;

    float totalSamples = 0.0;
    vec3 colAcum = vec3(0.0);

    for (float currentCircle = 0.0; currentCircle < blurCircles; currentCircle++) {
        float samplesForCurrentCircle = (pow(currentCircle + 1.0, 2.0) - pow(currentCircle, 2.0)) * 4.0;
        float currentRadius = (blurRadius / blurCircles) * (currentCircle + 0.5);

        for (float currentSample = 0.0; currentSample < MAX_SAMPLES; currentSample++) {
            if (currentSample >= samplesForCurrentCircle) break;

            vec2 samplePoint = vec2(0.0, currentRadius);
            float angle = TWO_PI * ((currentSample + 0.5) / samplesForCurrentCircle);

            float s = sin(angle);
            float c = cos(angle);
            mat2 m = mat2(c, -s, s, c);
            samplePoint = m * samplePoint;

            samplePoint *= vec2(uResolution.y / uResolution.x, 1.0);

            totalSamples++;
            colAcum = max(colAcum, texture(tMap, vUv + samplePoint).rgb);
        }
    }

    FragColor = vec4(colAcum, 1.0);
}
`;



---
File: /src/shaders/ChromaticAberrationShader.js
---

// Based on https://www.shadertoy.com/view/ltKBDd by battlebottle

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uRedOffset;
uniform float uGreenOffset;
uniform float uBlueOffset;
uniform float uIntensity;

in vec2 vUv;

out vec4 FragColor;

void main() {
    float ro = 0.001 * uRedOffset * uIntensity;
    float go = 0.001 * uGreenOffset * uIntensity;
    float bo = 0.001 * uBlueOffset * uIntensity;

    float r = texture(tMap, vUv * (1.0 + ro) - (ro / 2.0)).r;
    float g = texture(tMap, vUv * (1.0 + go) - (go / 2.0)).g;
    float b = texture(tMap, vUv * (1.0 + bo) - (bo / 2.0)).b;

    FragColor = vec4(r, g, b, 1.0);
}
`;



---
File: /src/shaders/ColorLightingShader.js
---

export const vertexShader = /* glsl */ `
in vec3 position;
in vec3 normal;

#ifdef USE_INSTANCING
    in mat4 instanceMatrix;
#endif

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

out vec3 vNormal;

void main() {
    vNormal = normalize(normalMatrix * normal);

    vec4 mvPosition = vec4(position, 1.0);

    #ifdef USE_INSTANCING
        mvPosition = instanceMatrix * mvPosition;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * mvPosition;
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform vec3 uColor;
uniform vec3 uLightPosition;
uniform float uLightIntensity;
uniform float uAlpha;

in vec3 vNormal;

out vec4 FragColor;

void main() {
    vec3 normal = normalize(vNormal);

    vec3 light = normalize(uLightPosition);
    float shading = dot(normal, light) * uLightIntensity;

    FragColor = vec4(uColor + shading, uAlpha);
}
`;



---
File: /src/shaders/ColorShader.js
---

export const vertexShader = /* glsl */ `
in vec3 position;

#ifdef USE_INSTANCING
    in mat4 instanceMatrix;
#endif

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

void main() {
    vec4 mvPosition = vec4(position, 1.0);

    #ifdef USE_INSTANCING
        mvPosition = instanceMatrix * mvPosition;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * mvPosition;
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform vec3 uColor;
uniform float uAlpha;

out vec4 FragColor;

void main() {
    FragColor = vec4(uColor, uAlpha);
}
`;



---
File: /src/shaders/CopyShader.js
---

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;

in vec2 vUv;

out vec4 FragColor;

void main() {
    FragColor = texture(tMap, vUv);
}
`;



---
File: /src/shaders/DatamoshShader.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/AfterimageShader.js by HypnosNova
// Based on https://ompuco.wordpress.com/2018/03/29/creating-your-own-datamosh-effect/
// Based on https://www.youtube.com/watch?v=Uapad3pVxBY by Jam2go

import random from './modules/random/random.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tOld;
uniform sampler2D tNew;
uniform sampler2D tVelocity;
uniform float uAmount;
uniform float uLossy;
uniform float uDamping;
uniform vec2 uResolution;
uniform float uTime;
uniform int uFrame;

in vec2 vUv;

out vec4 FragColor;

${random}

void main() {
    if (uFrame < 10) {
        FragColor = texture(tNew, vUv);
        return;
    }

    vec2 blockUv = round(vUv * 32.0) / 32.0;

    // Noise float per UV block, changes over time
    float rnd = random(vec2(uTime, blockUv.x + blockUv.y * uResolution.x));

    vec2 vel = texture(tVelocity, mix(vUv, blockUv, uLossy)).xy;

    // Randomize motion vector
    vel = mix(vel, max(abs(vel) - round(rnd / 1.4), 0.0) * sign(vel), uLossy);

    vec2 motionUv = vUv - vel;

    vec4 color = mix(
        texture(tNew, vUv),
        texture(tOld, motionUv),
        mix(round(1.0 - rnd / 1.4) * uLossy, 1.0, uDamping) * uAmount
    );

    FragColor = color;
}
`;



---
File: /src/shaders/DepthMaskShader.js
---

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform sampler2D tDepth1;
uniform sampler2D tDepth2;

in vec2 vUv;

out vec4 FragColor;

void main() {
    float d1 = texture(tDepth1, vUv).r;
    float d2 = texture(tDepth2, vUv).r;

    if (d1 < d2) {
        discard;
    }

    FragColor = texture(tMap, vUv);
}
`;



---
File: /src/shaders/DepthShader.js
---

import dither from './modules/dither/dither.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;

#ifdef USE_INSTANCING
    in mat4 instanceMatrix;
#endif

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

void main() {
    vec4 mvPosition = vec4(position, 1.0);

    #ifdef USE_INSTANCING
        mvPosition = instanceMatrix * mvPosition;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * mvPosition;
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

out vec4 FragColor;

${dither}

void main() {
    FragColor = vec4(vec3(gl_FragCoord.w), 1.0);

    #ifdef DITHERING
        FragColor.rgb = dither(FragColor.rgb);
    #endif

    FragColor.a = 1.0;
}
`;



---
File: /src/shaders/DiscardShader.js
---

// Based on https://github.com/pmndrs/drei/blob/master/src/materials/DiscardMaterial.tsx

export const vertexShader = /* glsl */ `
in vec3 position;

#ifdef USE_INSTANCING
    in mat4 instanceMatrix;
#endif

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

void main() {
    vec4 mvPosition = vec4(position, 1.0);

    #ifdef USE_INSTANCING
        mvPosition = instanceMatrix * mvPosition;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * mvPosition;
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

out vec4 FragColor;

void main() {
    FragColor = vec4(0);
    discard;
}
`;



---
File: /src/shaders/DrawBuffersShader.js
---

// Based on https://threejs.org/examples/#webgl_multiple_rendertargets by takahirox
// Based on https://oframe.github.io/ogl/examples/?src=mrt.html by gordonnl
// Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/motionBlurPass
// Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/shader-replacement

export const vertexShader = /* glsl */ `
in vec3 position;
in vec3 normal;

#ifdef USE_INSTANCING
    in mat4 instanceMatrix;
    in mat4 instancePrevMatrix;
#endif

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

uniform mat4 uPrevModelViewMatrix;
uniform mat4 uPrevProjectionMatrix;
uniform float uInterpolateGeometry;

out vec3 vWorldPosition;
out vec4 vPrevPosition;
out vec4 vNewPosition;

void main() {
    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;

    // Outputs the position of the current and last frame positions
    vNewPosition = vec4(position, 1.0);
    vPrevPosition = vec4(position, 1.0);

    #ifdef USE_INSTANCING
        vNewPosition = instanceMatrix * vNewPosition;
        vPrevPosition = instancePrevMatrix * vPrevPosition;
    #endif

    vNewPosition = projectionMatrix * modelViewMatrix * vNewPosition;
    vPrevPosition = uPrevProjectionMatrix * uPrevModelViewMatrix * vPrevPosition;

    // The delta between frames
    vec3 delta = vNewPosition.xyz - vPrevPosition.xyz;
    vec3 direction = normalize(delta);

    // Stretch along the velocity axes
    vec3 transformedNormal = normalMatrix * normal;
    float stretchDot = dot(direction, transformedNormal);

    gl_Position = mix(vNewPosition, vPrevPosition, uInterpolateGeometry * (1.0 - step(0.0, stretchDot)));
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform float uSmearIntensity;

in vec3 vWorldPosition;
in vec4 vPrevPosition;
in vec4 vNewPosition;

layout(location = 0) out vec4 gPosition;
layout(location = 1) out vec4 gVelocity;

void main() {
    // Write world positions and depth to G-Buffer
    gPosition = vec4(vWorldPosition, gl_FragCoord.z);

    // Write velocities in screen UV space to G-Buffer
    vec3 pos0 = vPrevPosition.xyz / vPrevPosition.w;
    pos0 += 1.0;
    pos0 /= 2.0;

    vec3 pos1 = vNewPosition.xyz / vNewPosition.w;
    pos1 += 1.0;
    pos1 /= 2.0;

    vec3 vel = pos1 - pos0;
    gVelocity = vec4(vel * uSmearIntensity, 1.0);
}
`;



---
File: /src/shaders/FastGaussianBlurShader.js
---

import blur13 from './modules/blur/blur13.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform vec2 uDirection;
uniform vec2 uResolution;

in vec2 vUv;

out vec4 FragColor;

${blur13}

void main() {
    FragColor = blur13(tMap, vUv, uResolution, uDirection);
}
`;



---
File: /src/shaders/FresnelShader.js
---

export const vertexShader = /* glsl */ `
in vec3 position;
in vec3 normal;

#ifdef USE_INSTANCING
    in mat4 instanceMatrix;
#endif

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform vec3 cameraPosition;

out vec3 vWorldNormal;
out vec3 vViewDirection;

void main() {
    vWorldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
    vViewDirection = normalize(cameraPosition - (modelMatrix * vec4(position, 1.0)).xyz);

    vec4 mvPosition = vec4(position, 1.0);

    #ifdef USE_INSTANCING
        mvPosition = instanceMatrix * mvPosition;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * mvPosition;
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform vec3 uBaseColor;
uniform vec3 uFresnelColor;
uniform float uFresnelPower;

in vec3 vWorldNormal;
in vec3 vViewDirection;

out vec4 FragColor;

void main() {
    float fresnelFactor = abs(dot(vViewDirection, vWorldNormal));
    float inversefresnelFactor = 1.0 - fresnelFactor;

    // Shaping function
    fresnelFactor = pow(fresnelFactor, uFresnelPower);
    inversefresnelFactor = pow(inversefresnelFactor, uFresnelPower);

    FragColor = vec4(fresnelFactor * uBaseColor + inversefresnelFactor * uFresnelColor, 1.0);
}
`;



---
File: /src/shaders/FXAAShader.js
---

// Based on https://github.com/mattdesl/glsl-fxaa

import fxaa from './modules/fxaa/fxaa.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

uniform vec2 uResolution;

out vec2 vUv;
out vec2 v_rgbNW;
out vec2 v_rgbNE;
out vec2 v_rgbSW;
out vec2 v_rgbSE;
out vec2 v_rgbM;

void main() {
    vUv = uv;

    vec2 fragCoord = uv * uResolution;
    vec2 inverseVP = 1.0 / uResolution.xy;
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform vec2 uResolution;

in vec2 vUv;
in vec2 v_rgbNW;
in vec2 v_rgbNE;
in vec2 v_rgbSW;
in vec2 v_rgbSE;
in vec2 v_rgbM;

out vec4 FragColor;

${fxaa}

void main() {
    FragColor = fxaa(tMap, vUv * uResolution, uResolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;



---
File: /src/shaders/GammaCorrectionShader.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/GammaCorrectionShader.js by WestLangley

import encodings from './modules/encodings/encodings.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;

in vec2 vUv;

out vec4 FragColor;

${encodings}

void main() {
    FragColor = texture(tMap, vUv);

    FragColor = vec4(linearToSRGB(FragColor.rgb), FragColor.a);
}
`;



---
File: /src/shaders/LensflareShader.js
---

// Based on https://www.shadertoy.com/view/4sX3Rs by mu6k
// Based on https://www.shadertoy.com/view/wlcyzj by TheNosiriN

import lensflare from './modules/lensflare/lensflare.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform vec2 uLightPosition;
uniform vec2 uScale;
uniform float uExposure;
uniform float uClamp;
uniform vec2 uResolution;

in vec2 vUv;

out vec4 FragColor;

${lensflare}

void main() {
    vec2 uv = vUv - 0.5;
    vec2 pos = uLightPosition - 0.5;

    uv.x *= uResolution.x / uResolution.y;
    pos.x *= uResolution.x / uResolution.y;

    uv *= uScale;
    pos *= uScale;

    vec3 color = lensflare(uv, pos) * texture(tMap, uLightPosition).rgb * 2.0;
    color = pow(color, vec3(0.5));
    color *= uExposure;
    color = clamp(color, 0.0, uClamp);

    FragColor = vec4(color, 1.0);
}
`;



---
File: /src/shaders/LuminosityShader.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/LuminosityHighPassShader.js by bhouston

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uThreshold;
uniform float uSmoothing;

in vec2 vUv;

out vec4 FragColor;

void main() {
    vec4 texel = texture(tMap, vUv);
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float v = dot(texel.xyz, luma);
    float alpha = smoothstep(uThreshold, uThreshold + uSmoothing, v);

    FragColor = mix(vec4(0), texel, alpha);
}
`;



---
File: /src/shaders/MaskShader.js
---

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform sampler2D tMask;

in vec2 vUv;

out vec4 FragColor;

void main() {
    float mask = texture(tMask, vUv).g;

    FragColor = texture(tMap, vUv);
    FragColor.a = mask;
}
`;



---
File: /src/shaders/MotionBlurCompositeShader.js
---

// Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/motionBlurPass
// Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/shader-replacement

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform sampler2D tVelocity;
uniform sampler2D tBlueNoise;
uniform vec2 uBlueNoiseResolution;

in vec2 vUv;

out vec4 FragColor;

void main() {
    vec2 vel = texture(tVelocity, vUv).xy;

    float jitterValue = texture(tBlueNoise, gl_FragCoord.xy / uBlueNoiseResolution).r;
    vec2 jitterOffset = vel * vec2(jitterValue) / float(SAMPLES);

    vec4 result;

    vec2 startUv = clamp(vUv - vel * 0.5 + jitterOffset, 0.0, 1.0);
    vec2 endUv = clamp(vUv + vel * 0.5 + jitterOffset, 0.0, 1.0);

    for (int i = 0; i < SAMPLES; i++) {
        vec2 sampleUv = mix(startUv, endUv, float(i) / float(SAMPLES));
        result += texture(tMap, sampleUv);
    }

    result /= float(SAMPLES);

    FragColor = result;
}
`;



---
File: /src/shaders/MotionBlurVelocityShader.js
---

// Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/motionBlurPass
// Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/shader-replacement

export const vertexShader = /* glsl */ `
in vec3 position;
in vec3 normal;

#ifdef USE_INSTANCING
    in mat4 instanceMatrix;
    in mat4 instancePrevMatrix;
#endif

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

uniform mat4 uPrevModelViewMatrix;
uniform mat4 uPrevProjectionMatrix;
uniform float uInterpolateGeometry;

out vec4 vPrevPosition;
out vec4 vNewPosition;

void main() {
    // Outputs the position of the current and last frame positions
    vNewPosition = vec4(position, 1.0);
    vPrevPosition = vec4(position, 1.0);

    #ifdef USE_INSTANCING
        vNewPosition = instanceMatrix * vNewPosition;
        vPrevPosition = instancePrevMatrix * vPrevPosition;
    #endif

    vNewPosition = projectionMatrix * modelViewMatrix * vNewPosition;
    vPrevPosition = uPrevProjectionMatrix * uPrevModelViewMatrix * vPrevPosition;

    // The delta between frames
    vec3 delta = vNewPosition.xyz - vPrevPosition.xyz;
    vec3 direction = normalize(delta);

    // Stretch along the velocity axes
    vec3 transformedNormal = normalMatrix * normal;
    float stretchDot = dot(direction, transformedNormal);

    gl_Position = mix(vNewPosition, vPrevPosition, uInterpolateGeometry * (1.0 - step(0.0, stretchDot)));
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform float uSmearIntensity;

in vec4 vPrevPosition;
in vec4 vNewPosition;

out vec4 FragColor;

void main() {
    // Compute velocities in screen UV space
    vec3 pos0 = vPrevPosition.xyz / vPrevPosition.w;
    pos0 += 1.0;
    pos0 /= 2.0;

    vec3 pos1 = vNewPosition.xyz / vNewPosition.w;
    pos1 += 1.0;
    pos1 /= 2.0;

    vec3 vel = pos1 - pos0;
    FragColor = vec4(vel * uSmearIntensity, 1.0);
}
`;



---
File: /src/shaders/NormalShader.js
---

export const vertexShader = /* glsl */ `
in vec3 position;
in vec3 normal;

#ifdef USE_INSTANCING
    in mat4 instanceMatrix;
#endif

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

out vec3 vNormal;

void main() {
    vNormal = normalize(normalMatrix * normal);

    vec4 mvPosition = vec4(position, 1.0);

    #ifdef USE_INSTANCING
        mvPosition = instanceMatrix * mvPosition;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * mvPosition;
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

in vec3 vNormal;

out vec4 FragColor;

void main() {
    FragColor = vec4(normalize(vNormal), 1.0);
}
`;



---
File: /src/shaders/PoissonDiscBlurShader.js
---

import blur from './modules/blur/poisson-disc-blur12.glsl.js';
import blueNoise from './modules/noise/blue-noise.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform sampler2D tBlueNoise;
uniform vec2 uBlueNoiseResolution;
uniform float uRadius;
uniform vec2 uResolution;
uniform float uTime;

in vec2 vUv;

out vec4 FragColor;

vec2 rot2d(vec2 p, float a) {
    vec2 sc = vec2(sin(a), cos(a));
    return vec2(dot(p, vec2(sc.y, -sc.x)), dot(p, sc.xy));
}

${blur}
${blueNoise}

void main() {
    float rnd = getBlueNoise(tBlueNoise, gl_FragCoord.xy, uBlueNoiseResolution, vec2(fract(uTime)));
    vec4 basis = vec4(rot2d(vec2(1, 0), rnd), rot2d(vec2(0, 1), rnd));

    FragColor = poissonSample(tMap, vUv, uResolution, uRadius, basis);
}
`;



---
File: /src/shaders/ReflectorBlurShader.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/HorizontalTiltShiftShader.js by alteredq
// Based on https://github.com/spite/codevember-2016

import smootherstep from './modules/smootherstep/smootherstep.glsl.js';
import blur13 from './modules/blur/blur13.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform vec2 uDirection;
uniform vec2 uResolution;

in vec2 vUv;

out vec4 FragColor;

${smootherstep}
${blur13}

void main() {
    FragColor = blur13(tMap, vUv, uResolution, smootherstep(1.0, 0.0, vUv.y) * uDirection);
}
`;



---
File: /src/shaders/ReflectorDudvShader.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/objects/Water2.js by Mugen87

import dither from './modules/dither/dither.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec3 normal;
in vec2 uv;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform mat3 uMapTransform;
uniform mat4 uMatrix;

out vec2 vUv;
out vec4 vCoord;
out vec3 vNormal;
out vec3 vToEye;

void main() {
    vUv = (uMapTransform * vec3(uv, 1.0)).xy;
    vCoord = uMatrix * vec4(position, 1.0);
    vNormal = normalMatrix * normal;
    vToEye = cameraPosition - (modelMatrix * vec4(position, 1.0)).xyz;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform sampler2D tReflect;
uniform sampler2D tReflectBlur;
uniform float uReflectivity;

in vec2 vUv;
in vec4 vCoord;
in vec3 vNormal;
in vec3 vToEye;

out vec4 FragColor;

${dither}

void main() {
    vec2 reflectionUv = vCoord.xy / vCoord.w;

    vec4 dudv = texture(tMap, vUv);
    vec4 color = texture(tReflect, reflectionUv);

    vec4 blur;

    blur = texture(tReflectBlur, reflectionUv + dudv.rg / 256.0);
    color = mix(color, blur, smoothstep(1.0, 0.1, dudv.g));

    blur = texture(tReflectBlur, reflectionUv);
    color = mix(color, blur, smoothstep(0.5, 1.0, dudv.r));

    FragColor = color * mix(0.6, 0.75, dudv.g);

    // Fresnel term
    vec3 toEye = normalize(vToEye);
    float theta = max(dot(toEye, vNormal), 0.0);
    float reflectance = uReflectivity + (1.0 - uReflectivity) * pow((1.0 - theta), 5.0);

    FragColor = mix(vec4(0), FragColor, reflectance);

    #ifdef DITHERING
        FragColor.rgb = dither(FragColor.rgb);
    #endif

    FragColor.a = 1.0;
}
`;



---
File: /src/shaders/ReflectorShader.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/objects/Water2.js by Mugen87

import dither from './modules/dither/dither.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec3 normal;
in vec2 uv;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

uniform mat3 uMapTransform;
uniform mat4 uMatrix;

out vec2 vUv;
out vec4 vCoord;
out vec3 vNormal;
out vec3 vToEye;

void main() {
    vUv = (uMapTransform * vec3(uv, 1.0)).xy;
    vCoord = uMatrix * vec4(position, 1.0);
    vNormal = normalMatrix * normal;
    vToEye = cameraPosition - (modelMatrix * vec4(position, 1.0)).xyz;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tReflect;
uniform vec3 uColor;
uniform float uReflectivity;
uniform float uMirror;
uniform float uMixStrength;

#ifdef USE_MAP
    uniform sampler2D tMap;
#endif

#ifdef USE_NORMALMAP
    uniform sampler2D tNormalMap;
    uniform vec2 uNormalScale;
#endif

#ifdef USE_FOG
    uniform vec3 uFogColor;
    uniform float uFogNear;
    uniform float uFogFar;
#endif

in vec2 vUv;
in vec4 vCoord;
in vec3 vNormal;
in vec3 vToEye;

out vec4 FragColor;

${dither}

void main() {
    #ifdef USE_MAP
        vec4 color = texture(tMap, vUv);
    #else
        vec4 color = vec4(uColor, 1.0);
    #endif

    #ifdef USE_NORMALMAP
        vec4 normalColor = texture(tNormalMap, vUv * uNormalScale);
        vec3 normal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));
        vec3 coord = vCoord.xyz / vCoord.w;
        vec2 uv = coord.xy + coord.z * normal.xz * 0.05;
        vec4 reflectColor = texture(tReflect, uv);
    #else
        vec3 normal = vNormal;
        vec4 reflectColor = textureProj(tReflect, vCoord);
    #endif

    // Fresnel term
    vec3 toEye = normalize(vToEye);
    float theta = max(dot(toEye, normal), 0.0);
    float reflectance = uReflectivity + (1.0 - uReflectivity) * pow((1.0 - theta), 5.0);

    reflectColor = mix(vec4(0), reflectColor, reflectance);

    FragColor.rgb = color.rgb * ((1.0 - min(1.0, uMirror)) + reflectColor.rgb * uMixStrength);

    #ifdef USE_FOG
        float fogDepth = gl_FragCoord.z / gl_FragCoord.w;
        float fogFactor = smoothstep(uFogNear, uFogFar, fogDepth);

        FragColor.rgb = mix(FragColor.rgb, uFogColor, fogFactor);
    #endif

    #ifdef DITHERING
        FragColor.rgb = dither(FragColor.rgb);
    #endif

    FragColor.a = 1.0;
}
`;



---
File: /src/shaders/RGBShader.js
---

import rgbshift from './modules/rgbshift/rgbshift.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uAngle;
uniform float uAmount;

in vec2 vUv;

out vec4 FragColor;

${rgbshift}

void main() {
    FragColor = getRGB(tMap, vUv, uAngle, uAmount);
}
`;



---
File: /src/shaders/SceneCompositeAddShader.js
---

import dither from './modules/dither/dither.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tScene;
uniform sampler2D tBloom;
uniform sampler2D tAdd;

in vec2 vUv;

out vec4 FragColor;

${dither}

void main() {
    FragColor = texture(tScene, vUv);

    FragColor.rgb += texture(tBloom, vUv).rgb;

    FragColor.rgb += texture(tAdd, vUv).rgb;

    #ifdef DITHERING
        FragColor.rgb = dither(FragColor.rgb);
    #endif

    FragColor.a = 1.0;
}
`;



---
File: /src/shaders/SceneCompositeDistortionShader.js
---

import rgbshift from './modules/rgbshift/rgbshift.glsl.js';
import dither from './modules/dither/dither.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tScene;
uniform sampler2D tBloom;
uniform float uBloomDistortion;

in vec2 vUv;

out vec4 FragColor;

${rgbshift}
${dither}

void main() {
    FragColor = texture(tScene, vUv);

    float angle = length(vUv - 0.5);
    float amount = 0.001 * uBloomDistortion;

    FragColor.rgb += getRGB(tBloom, vUv, angle, amount).rgb;

    #ifdef DITHERING
        FragColor.rgb = dither(FragColor.rgb);
    #endif

    FragColor.a = 1.0;
}
`;



---
File: /src/shaders/SceneCompositeShader.js
---

import dither from './modules/dither/dither.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tScene;
uniform sampler2D tBloom;

in vec2 vUv;

out vec4 FragColor;

${dither}

void main() {
    FragColor = texture(tScene, vUv);

    FragColor.rgb += texture(tBloom, vUv).rgb;

    #ifdef DITHERING
        FragColor.rgb = dither(FragColor.rgb);
    #endif

    FragColor.a = 1.0;
}
`;



---
File: /src/shaders/ShadowTextureShader.js
---

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uAlpha;

in vec2 vUv;

out vec4 FragColor;

void main() {
    float shadow = texture(tMap, vUv).g;

    FragColor.rgb = vec3(0.0);
    FragColor.a = shadow * uAlpha;
}
`;



---
File: /src/shaders/SinglePassBlurShader.js
---

import blur from './modules/blur/blur.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uBlurAmount;
uniform vec2 uResolution;

in vec2 vUv;

out vec4 FragColor;

${blur}

void main() {
    vec4 blur1 = blur(tMap, vUv, uResolution, vec2(uBlurAmount, 0.0)) * 0.5;
    vec4 blur2 = blur(tMap, vUv, uResolution, vec2(0.0, uBlurAmount)) * 0.5;

    FragColor = blur1 + blur2;
}
`;



---
File: /src/shaders/SMAABlendShader.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc
// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/postprocessing/SMAAPass.js by mpk

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

uniform vec2 uTexelSize;

out vec2 vUv;
out vec4 vOffset[2];

void SMAANeighborhoodBlendingVS(vec2 texCoord) {
    vOffset[0] = texCoord.xyxy + uTexelSize.xyxy * vec4(-1.0, 0.0, 0.0, 1.0);
    vOffset[1] = texCoord.xyxy + uTexelSize.xyxy * vec4(1.0, 0.0, 0.0, -1.0);
}

void main() {
    vUv = uv;

    SMAANeighborhoodBlendingVS(vUv);

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform sampler2D tWeightMap;
uniform vec2 uTexelSize;

in vec2 vUv;
in vec4 vOffset[2];

out vec4 FragColor;

vec4 SMAANeighborhoodBlendingPS(vec2 texCoord, vec4 offset[2], sampler2D colorTex, sampler2D blendTex) {
    // Fetch the blending weights for the current pixel
    vec4 a;
    a.xz = texture(blendTex, texCoord).xz;
    a.y = texture(blendTex, offset[1].zw).g;
    a.w = texture(blendTex, offset[1].xy).a;

    // Ignore tiny blending weights
    if (dot(a, vec4(1.0)) < 1e-5) {
        return texture(colorTex, texCoord);
    } else {
        // Up to 4 lines can be crossing a pixel (one through each edge). We
        // favor blending by choosing the line with the maximum weight for each
        // direction.
        vec2 offset;
        offset.x = a.a > a.b ? a.a : -a.b; // left vs. right
        offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom

        // Then we go in the direction that has the maximum weight
        if (abs(offset.x) > abs(offset.y)) { // horizontal vs. vertical
            offset.y = 0.0;
        } else {
            offset.x = 0.0;
        }

        // Fetch the opposite color and lerp by hand
        vec4 c = texture(colorTex, texCoord);
        texCoord += sign(offset) * uTexelSize;
        vec4 cOp = texture(colorTex, texCoord);
        float s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);

        // Gamma correction
        c.xyz = pow(c.xyz, vec3(2.2));
        cOp.xyz = pow(cOp.xyz, vec3(2.2));
        vec4 mixed = mix(c, cOp, s);
        mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));

        return mixed;
    }
}

void main() {
    FragColor = SMAANeighborhoodBlendingPS(vUv, vOffset, tMap, tWeightMap);
}
`;



---
File: /src/shaders/SMAAEdgesShader.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc
// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/postprocessing/SMAAPass.js by mpk

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

uniform vec2 uTexelSize;

out vec2 vUv;
out vec4 vOffset[3];

void SMAAEdgeDetectionVS(vec2 texCoord) {
    vOffset[0] = texCoord.xyxy + uTexelSize.xyxy * vec4(-1.0, 0.0, 0.0, 1.0);
    vOffset[1] = texCoord.xyxy + uTexelSize.xyxy * vec4(1.0, 0.0, 0.0, -1.0);
    vOffset[2] = texCoord.xyxy + uTexelSize.xyxy * vec4(-2.0, 0.0, 0.0, 2.0);
}

void main() {
    vUv = uv;

    SMAAEdgeDetectionVS(vUv);

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;

in vec2 vUv;
in vec4 vOffset[3];

out vec4 FragColor;

vec4 SMAAColorEdgeDetectionPS(vec2 texCoord, vec4 offset[3], sampler2D colorTex) {
    vec2 threshold = vec2(SMAA_THRESHOLD);

    // Color-based edge detection
    vec4 delta;
    vec3 c = texture(colorTex, texCoord).rgb;

    vec3 cLeft = texture(colorTex, offset[0].xy).rgb;
    vec3 t = abs(c - cLeft);
    delta.x = max(max(t.r, t.g), t.b);

    vec3 cTop = texture(colorTex, offset[0].zw).rgb;
    t = abs(c - cTop);
    delta.y = max(max(t.r, t.g), t.b);

    vec2 edges = step(threshold, delta.xy);

    if (dot(edges, vec2(1.0)) == 0.0) {
        discard;
    }

    // Calculate right and bottom deltas
    vec3 cRight = texture(colorTex, offset[1].xy).rgb;
    t = abs(c - cRight);
    delta.z = max(max(t.r, t.g), t.b);

    vec3 cBottom  = texture(colorTex, offset[1].zw).rgb;
    t = abs(c - cBottom);
    delta.w = max(max(t.r, t.g), t.b);

    // Calculate the maximum delta in the direct neighborhood
    float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);

    // Calculate left-left and top-top deltas
    vec3 cLeftLeft = texture(colorTex, offset[2].xy).rgb;
    t = abs(c - cLeftLeft);
    delta.z = max(max(t.r, t.g), t.b);

    vec3 cTopTop = texture(colorTex, offset[2].zw).rgb;
    t = abs(c - cTopTop);
    delta.w = max(max(t.r, t.g), t.b);

    // Calculate the final maximum delta
    maxDelta = max(max(maxDelta, delta.z), delta.w);

    // Local contrast adaptation
    edges *= step(0.5 * maxDelta, delta.xy);

    return vec4(edges, 0.0, 0.0);
}

void main() {
    FragColor = SMAAColorEdgeDetectionPS(vUv, vOffset, tMap);
}
`;



---
File: /src/shaders/SMAAWeightsShader.js
---

// Based on https://github.com/pmndrs/postprocessing by vanruesc
// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/postprocessing/SMAAPass.js by mpk

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

uniform vec2 uTexelSize;

out vec2 vUv;
out vec4 vOffset[3];
out vec2 vPixCoord;

void SMAABlendingWeightCalculationVS(vec2 texCoord) {
    vPixCoord = texCoord / uTexelSize;

    // Offsets for the searches
    vOffset[0] = texCoord.xyxy + uTexelSize.xyxy * vec4(-0.25, 0.125, 1.25, 0.125);
    vOffset[1] = texCoord.xyxy + uTexelSize.xyxy * vec4(-0.125, 0.25, -0.125, -1.25);

    // This indicates the ends of the loops
    vOffset[2] = vec4(vOffset[0].xz, vOffset[1].yw) +
        vec4(-2.0, 2.0, -2.0, 2.0) * uTexelSize.xxyy * float(SMAA_MAX_SEARCH_STEPS);
}

void main() {
    vUv = uv;

    SMAABlendingWeightCalculationVS(vUv);

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

#define SMAASampleLevelZeroOffset(tex, coord, offset) texture(tex, coord + offset * uTexelSize)

uniform sampler2D tMap;
uniform sampler2D tArea;
uniform sampler2D tSearch;
uniform vec2 uTexelSize;

in vec2 vUv;
in vec4 vOffset[3];
in vec2 vPixCoord;

out vec4 FragColor;

float SMAASearchLength(sampler2D searchTex, vec2 e, float bias, float scale) {
    e.r = bias + e.r * scale;
    return 255.0 * texture(searchTex, e).r;
}

float SMAASearchXLeft(sampler2D edgesTex, sampler2D searchTex, vec2 texCoord, float end) {
    vec2 e = vec2(0.0, 1.0);

    for (int i = 0; i < SMAA_MAX_SEARCH_STEPS; i++) {
        e = texture(edgesTex, texCoord).rg;
        texCoord -= vec2(2.0, 0.0) * uTexelSize;
        if (!(texCoord.x > end && e.g > 0.8281 && e.r == 0.0)) break;
    }

    texCoord.x += 0.25 * uTexelSize.x;
    texCoord.x += uTexelSize.x;
    texCoord.x += 2.0 * uTexelSize.x;
    texCoord.x -= uTexelSize.x * SMAASearchLength(searchTex, e, 0.0, 0.5);

    return texCoord.x;
}

float SMAASearchXRight(sampler2D edgesTex, sampler2D searchTex, vec2 texCoord, float end) {
    vec2 e = vec2(0.0, 1.0);

    for (int i = 0; i < SMAA_MAX_SEARCH_STEPS; i++) {
        e = texture(edgesTex, texCoord).rg;
        texCoord += vec2(2.0, 0.0) * uTexelSize;
        if (!(texCoord.x < end && e.g > 0.8281 && e.r == 0.0)) break;
    }

    texCoord.x -= 0.25 * uTexelSize.x;
    texCoord.x -= uTexelSize.x;
    texCoord.x -= 2.0 * uTexelSize.x;
    texCoord.x += uTexelSize.x * SMAASearchLength(searchTex, e, 0.5, 0.5);

    return texCoord.x;
}

float SMAASearchYUp(sampler2D edgesTex, sampler2D searchTex, vec2 texCoord, float end) {
    vec2 e = vec2(1.0, 0.0);

    for (int i = 0; i < SMAA_MAX_SEARCH_STEPS; i++) {
        e = texture(edgesTex, texCoord).rg;
        texCoord += vec2(0.0, 2.0) * uTexelSize;
        if (!(texCoord.y > end && e.r > 0.8281 && e.g == 0.0)) break;
    }

    texCoord.y -= 0.25 * uTexelSize.y;
    texCoord.y -= uTexelSize.y;
    texCoord.y -= 2.0 * uTexelSize.y;
    texCoord.y += uTexelSize.y * SMAASearchLength(searchTex, e.gr, 0.0, 0.5);

    return texCoord.y;
}

float SMAASearchYDown(sampler2D edgesTex, sampler2D searchTex, vec2 texCoord, float end) {
    vec2 e = vec2(1.0, 0.0);

    for (int i = 0; i < SMAA_MAX_SEARCH_STEPS; i++) {
        e = texture(edgesTex, texCoord).rg;
        texCoord -= vec2(0.0, 2.0) * uTexelSize;
        if (!(texCoord.y < end && e.r > 0.8281 && e.g == 0.0)) break;
    }

    texCoord.y += 0.25 * uTexelSize.y;
    texCoord.y += uTexelSize.y;
    texCoord.y += 2.0 * uTexelSize.y;
    texCoord.y -= uTexelSize.y * SMAASearchLength(searchTex, e.gr, 0.5, 0.5);

    return texCoord.y;
}

vec2 SMAAArea(sampler2D areaTex, vec2 dist, float e1, float e2, float offset) {
    // Rounding prevents precision errors of bilinear filtering
    vec2 texCoord = vec2(SMAA_AREATEX_MAX_DISTANCE) * round(4.0 * vec2(e1, e2)) + dist;

    // Apply a scale and bias for mapping to texel space
    texCoord = SMAA_AREATEX_PIXEL_SIZE * texCoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);

    // Move to the proper place, according to the subpixel offset
    texCoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

    return texture(areaTex, texCoord).rg;
}

vec4 SMAABlendingWeightCalculationPS(vec2 texCoord, vec2 pixcoord, vec4 offset[3], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex) {
    vec4 weights = vec4(0.0);
    vec4 subsampleIndices = vec4(0.0);
    vec2 e = texture(edgesTex, texCoord).rg;

    if (e.g > 0.0) { // Edge at north
        vec2 d;

        // Find the distance to the left
        vec2 coords;
        coords.x = SMAASearchXLeft(edgesTex, searchTex, offset[0].xy, offset[2].x);
        coords.y = offset[1].y;
        d.x = coords.x;

        // Now fetch the left crossing edges, two at a time using bilinear
        // filtering. Sampling at -0.25 to discern what value each edge has.
        float e1 = texture(edgesTex, coords).r;

        // Find the distance to the right
        coords.x = SMAASearchXRight(edgesTex, searchTex, offset[0].zw, offset[2].y);
        d.y = coords.x;

        // Translate distances into pixel units
        d = d / uTexelSize.x - pixcoord.x;

        // The area texture is compressed quadratically
        vec2 sqrtD = sqrt(abs(d));

        // Fetch the right crossing edges
        coords.y -= 1.0 * uTexelSize.y;
        float e2 = SMAASampleLevelZeroOffset(edgesTex, coords, vec2(1, 0)).r;

        // Pattern recognized, now get the actual area
        weights.rg = SMAAArea(areaTex, sqrtD, e1, e2, subsampleIndices.y);
    }

    if (e.r > 0.0) { // Edge at west
        vec2 d;

        // Find the distance to the top
        vec2 coords;
        coords.y = SMAASearchYUp(edgesTex, searchTex, offset[1].xy, offset[2].z);
        coords.x = offset[0].x;
        d.x = coords.y;

        // Fetch the top crossing edges
        float e1 = texture(edgesTex, coords).g;

        // Find the distance to the bottom
        coords.y = SMAASearchYDown(edgesTex, searchTex, offset[1].zw, offset[2].w);
        d.y = coords.y;

        // Translate distances into pixel units
        d = d / uTexelSize.y - pixcoord.y;

        // The area texture is compressed quadratically
        vec2 sqrtD = sqrt(abs(d));

        // Fetch the bottom crossing edges
        coords.y -= 1.0 * uTexelSize.y;
        float e2 = SMAASampleLevelZeroOffset(edgesTex, coords, vec2(0, 1)).g;

        // Get the area for this direction
        weights.ba = SMAAArea(areaTex, sqrtD, e1, e2, subsampleIndices.x);
    }

    return weights;
}

void main() {
    FragColor = SMAABlendingWeightCalculationPS(vUv, vPixCoord, vOffset, tMap, tArea, tSearch);
}
`;



---
File: /src/shaders/TextShader.js
---

// Based on https://oframe.github.io/ogl/examples/?src=msdf-text.html by gordonnl

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform vec3 uColor;
uniform float uAlpha;

in vec2 vUv;

out vec4 FragColor;

void main() {
    vec3 tex = texture(tMap, vUv).rgb;
    float signedDist = max(min(tex.r, tex.g), min(max(tex.r, tex.g), tex.b)) - 0.5;
    float d = fwidth(signedDist);
    float alpha = smoothstep(-d, d, signedDist);

    alpha *= uAlpha;

    if (alpha < 0.01) {
        discard;
    }

    FragColor.rgb = uColor;
    FragColor.a = alpha;
}
`;



---
File: /src/shaders/TiltShiftShader.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/shaders/HorizontalTiltShiftShader.js by alteredq
// Based on https://github.com/spite/codevember-2016

import smootherstep from './modules/smootherstep/smootherstep.glsl.js';
import blur from './modules/blur/blur.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uFocus;
uniform float uBlurAmount;
uniform vec2 uDirection;
uniform vec2 uResolution;

in vec2 vUv;

out vec4 FragColor;

${smootherstep}
${blur}

void main() {
    float d = abs(uFocus - vUv.y);

    FragColor = blur(tMap, vUv, uResolution, uBlurAmount * smootherstep(0.0, 1.0, d) * uDirection);
}
`;



---
File: /src/shaders/UnrealBloomBlurShader.js
---

import blur from './modules/blur/unreal-blur.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform vec2 uDirection;
uniform vec2 uResolution;

in vec2 vUv;

out vec4 FragColor;

${blur}

void main() {
    FragColor = blur(tMap, vUv, uResolution, uDirection);
}
`;



---
File: /src/shaders/UnrealBloomCompositeShader.js
---

// Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/postprocessing/UnrealBloomPass.js by spidersharma03 and bhouston

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tBlur1;
uniform sampler2D tBlur2;
uniform sampler2D tBlur3;
uniform sampler2D tBlur4;
uniform sampler2D tBlur5;
uniform float uBloomStrength;
uniform float uBloomRadius;
uniform float uBloomFactors[NUM_MIPS];
uniform vec3 uBloomTintColors[NUM_MIPS];

in vec2 vUv;

out vec4 FragColor;

float lerpBloomFactor(float factor) {
    return mix(factor, 1.2 - factor, uBloomRadius);
}

void main() {
    FragColor = uBloomStrength * (lerpBloomFactor(uBloomFactors[0]) * vec4(uBloomTintColors[0], 1.0) * texture(tBlur1, vUv) +
                                  lerpBloomFactor(uBloomFactors[1]) * vec4(uBloomTintColors[1], 1.0) * texture(tBlur2, vUv) +
                                  lerpBloomFactor(uBloomFactors[2]) * vec4(uBloomTintColors[2], 1.0) * texture(tBlur3, vUv) +
                                  lerpBloomFactor(uBloomFactors[3]) * vec4(uBloomTintColors[3], 1.0) * texture(tBlur4, vUv) +
                                  lerpBloomFactor(uBloomFactors[4]) * vec4(uBloomTintColors[4], 1.0) * texture(tBlur5, vUv));
}
`;



---
File: /src/shaders/VideoGlitchShader.js
---

// Based on https://www.shadertoy.com/view/XtK3W3 by dyvoid

import simplex2d from './modules/noise/simplex2d.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform float uDistortion;
uniform float uDistortion2;
uniform float uSpeed;
uniform float uTime;

in vec2 vUv;

out vec4 FragColor;

${simplex2d}

void main() {
    vec2 uv = vUv;

    // Create large, incidental noise waves
    float noise = max(0.0, snoise(vec2(uTime * uSpeed, uv.y * 0.3)) - 0.3) * uDistortion;

    // Offset by smaller, constant noise waves
    noise += (snoise(vec2(uTime * 10.0 * uSpeed, uv.y * 2.4)) - 0.5) * uDistortion2;

    // Apply the noise as X displacement for every line
    float xpos = uv.x - noise * noise * 0.25;
    FragColor = texture(tMap, vec2(xpos, uv.y));

    // Mix in some random interference for lines
    FragColor.rgb = mix(FragColor.rgb, vec3(0.0), noise * 0.3).rgb;

    // Apply a line pattern every 4 pixels
    if (floor(mod(gl_FragCoord.y * 0.25, 2.0)) == 0.0) {
        FragColor.rgb *= 1.0 - (0.15 * noise);
    }
}
`;



---
File: /src/shaders/VolumetricLightLensflareShader.js
---

// Based on https://github.com/BKcore/Three.js-experiments-pool
// Based on https://github.com/netpraxis/volumetric_light_example
// Based on https://codepen.io/peterhry/pen/egzjGR
// Based on https://www.shadertoy.com/view/4sX3Rs by mu6k
// Based on https://www.shadertoy.com/view/wlcyzj by TheNosiriN

import lensflare from './modules/lensflare/lensflare.glsl.js';

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform vec2 uLightPosition;
uniform vec2 uScale;
uniform float uSwizzle;
uniform float uExposure;
uniform float uDecay;
uniform float uDensity;
uniform float uWeight;
uniform float uClamp;
uniform vec2 uLensflareScale;
uniform float uLensflareExposure;
uniform float uLensflareClamp;
uniform vec2 uResolution;

in vec2 vUv;

out vec4 FragColor;

const int samples = 20;

${lensflare}

void main() {
    vec2 texcoord = vUv;
    vec2 deltaTexCoord = texcoord - uLightPosition;
    deltaTexCoord *= 1.0 / float(samples) * uDensity;
    vec4 color = vec4(0);
    float illuminationDecay = 1.0;

    for (int i = 0; i < samples; i++) {
        texcoord -= ((deltaTexCoord.xy * (1.0 - uSwizzle)) + (deltaTexCoord.xx * uSwizzle)) * uScale;
        vec4 texel = texture(tMap, texcoord);
        texel *= illuminationDecay * uWeight;
        color += texel;
        illuminationDecay *= uDecay;
    }

    color *= uExposure;
    color = clamp(color, 0.0, uClamp);

    // Lens flare
    vec2 uv = vUv - 0.5;
    vec2 pos = uLightPosition - 0.5;

    uv.x *= uResolution.x / uResolution.y;
    pos.x *= uResolution.x / uResolution.y;

    uv *= uLensflareScale;
    pos *= uLensflareScale;

    vec3 flare = lensflare(uv, pos) * texture(tMap, uLightPosition).rgb * 2.0;
    flare = pow(flare, vec3(0.5));
    flare *= uLensflareExposure;
    flare = clamp(flare, 0.0, uLensflareClamp);

    FragColor = vec4(color.rgb + flare, 1.0);
}
`;



---
File: /src/shaders/VolumetricLightShader.js
---

// Based on https://github.com/BKcore/Three.js-experiments-pool
// Based on https://github.com/netpraxis/volumetric_light_example
// Based on https://codepen.io/peterhry/pen/egzjGR

export const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

export const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;
uniform vec2 uLightPosition;
uniform vec2 uScale;
uniform float uSwizzle;
uniform float uExposure;
uniform float uDecay;
uniform float uDensity;
uniform float uWeight;
uniform float uClamp;

in vec2 vUv;

out vec4 FragColor;

const int samples = 20;

void main() {
    vec2 texcoord = vUv;
    vec2 deltaTexCoord = texcoord - uLightPosition;
    deltaTexCoord *= 1.0 / float(samples) * uDensity;
    vec4 color = vec4(0);
    float illuminationDecay = 1.0;

    for (int i = 0; i < samples; i++) {
        texcoord -= ((deltaTexCoord.xy * (1.0 - uSwizzle)) + (deltaTexCoord.xx * uSwizzle)) * uScale;
        vec4 texel = texture(tMap, texcoord);
        texel *= illuminationDecay * uWeight;
        color += texel;
        illuminationDecay *= uDecay;
    }

    color *= uExposure;
    color = clamp(color, 0.0, uClamp);

    FragColor = vec4(color.rgb, 1.0);
}
`;



---
File: /src/three/materials/ACESFilmicToneMappingMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/ACESFilmicToneMappingShader.js';

/**
 * An ACES Filmic tone mapping material with exposure parameter.
 */
export class ACESFilmicToneMappingMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uExposure: { value: 1 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/AfterimageMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/AfterimageShader.js';

/**
 * An afterimage pass material with damping parameter.
 */
export class AfterimageMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tOld: { value: null },
                tNew: { value: null },
                uDamping: { value: 0.96 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/BadTVMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/BadTVShader.js';

/**
 * A TV-style glitch pass material with distortion and speed parameters.
 */
export class BadTVMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uDistortion: { value: 3 },
                uDistortion2: { value: 5 },
                uSpeed: { value: 0.2 },
                uRollSpeed: { value: 0.1 },
                uTime: { value: 0 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/BasicLightingMaterial.js
---

import { GLSL3, Matrix3, RawShaderMaterial, Vector3 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/BasicLightingShader.js';

/**
 * A basic texture map material with position-based lighting,
 * intensity and alpha parameters plus instancing support.
 */
export class BasicLightingMaterial extends RawShaderMaterial {
    constructor({
        map = null,
        lightPosition = new Vector3(1, 1, 1),
        lightIntensity = 0.25,
        instancing = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
            },
            uniforms: {
                tMap: { value: null },
                uMapTransform: { value: new Matrix3() },
                uLightPosition: { value: lightPosition },
                uLightIntensity: { value: lightIntensity },
                uAlpha: { value: 1 }
            },
            vertexShader,
            fragmentShader,
            transparent: true
        };

        if (map) {
            map.updateMatrix();

            parameters.uniforms = Object.assign(parameters.uniforms, {
                tMap: { value: map },
                uMapTransform: { value: map.matrix }
            });
        }

        if (instancing) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_INSTANCING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/BasicMaterial.js
---

import { GLSL3, Matrix3, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/BasicShader.js';

/**
 * A basic texture map material with alpha parameter and instancing support.
 */
export class BasicMaterial extends RawShaderMaterial {
    constructor({
        map = null,
        instancing = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
            },
            uniforms: {
                tMap: { value: null },
                uMapTransform: { value: new Matrix3() },
                uAlpha: { value: 1 }
            },
            vertexShader,
            fragmentShader,
            transparent: true
        };

        if (map) {
            map.updateMatrix();

            parameters.uniforms = Object.assign(parameters.uniforms, {
                tMap: { value: map },
                uMapTransform: { value: map.matrix }
            });
        }

        if (instancing) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_INSTANCING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/BloomCompositeMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/BloomCompositeShader.js';

/**
 * A bloom composite pass material based on the bloom from Unreal Engine.
 */
export class BloomCompositeMaterial extends RawShaderMaterial {
    constructor({
        dithering = false
    } = {}) {
        super({
            glslVersion: GLSL3,
            defines: {
                NUM_MIPS: 5,
                DITHERING: dithering
            },
            uniforms: {
                tBlur1: { value: null },
                tBlur2: { value: null },
                tBlur3: { value: null },
                tBlur4: { value: null },
                tBlur5: { value: null },
                uBloomFactors: { value: null }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/BlurMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/BlurShader.js';

/**
 * A separable Gaussian blur pass material.
 */
export class BlurMaterial extends RawShaderMaterial {
    constructor(direction = new Vector2(0.5, 0.5)) {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uBlurAmount: { value: 1 },
                uDirection: { value: direction },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/BokehBlurMaterial1.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/BokehBlurShader1.js';

/**
 * A bokeh blur two pass material.
 */
export class BokehBlurMaterial1 extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uScale: { value: 1 },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/BokehBlurMaterial2.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/BokehBlurShader2.js';

/**
 * A bokeh blur two pass material.
 */
export class BokehBlurMaterial2 extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uScale: { value: 1 },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/ChromaticAberrationMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/ChromaticAberrationShader.js';

/**
 * A chromatic aberration pass material with RGB offset parameters.
 */
export class ChromaticAberrationMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uRedOffset: { value: -4 },
                uGreenOffset: { value: 1.5 },
                uBlueOffset: { value: 0 },
                uIntensity: { value: 1.5 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/ColorLightingMaterial.js
---

import { Color, GLSL3, RawShaderMaterial, Vector3 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/ColorLightingShader.js';

/**
 * A basic color material with position-based lighting,
 * intensity and alpha parameters plus instancing support.
 */
export class ColorLightingMaterial extends RawShaderMaterial {
    constructor({
        color,
        lightPosition = new Vector3(1, 1, 1),
        lightIntensity = 0.25,
        instancing = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
            },
            uniforms: {
                uColor: { value: color instanceof Color ? color : new Color(color) },
                uLightPosition: { value: lightPosition },
                uLightIntensity: { value: lightIntensity },
                uAlpha: { value: 1 }
            },
            vertexShader,
            fragmentShader,
            transparent: true
        };

        if (instancing) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_INSTANCING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/ColorMaterial.js
---

import { Color, GLSL3, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/ColorShader.js';

/**
 * A basic color material with alpha parameter and instancing support.
 */
export class ColorMaterial extends RawShaderMaterial {
    constructor({
        color,
        instancing = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
            },
            uniforms: {
                uColor: { value: color instanceof Color ? color : new Color(color) },
                uAlpha: { value: 1 }
            },
            vertexShader,
            fragmentShader
        };

        if (instancing) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_INSTANCING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/CopyMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/CopyShader.js';

/**
 * A blit pass material.
 */
export class CopyMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/DatamoshMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/DatamoshShader.js';

/**
 * A data moshing pass material with damping parameter.
 */
export class DatamoshMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tOld: { value: null },
                tNew: { value: null },
                tVelocity: { value: null },
                uAmount: { value: 1 },
                uLossy: { value: 1 },
                uDamping: { value: 0.96 },
                uResolution: { value: new Vector2() },
                uTime: { value: 0 },
                uFrame: { value: 0 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/DepthMaskMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/DepthMaskShader.js';

/**
 * A depth mask pass material that discards the lesser depth.
 */
export class DepthMaskMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                tDepth1: { value: null },
                tDepth2: { value: null }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/DepthMaterial.js
---

import { GLSL3, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/DepthShader.js';

/**
 * A depth material with dithering and instancing support.
 */
export class DepthMaterial extends RawShaderMaterial {
    constructor({
        dithering = false,
        instancing = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
                DITHERING: dithering
            },
            vertexShader,
            fragmentShader
        };

        if (instancing) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_INSTANCING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/DiscardMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/DiscardShader.js';

/**
 * A discard material with instancing support.
 */
export class DiscardMaterial extends RawShaderMaterial {
    constructor({
        instancing = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        };

        if (instancing) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_INSTANCING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/DrawBuffersMaterial.js
---

import { GLSL3, Matrix4, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/DrawBuffersShader.js';

/**
 * A draw buffers pass material with instancing support.
 */
export class DrawBuffersMaterial extends RawShaderMaterial {
    constructor({
        instancing = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
            },
            uniforms: {
                uPrevModelViewMatrix: { value: new Matrix4() },
                uPrevProjectionMatrix: { value: new Matrix4() },
                uInterpolateGeometry: { value: 1 },
                uSmearIntensity: { value: 1 }
            },
            vertexShader,
            fragmentShader
        };

        if (instancing) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_INSTANCING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/FastGaussianBlurMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/FastGaussianBlurShader.js';

/**
 * A separable Gaussian blur pass material.
 */
export class FastGaussianBlurMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uDirection: { value: new Vector2(1, 0) },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/FresnelMaterial.js
---

import { Color, GLSL3, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/FresnelShader.js';

/**
 * A Fresnel material with instancing support.
 */
export class FresnelMaterial extends RawShaderMaterial {
    constructor({
        baseColor,
        fresnelColor,
        fresnelPower = 1.5,
        instancing = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
            },
            uniforms: {
                uBaseColor: { value: baseColor instanceof Color ? baseColor : new Color(baseColor) },
                uFresnelColor: { value: fresnelColor instanceof Color ? fresnelColor : new Color(fresnelColor) },
                uFresnelPower: { value: fresnelPower }
            },
            vertexShader,
            fragmentShader
        };

        if (instancing) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_INSTANCING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/FXAAMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/FXAAShader.js';

/**
 * An FXAA pass material.
 */
export class FXAAMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/GammaCorrectionMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/GammaCorrectionShader.js';

/**
 * A gamma correction pass material.
 */
export class GammaCorrectionMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/LensflareMaterial.js
---

import { AdditiveBlending, GLSL3, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/LensflareShader.js';

/**
 * A lens flare pass material with position-based lighting.
 */
export class LensflareMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uLightPosition: { value: new Vector2(0.5, 0.5) },
                uScale: { value: new Vector2(1.5, 1.5) },
                uExposure: { value: 1 },
                uClamp: { value: 1 },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: AdditiveBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/LuminosityMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/LuminosityShader.js';

/**
 * A luminosity high pass material with threshold and smoothing parameters.
 */
export class LuminosityMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uThreshold: { value: 1 },
                uSmoothing: { value: 1 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/MaskMaterial.js
---

import { GLSL3, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/MaskShader.js';

/**
 * An alpha mask pass material that uses the green channel of the mask texture.
 */
export class MaskMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                tMask: { value: null }
            },
            vertexShader,
            fragmentShader,
            transparent: true
        });
    }
}



---
File: /src/three/materials/Materials.js
---

export { NormalMaterial } from './NormalMaterial.js';
export { ColorMaterial } from './ColorMaterial.js';
export { ColorLightingMaterial } from './ColorLightingMaterial.js';
export { BasicMaterial } from './BasicMaterial.js';
export { BasicLightingMaterial } from './BasicLightingMaterial.js';
export { ShadowTextureMaterial } from './ShadowTextureMaterial.js';
export { MaskMaterial } from './MaskMaterial.js';
export { DepthMaterial } from './DepthMaterial.js';
export { FresnelMaterial } from './FresnelMaterial.js';
export { CopyMaterial } from './CopyMaterial.js';
export { ACESFilmicToneMappingMaterial } from './ACESFilmicToneMappingMaterial.js';
export { GammaCorrectionMaterial } from './GammaCorrectionMaterial.js';
export { FXAAMaterial } from './FXAAMaterial.js';
export { SMAABlendMaterial } from './SMAABlendMaterial.js';
export { SMAAEdgesMaterial } from './SMAAEdgesMaterial.js';
export { SMAAWeightsMaterial } from './SMAAWeightsMaterial.js';
export { BadTVMaterial } from './BadTVMaterial.js';
export { RGBMaterial } from './RGBMaterial.js';
export { BlurMaterial } from './BlurMaterial.js';
export { SinglePassBlurMaterial } from './SinglePassBlurMaterial.js';
export { FastGaussianBlurMaterial } from './FastGaussianBlurMaterial.js';
export { LuminosityMaterial } from './LuminosityMaterial.js';
export { UnrealBloomBlurMaterial } from './UnrealBloomBlurMaterial.js';
export { UnrealBloomCompositeMaterial } from './UnrealBloomCompositeMaterial.js';
export { BloomCompositeMaterial } from './BloomCompositeMaterial.js';
export { SceneCompositeMaterial } from './SceneCompositeMaterial.js';
export { SceneCompositeAddMaterial } from './SceneCompositeAddMaterial.js';
export { SceneCompositeDistortionMaterial } from './SceneCompositeDistortionMaterial.js';
export { PoissonDiscBlurMaterial } from './PoissonDiscBlurMaterial.js';
export { MotionBlurVelocityMaterial } from './MotionBlurVelocityMaterial.js';
export { MotionBlurCompositeMaterial } from './MotionBlurCompositeMaterial.js';
export { DrawBuffersMaterial } from './DrawBuffersMaterial.js';
export { BokehBlurMaterial1 } from './BokehBlurMaterial1.js';
export { BokehBlurMaterial2 } from './BokehBlurMaterial2.js';
export { TiltShiftMaterial } from './TiltShiftMaterial.js';
export { ReflectorBlurMaterial } from './ReflectorBlurMaterial.js';
export { ReflectorMaterial } from './ReflectorMaterial.js';
export { ReflectorDudvMaterial } from './ReflectorDudvMaterial.js';
export { ChromaticAberrationMaterial } from './ChromaticAberrationMaterial.js';
export { VideoGlitchMaterial } from './VideoGlitchMaterial.js';
export { AfterimageMaterial } from './AfterimageMaterial.js';
export { DatamoshMaterial } from './DatamoshMaterial.js';
export { VolumetricLightMaterial } from './VolumetricLightMaterial.js';
export { VolumetricLightLensflareMaterial } from './VolumetricLightLensflareMaterial.js';
export { LensflareMaterial } from './LensflareMaterial.js';
export { DepthMaskMaterial } from './DepthMaskMaterial.js';
export { DiscardMaterial } from './DiscardMaterial.js';
export { TextMaterial } from './TextMaterial.js';



---
File: /src/three/materials/MotionBlurCompositeMaterial.js
---

import { GLSL3, NearestFilter, NoBlending, RawShaderMaterial, RepeatWrapping, TextureLoader, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/MotionBlurCompositeShader.js';

/**
 * A per-object motion blur pass material with blue noise jitter.
 */
export class MotionBlurCompositeMaterial extends RawShaderMaterial {
    constructor(loader = new TextureLoader(), {
        samples = 7,
        blueNoisePath = 'assets/textures/blue_noise.png',
        blueNoiseResolution = new Vector2(256, 256)
    } = {}) {
        const texture = loader.load(blueNoisePath);
        texture.wrapS = RepeatWrapping;
        texture.wrapT = RepeatWrapping;
        texture.magFilter = NearestFilter;
        texture.minFilter = NearestFilter;
        texture.generateMipmaps = false;

        super({
            glslVersion: GLSL3,
            defines: {
                SAMPLES: samples
            },
            uniforms: {
                tMap: { value: null },
                tVelocity: { value: null },
                tBlueNoise: { value: texture },
                uBlueNoiseResolution: { value: blueNoiseResolution }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/MotionBlurVelocityMaterial.js
---

import { GLSL3, Matrix4, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/MotionBlurVelocityShader.js';

/**
 * A velocity pass material with instancing support.
 */
export class MotionBlurVelocityMaterial extends RawShaderMaterial {
    constructor({
        instancing = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
            },
            uniforms: {
                uPrevModelViewMatrix: { value: new Matrix4() },
                uPrevProjectionMatrix: { value: new Matrix4() },
                uInterpolateGeometry: { value: 1 },
                uSmearIntensity: { value: 1 }
            },
            vertexShader,
            fragmentShader
        };

        if (instancing) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_INSTANCING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/NormalMaterial.js
---

import { GLSL3, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/NormalShader.js';

/**
 * A normal vectors material.
 */
export class NormalMaterial extends RawShaderMaterial {
    constructor({
        instancing = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
            },
            vertexShader,
            fragmentShader
        };

        if (instancing) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_INSTANCING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/PoissonDiscBlurMaterial.js
---

import { GLSL3, NearestFilter, NoBlending, RawShaderMaterial, RepeatWrapping, TextureLoader, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/PoissonDiscBlurShader.js';

/**
 * A Poisson-disc blur pass material.
 */
export class PoissonDiscBlurMaterial extends RawShaderMaterial {
    constructor(loader = new TextureLoader(), {
        blueNoisePath = 'assets/textures/blue_noise.png',
        blueNoiseResolution = new Vector2(256, 256)
    } = {}) {
        const texture = loader.load(blueNoisePath);
        texture.wrapS = RepeatWrapping;
        texture.wrapT = RepeatWrapping;
        texture.magFilter = NearestFilter;
        texture.minFilter = NearestFilter;
        texture.generateMipmaps = false;

        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                tBlueNoise: { value: texture },
                uBlueNoiseResolution: { value: blueNoiseResolution },
                uRadius: { value: 42 },
                uResolution: { value: new Vector2() },
                uTime: { value: 0 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/ReflectorBlurMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/ReflectorBlurShader.js';

/**
 * A separable Gaussian blur pass material for reflections.
 */
export class ReflectorBlurMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uDirection: { value: new Vector2(1, 0) },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/ReflectorDudvMaterial.js
---

import { GLSL3, Matrix3, Matrix4, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/ReflectorDudvShader.js';

/**
 * A reflection material with DuDv map.
 */
export class ReflectorDudvMaterial extends RawShaderMaterial {
    constructor({
        map = null,
        reflectivity = 0,
        dithering = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
                DITHERING: dithering
            },
            uniforms: {
                tMap: { value: null },
                tReflect: { value: null },
                tReflectBlur: { value: null },
                uMapTransform: { value: new Matrix3() },
                uMatrix: { value: new Matrix4() },
                uReflectivity: { value: reflectivity }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending
        };

        if (map) {
            map.updateMatrix();

            parameters.uniforms = Object.assign(parameters.uniforms, {
                tMap: { value: map },
                uMapTransform: { value: map.matrix }
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/ReflectorMaterial.js
---

import { Color, GLSL3, Matrix3, Matrix4, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/ReflectorShader.js';

/**
 * A reflection material.
 */
export class ReflectorMaterial extends RawShaderMaterial {
    constructor({
        color = new Color(0x101010),
        map = null,
        normalMap = null,
        normalScale = new Vector2(1, 1),
        reflectivity = 0,
        mirror = 0,
        mixStrength = 10,
        fog = null,
        dithering = false
    } = {}) {
        const parameters = {
            glslVersion: GLSL3,
            defines: {
            },
            uniforms: {
                tMap: { value: null },
                tReflect: { value: null },
                uMapTransform: { value: new Matrix3() },
                uMatrix: { value: new Matrix4() },
                uColor: { value: color instanceof Color ? color : new Color(color) },
                uReflectivity: { value: reflectivity },
                uMirror: { value: mirror },
                uMixStrength: { value: mixStrength }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending
        };

        if (map) {
            map.updateMatrix();

            parameters.defines = Object.assign(parameters.defines, {
                USE_MAP: ''
            });

            parameters.uniforms = Object.assign(parameters.uniforms, {
                tMap: { value: map },
                uMapTransform: { value: map.matrix }
            });
        }

        if (normalMap) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_NORMALMAP: ''
            });

            parameters.uniforms = Object.assign(parameters.uniforms, {
                tNormalMap: { value: normalMap },
                uNormalScale: { value: normalScale }
            });

            if (!map) {
                normalMap.updateMatrix();

                parameters.uniforms = Object.assign(parameters.uniforms, {
                    uMapTransform: { value: normalMap.matrix }
                });
            }
        }

        if (fog) {
            parameters.defines = Object.assign(parameters.defines, {
                USE_FOG: ''
            });

            parameters.uniforms = Object.assign(parameters.uniforms, {
                uFogColor: { value: fog.color },
                uFogNear: { value: fog.near },
                uFogFar: { value: fog.far }
            });
        }

        if (dithering) {
            parameters.defines = Object.assign(parameters.defines, {
                DITHERING: ''
            });
        }

        super(parameters);
    }
}



---
File: /src/three/materials/RGBMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/RGBShader.js';

/**
 * An RGB shift pass material with angle and amount parameters.
 */
export class RGBMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uAngle: { value: 0 },
                uAmount: { value: 0.005 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/SceneCompositeAddMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/SceneCompositeAddShader.js';

/**
 * A composite pass material for a scene with bloom and additional texture added.
 */
export class SceneCompositeAddMaterial extends RawShaderMaterial {
    constructor({
        dithering = false
    } = {}) {
        super({
            glslVersion: GLSL3,
            defines: {
                DITHERING: dithering
            },
            uniforms: {
                tScene: { value: null },
                tBloom: { value: null },
                tAdd: { value: null }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/SceneCompositeDistortionMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/SceneCompositeDistortionShader.js';

/**
 * A composite pass material for a scene with distorted bloom added,
 * and distortion parameter.
 */
export class SceneCompositeDistortionMaterial extends RawShaderMaterial {
    constructor({
        dithering = false
    } = {}) {
        super({
            glslVersion: GLSL3,
            defines: {
                DITHERING: dithering
            },
            uniforms: {
                tScene: { value: null },
                tBloom: { value: null },
                uBloomDistortion: { value: 1.5 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/SceneCompositeMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/SceneCompositeShader.js';

/**
 * A composite pass material for a scene with bloom added.
 */
export class SceneCompositeMaterial extends RawShaderMaterial {
    constructor({
        dithering = false
    } = {}) {
        super({
            glslVersion: GLSL3,
            defines: {
                DITHERING: dithering
            },
            uniforms: {
                tScene: { value: null },
                tBloom: { value: null }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/ShadowTextureMaterial.js
---

import { GLSL3, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/ShadowTextureShader.js';

/**
 * A basic texture map material with alpha parameter,
 * that uses the green channel of the texture as the shadow.
 */
export class ShadowTextureMaterial extends RawShaderMaterial {
    constructor({
        map = null
    } = {}) {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: map },
                uAlpha: { value: 1 }
            },
            vertexShader,
            fragmentShader,
            transparent: true
        });
    }
}



---
File: /src/three/materials/SinglePassBlurMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/SinglePassBlurShader.js';

/**
 * A single pass Gaussian blur sum pass material.
 */
export class SinglePassBlurMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uBlurAmount: { value: 1 },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/SMAABlendMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/SMAABlendShader.js';

/**
 * An SMAA blend pass material.
 */
export class SMAABlendMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                tWeightMap: { value: null },
                uTexelSize: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/SMAAEdgesMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/SMAAEdgesShader.js';

/**
 * An SMAA edges pass material.
 */
export class SMAAEdgesMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            defines: {
                SMAA_THRESHOLD: '0.1'
            },
            uniforms: {
                tMap: { value: null },
                uTexelSize: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/SMAAWeightsMaterial.js
---

import { GLSL3, LinearFilter, NearestFilter, NoBlending, RawShaderMaterial, TextureLoader, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/SMAAWeightsShader.js';

/**
 * An SMAA weights pass material.
 */
export class SMAAWeightsMaterial extends RawShaderMaterial {
    constructor(loader = new TextureLoader(), {
        areaTexturePath = 'assets/textures/smaa/area.png',
        searchTexturePath = 'assets/textures/smaa/search.png'
    } = {}) {
        const areaTexture = loader.load(areaTexturePath);
        areaTexture.minFilter = LinearFilter;
        areaTexture.generateMipmaps = false;
        areaTexture.flipY = false;

        const searchTexture = loader.load(searchTexturePath);
        searchTexture.magFilter = NearestFilter;
        searchTexture.minFilter = NearestFilter;
        searchTexture.generateMipmaps = false;
        searchTexture.flipY = false;

        super({
            glslVersion: GLSL3,
            defines: {
                SMAA_MAX_SEARCH_STEPS: '8',
                SMAA_AREATEX_MAX_DISTANCE: '16',
                SMAA_AREATEX_PIXEL_SIZE: '(1.0 / vec2(160.0, 560.0))',
                SMAA_AREATEX_SUBTEX_SIZE: '(1.0 / 7.0)'
            },
            uniforms: {
                tMap: { value: null },
                tArea: { value: areaTexture },
                tSearch: { value: searchTexture },
                uTexelSize: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/TextMaterial.js
---

import { Color, GLSL3, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/TextShader.js';

/**
 * An MSDF (Multichannel Signed Distance Fields) text material,
 * with color and alpha parameters.
 */
export class TextMaterial extends RawShaderMaterial {
    constructor({
        map = null,
        color
    } = {}) {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: map },
                uColor: { value: color instanceof Color ? color : new Color(color) },
                uAlpha: { value: 1 }
            },
            vertexShader,
            fragmentShader,
            transparent: true
        });
    }
}



---
File: /src/three/materials/TiltShiftMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/TiltShiftShader.js';

/**
 * A separable Gaussian blur pass material for a simple fake tilt-shift effect.
 */
export class TiltShiftMaterial extends RawShaderMaterial {
    constructor(direction = new Vector2(0.5, 0.5)) {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uFocus: { value: 0.5 },
                uBlurAmount: { value: 1 },
                uDirection: { value: direction },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/UnrealBloomBlurMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/UnrealBloomBlurShader.js';

/**
 * A separable Gaussian blur pass material based on the bloom from Unreal Engine.
 */
export class UnrealBloomBlurMaterial extends RawShaderMaterial {
    constructor(kernelRadius) {
        super({
            glslVersion: GLSL3,
            defines: {
                KERNEL_RADIUS: kernelRadius,
                SIGMA: kernelRadius
            },
            uniforms: {
                tMap: { value: null },
                uDirection: { value: new Vector2(0.5, 0.5) },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/UnrealBloomCompositeMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/UnrealBloomCompositeShader.js';

/**
 * A bloom composite pass material based on the bloom from Unreal Engine.
 */
export class UnrealBloomCompositeMaterial extends RawShaderMaterial {
    constructor(nMips) {
        super({
            glslVersion: GLSL3,
            defines: {
                NUM_MIPS: nMips
            },
            uniforms: {
                tBlur1: { value: null },
                tBlur2: { value: null },
                tBlur3: { value: null },
                tBlur4: { value: null },
                tBlur5: { value: null },
                uBloomStrength: { value: 1 },
                uBloomRadius: { value: 0 },
                uBloomFactors: { value: null },
                uBloomTintColors: { value: null }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/VideoGlitchMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/VideoGlitchShader.js';

/**
 * A TV-style glitch pass material with distortion and speed parameters.
 */
export class VideoGlitchMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uDistortion: { value: 1.43 },
                uDistortion2: { value: 0.15 },
                uSpeed: { value: 1 },
                uTime: { value: 0 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/VolumetricLightLensflareMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/VolumetricLightLensflareShader.js';

/**
 * A volumetric light pass material with lens flare.
 */
export class VolumetricLightLensflareMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uLightPosition: { value: new Vector2(0.5, 0.5) },
                uScale: { value: new Vector2(1, 1) },
                uSwizzle: { value: 0 },
                uExposure: { value: 0.6 },
                uDecay: { value: 0.93 },
                uDensity: { value: 0.96 },
                uWeight: { value: 0.4 },
                uClamp: { value: 1 },
                uLensflareScale: { value: new Vector2(1.5, 1.5) },
                uLensflareExposure: { value: 1 },
                uLensflareClamp: { value: 1 },
                uResolution: { value: new Vector2() }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/materials/VolumetricLightMaterial.js
---

import { GLSL3, NoBlending, RawShaderMaterial, Vector2 } from 'three';

import { vertexShader, fragmentShader } from '../../shaders/VolumetricLightShader.js';

/**
 * A volumetric light pass material.
 */
export class VolumetricLightMaterial extends RawShaderMaterial {
    constructor() {
        super({
            glslVersion: GLSL3,
            uniforms: {
                tMap: { value: null },
                uLightPosition: { value: new Vector2(0.5, 0.5) },
                uScale: { value: new Vector2(1, 1) },
                uSwizzle: { value: 0 },
                uExposure: { value: 0.6 },
                uDecay: { value: 0.93 },
                uDensity: { value: 0.96 },
                uWeight: { value: 0.4 },
                uClamp: { value: 1 }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}



---
File: /src/three/utils/physics/OimoPhysics.js
---

/**
 * @author pschroen / https://ufo.ai/
 *
 * Based on https://github.com/mrdoob/three.js/blob/66c460eca3c025678ff2bc0aa423f4ba10e9571e/examples/jsm/libs/OimoPhysics/index.js by VBT-YTokan
 * Based on https://github.com/mrdoob/three.js/blob/66c460eca3c025678ff2bc0aa423f4ba10e9571e/examples/jsm/physics/OimoPhysics.js by VBT-YTokan
 * Based on https://github.com/lo-th/phy
 */

import { Group, Matrix4, Quaternion, Vector3 } from 'three';

import { oimo } from 'oimophysics';

// Dynamics
export const World = oimo.dynamics.World;
export const RigidBodyType = oimo.dynamics.rigidbody.RigidBodyType;
export const RigidBodyConfig = oimo.dynamics.rigidbody.RigidBodyConfig;
export const RigidBody = oimo.dynamics.rigidbody.RigidBody;
export const ShapeConfig = oimo.dynamics.rigidbody.ShapeConfig;
export const Shape = oimo.dynamics.rigidbody.Shape;
export const SphericalJointConfig = oimo.dynamics.constraint.joint.SphericalJointConfig;
export const SphericalJoint = oimo.dynamics.constraint.joint.SphericalJoint;
export const RevoluteJointConfig = oimo.dynamics.constraint.joint.RevoluteJointConfig;
export const RevoluteJoint = oimo.dynamics.constraint.joint.RevoluteJoint;
export const CylindricalJointConfig = oimo.dynamics.constraint.joint.CylindricalJointConfig;
export const CylindricalJoint = oimo.dynamics.constraint.joint.CylindricalJoint;
export const PrismaticJointConfig = oimo.dynamics.constraint.joint.PrismaticJointConfig;
export const PrismaticJoint = oimo.dynamics.constraint.joint.PrismaticJoint;
export const UniversalJointConfig = oimo.dynamics.constraint.joint.UniversalJointConfig;
export const UniversalJoint = oimo.dynamics.constraint.joint.UniversalJoint;
export const RagdollJointConfig = oimo.dynamics.constraint.joint.RagdollJointConfig;
export const RagdollJoint = oimo.dynamics.constraint.joint.RagdollJoint;
export const GenericJointConfig = oimo.dynamics.constraint.joint.GenericJointConfig;
export const GenericJoint = oimo.dynamics.constraint.joint.GenericJoint;
export const JointConfig = oimo.dynamics.constraint.joint.JointConfig;
export const Joint = oimo.dynamics.constraint.joint.Joint;
export const SpringDamper = oimo.dynamics.constraint.joint.SpringDamper;
export const TranslationalLimitMotor = oimo.dynamics.constraint.joint.TranslationalLimitMotor;
export const RotationalLimitMotor = oimo.dynamics.constraint.joint.RotationalLimitMotor;

// Common
export const Vec3 = oimo.common.Vec3;
export const Quat = oimo.common.Quat;
export const Mat3 = oimo.common.Mat3;
export const Mat4 = oimo.common.Mat4;
export const MathUtil = oimo.common.MathUtil;
export const Transform = oimo.common.Transform;
export const Setting = oimo.common.Setting;

// Collision
export const BroadPhaseType = oimo.collision.broadphase.BroadPhaseType;
export const BoxGeometry = oimo.collision.geometry.BoxGeometry;
export const SphereGeometry = oimo.collision.geometry.SphereGeometry;
export const ConeGeometry = oimo.collision.geometry.ConeGeometry;
export const CylinderGeometry = oimo.collision.geometry.CylinderGeometry;
export const CapsuleGeometry = oimo.collision.geometry.CapsuleGeometry;
export const ConvexHullGeometry = oimo.collision.geometry.ConvexHullGeometry;
export const Geometry = oimo.collision.geometry.Geometry;

// Callback
export const RayCastClosest = oimo.dynamics.callback.RayCastClosest;
export const ContactCallback = oimo.dynamics.callback.ContactCallback;

// Defaults
Setting.defaultGJKMargin = 0.0001;

/**
 * A class for using the OimoPhysics 3D physics engine.
 */
export class OimoPhysics {
    constructor({
        fps = 60,
        timestep = 1 / fps,
        broadphase = BroadPhaseType.BVH,
        gravity = new Vec3(0, -9.81, 0),
        velocityIterations = 8,
        positionIterations = 8
    } = {}) {
        this.timestep = timestep;

        this.world = new World(broadphase, gravity);
        this.world.setNumVelocityIterations(velocityIterations);
        this.world.setNumPositionIterations(positionIterations);

        this.objects = [];
        this.map = new WeakMap();

        this.v = new Vector3();
        this.q = new Quaternion();
        this.object = new Group();
        this.matrix = new Matrix4();
    }

    getShape(position, quaternion, scale, geometry, {
        density,
        friction,
        restitution,
        collisionMask,
        collisionGroup
    }) {
        const shapeConfig = new ShapeConfig();

        if (density !== undefined) {
            shapeConfig.density = density;
        }

        if (friction !== undefined) {
            shapeConfig.friction = friction;
        }

        if (restitution !== undefined) {
            shapeConfig.restitution = restitution;
        }

        if (collisionMask !== undefined) {
            shapeConfig.collisionMask = collisionMask;
        }

        if (collisionGroup !== undefined) {
            shapeConfig.collisionGroup = collisionGroup;
        }

        const parameters = geometry.parameters;

        if (geometry.type === 'BoxGeometry') {
            const sx = parameters.width !== undefined ? (parameters.width * scale.x) / 2 : 0.5;
            const sy = parameters.height !== undefined ? (parameters.height * scale.y) / 2 : 0.5;
            const sz = parameters.depth !== undefined ? (parameters.depth * scale.z) / 2 : 0.5;

            shapeConfig.geometry = new BoxGeometry(new Vec3(sx, sy, sz));
        } else if (geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry') {
            const radius = parameters.radius !== undefined ? parameters.radius * scale.x : 1;

            shapeConfig.geometry = new SphereGeometry(radius);
        } else if (geometry.type === 'ConeGeometry') {
            const radius = parameters.radius !== undefined ? parameters.radius * scale.x : 1;
            const height = parameters.height !== undefined ? (parameters.height * scale.y) / 2 : 0.5;

            shapeConfig.geometry = new ConeGeometry(radius, height);
        } else if (geometry.type === 'CylinderGeometry') {
            const radius = parameters.radiusTop !== undefined ? parameters.radiusTop * scale.x : 1;
            const height = parameters.height !== undefined ? (parameters.height * scale.y) / 2 : 0.5;

            shapeConfig.geometry = new CylinderGeometry(radius, height);
        } else if (geometry.type === 'CapsuleGeometry') {
            const radius = parameters.radius !== undefined ? parameters.radius * scale.x : 1;
            const height = parameters.length !== undefined ? (parameters.length * scale.y) / 2 : 0.5;

            shapeConfig.geometry = new CapsuleGeometry(radius, height);
        } else if (geometry.type !== 'PlaneGeometry') {
            const vertices = geometry.getAttribute('position');
            const array = [];

            for (let i = 0; i < vertices.count; i++) {
                const v = new Vec3(
                    vertices.array[i * 3 + 0] * scale.x,
                    vertices.array[i * 3 + 1] * scale.y,
                    vertices.array[i * 3 + 2] * scale.z
                );

                array.push(v);
            }

            shapeConfig.geometry = new ConvexHullGeometry(array);
        }

        if (position) {
            shapeConfig.position.copyFrom(position);
        }

        if (quaternion) {
            shapeConfig.rotation.fromQuat(quaternion);
        }

        return new Shape(shapeConfig);
    }

    getBody(position, quaternion, scale, geometry, {
        density,
        friction,
        restitution,
        collisionMask,
        collisionGroup,
        gravityScale,
        linearVelocity,
        angularVelocity,
        linearDamping,
        angularDamping,
        contactCallback,
        autoSleep,
        kinematic,
        shapes
    }) {
        const bodyConfig = new RigidBodyConfig();

        if (autoSleep !== undefined) {
            bodyConfig.autoSleep = autoSleep;
        }

        if (kinematic) {
            bodyConfig.type = RigidBodyType.KINEMATIC;
        } else if (density === 0) {
            bodyConfig.type = RigidBodyType.STATIC;
        } else {
            bodyConfig.type = RigidBodyType.DYNAMIC;
        }

        const body = new RigidBody(bodyConfig);

        if (shapes !== undefined) {
            for (let i = 0; i < shapes.length; i++) {
                const { position, quaternion, scale, geometry } = shapes[i];

                body.addShape(this.getShape(position, quaternion, scale, geometry, {
                    density,
                    friction,
                    restitution,
                    collisionMask,
                    collisionGroup
                }));
            }
        } else {
            body.addShape(this.getShape(null, null, scale, geometry, {
                density,
                friction,
                restitution,
                collisionMask,
                collisionGroup
            }));
        }

        if (position) {
            body.setPosition(position);
        }

        if (quaternion) {
            body.setOrientation(quaternion);
        }

        if (gravityScale) {
            body.setGravityScale(gravityScale);
        }

        if (linearVelocity) {
            body.setLinearVelocity(linearVelocity);
        }

        if (angularVelocity) {
            body.setAngularVelocity(angularVelocity);
        }

        if (linearDamping) {
            body.setLinearDamping(linearDamping);
        }

        if (angularDamping) {
            body.setAngularDamping(angularDamping);
        }

        if (contactCallback) {
            this.setContactCallback(body, contactCallback);
        }

        return body;
    }

    getObjectBody(object, index = 0) {
        let body;

        if (object instanceof RigidBody) {
            body = object;
        } else if (object.isInstancedMesh) {
            body = this.map.get(object)[index];
        } else {
            body = this.map.get(object);
        }

        return body;
    }

    add(object, props) {
        if (object.geometry) {
            if (object.isInstancedMesh) {
                return this.handleInstancedMesh(object, object.geometry, props);
            } else {
                return this.handleMesh(object, object.geometry, props);
            }
        } else if (object instanceof JointConfig) {
            return this.handleJoint(object);
        } else if (object instanceof RigidBodyConfig) {
            return this.handleBody(object);
        }
    }

    get(object) {
        return this.map.get(object);
    }

    remove(object) {
        const body = this.map.get(object);

        if (object instanceof JointConfig) {
            this.world.removeJoint(body);
        } else if (object instanceof RigidBody) {
            this.world.removeRigidBody(body);
        }

        this.map.delete(object);
    }

    handleJoint(object) {
        let Joint;

        if (object instanceof SphericalJointConfig) {
            Joint = SphericalJoint;
        } else if (object instanceof RevoluteJointConfig) {
            Joint = RevoluteJoint;
        } else if (object instanceof CylindricalJointConfig) {
            Joint = CylindricalJoint;
        } else if (object instanceof PrismaticJointConfig) {
            Joint = PrismaticJoint;
        } else if (object instanceof UniversalJointConfig) {
            Joint = UniversalJoint;
        } else if (object instanceof RagdollJointConfig) {
            Joint = RagdollJoint;
        } else if (object instanceof GenericJointConfig) {
            Joint = GenericJoint;
        }

        const joint = new Joint(object);
        this.world.addJoint(joint);

        this.map.set(object, joint);

        return joint;
    }

    handleBody(object) {
        const body = new RigidBody(object);
        this.world.addRigidBody(body);

        this.map.set(object, body);

        return body;
    }

    handleMesh(object, geometry, props) {
        if (object.parent && object.parent.isGroup) {
            object = object.parent;
        }

        if (props === undefined) {
            props = object;
        }

        const { position, quaternion, scale } = object;

        const body = this.getBody(position, quaternion, scale, geometry, props);
        this.world.addRigidBody(body);

        if (props.density !== 0) {
            this.objects.push(object);
        }

        this.map.set(object, body);

        return body;
    }

    handleInstancedMesh(object, geometry, props = {}) {
        const bodies = [];

        for (let i = 0; i < object.count; i++) {
            const { position, quaternion, scale } = this.object;

            object.getMatrixAt(i, this.matrix);
            this.matrix.decompose(position, quaternion, scale);

            const body = this.getBody(position, quaternion, scale, geometry, props);
            this.world.addRigidBody(body);

            bodies.push(body);
        }

        if (props.density !== 0) {
            this.objects.push(object);
        }

        this.map.set(object, bodies);

        return bodies;
    }

    getGravity() {
        return this.world.getGravity();
    }

    setGravity(gravity) {
        this.world.setGravity(gravity);
    }

    getPosition(object, index) {
        const body = this.getObjectBody(object, index);

        return this.v.copy(body.getPosition()).clone();
    }

    setPosition(object, position, index) {
        const body = this.getObjectBody(object, index);

        body.setPosition(position);
    }

    getOrientation(object, index) {
        const body = this.getObjectBody(object, index);

        return this.q.copy(body.getOrientation()).clone();
    }

    setOrientation(object, orientation, index) {
        const body = this.getObjectBody(object, index);

        body.setOrientation(orientation);
    }

    getGravityScale(object, index) {
        const body = this.getObjectBody(object, index);

        return body.getGravityScale();
    }

    setGravityScale(object, gravityScale, index) {
        const body = this.getObjectBody(object, index);

        body.setGravityScale(gravityScale);
    }

    getLinearVelocity(object, index) {
        const body = this.getObjectBody(object, index);

        return this.v.copy(body.getLinearVelocity()).clone();
    }

    setLinearVelocity(object, linearVelocity, index) {
        const body = this.getObjectBody(object, index);

        body.setLinearVelocity(linearVelocity);
    }

    getAngularVelocity(object, index) {
        const body = this.getObjectBody(object, index);

        return this.v.copy(body.getAngularVelocity()).clone();
    }

    setAngularVelocity(object, angularVelocity, index) {
        const body = this.getObjectBody(object, index);

        body.setAngularVelocity(angularVelocity);
    }

    getLinearDamping(object, index) {
        const body = this.getObjectBody(object, index);

        return this.v.copy(body.getLinearDamping()).clone();
    }

    setLinearDamping(object, linearDamping, index) {
        const body = this.getObjectBody(object, index);

        body.setLinearDamping(linearDamping);
    }

    getAngularDamping(object, index) {
        const body = this.getObjectBody(object, index);

        return this.v.copy(body.getAngularDamping()).clone();
    }

    setAngularDamping(object, angularDamping, index) {
        const body = this.getObjectBody(object, index);

        body.setAngularDamping(angularDamping);
    }

    setContactCallback(object, callback, index) {
        const body = this.getObjectBody(object, index);

        const contactCallback = new ContactCallback();
        contactCallback.beginContact = contact => callback(body, contact);

        let shape = body.getShapeList();

        while (shape) {
            shape.setContactCallback(contactCallback);
            shape = shape.getNext();
        }
    }

    applyImpulse(object, impulse, positionInWorld, index) {
        const body = this.getObjectBody(object, index);

        body.applyImpulse(impulse, positionInWorld);
    }

    wakeUp(object, index) {
        const body = this.getObjectBody(object, index);

        body.wakeUp();
    }

    sleep(object, index) {
        const body = this.getObjectBody(object, index);

        body.sleep();
    }

    step() {
        this.world.step(this.timestep);

        for (let i = 0, il = this.objects.length; i < il; i++) {
            const object = this.objects[i];

            if (object.isInstancedMesh) {
                const bodies = this.map.get(object);

                for (let j = 0, jl = bodies.length; j < jl; j++) {
                    const body = bodies[j];

                    this.object.position.copy(body.getPosition());
                    this.object.quaternion.copy(body.getOrientation());
                    this.object.updateMatrix();

                    object.setMatrixAt(j, this.object.matrix);
                }

                object.instanceMatrix.needsUpdate = true;
                object.computeBoundingSphere();
            } else {
                const body = this.map.get(object);

                object.position.copy(body.getPosition());
                object.quaternion.copy(body.getOrientation());
            }
        }
    }
}



---
File: /src/three/utils/physics/OimoPhysicsBuffer.js
---

/**
 * @author pschroen / https://ufo.ai/
 *
 * Based on https://github.com/mrdoob/three.js/blob/66c460eca3c025678ff2bc0aa423f4ba10e9571e/examples/jsm/libs/OimoPhysics/index.js by VBT-YTokan
 * Based on https://github.com/mrdoob/three.js/blob/66c460eca3c025678ff2bc0aa423f4ba10e9571e/examples/jsm/physics/OimoPhysics.js by VBT-YTokan
 * Based on https://github.com/lo-th/phy
 */

import { oimo } from 'oimophysics';

// Dynamics
export const World = oimo.dynamics.World;
export const RigidBodyType = oimo.dynamics.rigidbody.RigidBodyType;
export const RigidBodyConfig = oimo.dynamics.rigidbody.RigidBodyConfig;
export const RigidBody = oimo.dynamics.rigidbody.RigidBody;
export const ShapeConfig = oimo.dynamics.rigidbody.ShapeConfig;
export const Shape = oimo.dynamics.rigidbody.Shape;
export const SphericalJointConfig = oimo.dynamics.constraint.joint.SphericalJointConfig;
export const SphericalJoint = oimo.dynamics.constraint.joint.SphericalJoint;
export const RevoluteJointConfig = oimo.dynamics.constraint.joint.RevoluteJointConfig;
export const RevoluteJoint = oimo.dynamics.constraint.joint.RevoluteJoint;
export const CylindricalJointConfig = oimo.dynamics.constraint.joint.CylindricalJointConfig;
export const CylindricalJoint = oimo.dynamics.constraint.joint.CylindricalJoint;
export const PrismaticJointConfig = oimo.dynamics.constraint.joint.PrismaticJointConfig;
export const PrismaticJoint = oimo.dynamics.constraint.joint.PrismaticJoint;
export const UniversalJointConfig = oimo.dynamics.constraint.joint.UniversalJointConfig;
export const UniversalJoint = oimo.dynamics.constraint.joint.UniversalJoint;
export const RagdollJointConfig = oimo.dynamics.constraint.joint.RagdollJointConfig;
export const RagdollJoint = oimo.dynamics.constraint.joint.RagdollJoint;
export const GenericJointConfig = oimo.dynamics.constraint.joint.GenericJointConfig;
export const GenericJoint = oimo.dynamics.constraint.joint.GenericJoint;
export const JointConfig = oimo.dynamics.constraint.joint.JointConfig;
export const Joint = oimo.dynamics.constraint.joint.Joint;
export const SpringDamper = oimo.dynamics.constraint.joint.SpringDamper;
export const TranslationalLimitMotor = oimo.dynamics.constraint.joint.TranslationalLimitMotor;
export const RotationalLimitMotor = oimo.dynamics.constraint.joint.RotationalLimitMotor;

// Common
export const Vec3 = oimo.common.Vec3;
export const Quat = oimo.common.Quat;
export const Mat3 = oimo.common.Mat3;
export const Mat4 = oimo.common.Mat4;
export const MathUtil = oimo.common.MathUtil;
export const Transform = oimo.common.Transform;
export const Setting = oimo.common.Setting;

// Collision
export const BroadPhaseType = oimo.collision.broadphase.BroadPhaseType;
export const BoxGeometry = oimo.collision.geometry.BoxGeometry;
export const SphereGeometry = oimo.collision.geometry.SphereGeometry;
export const ConeGeometry = oimo.collision.geometry.ConeGeometry;
export const CylinderGeometry = oimo.collision.geometry.CylinderGeometry;
export const CapsuleGeometry = oimo.collision.geometry.CapsuleGeometry;
export const ConvexHullGeometry = oimo.collision.geometry.ConvexHullGeometry;
export const Geometry = oimo.collision.geometry.Geometry;

// Callback
export const RayCastClosest = oimo.dynamics.callback.RayCastClosest;
export const ContactCallback = oimo.dynamics.callback.ContactCallback;

// Defaults
Setting.defaultGJKMargin = 0.0001;

/**
 * A class for using the OimoPhysics 3D physics engine with an array buffer.
 */
export class OimoPhysicsBuffer {
    constructor({
        fps = 60,
        timestep = 1 / fps,
        broadphase = BroadPhaseType.BVH,
        gravity = new Vec3(0, -9.81, 0),
        velocityIterations = 8,
        positionIterations = 8
    } = {}) {
        this.timestep = timestep;

        this.world = new World(broadphase, gravity);
        this.world.setNumVelocityIterations(velocityIterations);
        this.world.setNumPositionIterations(positionIterations);

        this.bodies = [];
        this.map = new Map();
        this.array = new Float32Array();

        this.v1 = new Vec3();
        this.v2 = new Vec3();
        this.q = new Quat();
    }

    getShape({
        type,
        position,
        quaternion,
        size,
        density,
        friction,
        restitution,
        collisionMask,
        collisionGroup
    }) {
        const shapeConfig = new ShapeConfig();

        if (density !== undefined) {
            shapeConfig.density = density;
        }

        if (friction !== undefined) {
            shapeConfig.friction = friction;
        }

        if (restitution !== undefined) {
            shapeConfig.restitution = restitution;
        }

        if (collisionMask !== undefined) {
            shapeConfig.collisionMask = collisionMask;
        }

        if (collisionGroup !== undefined) {
            shapeConfig.collisionGroup = collisionGroup;
        }

        if (type === 'box') {
            shapeConfig.geometry = new BoxGeometry(new Vec3(size[0], size[1], size[2]));
        } else if (type === 'sphere') {
            shapeConfig.geometry = new SphereGeometry(size[0]);
        } else if (type === 'cone') {
            shapeConfig.geometry = new ConeGeometry(size[0], size[1]);
        } else if (type === 'cylinder') {
            shapeConfig.geometry = new CylinderGeometry(size[0], size[1]);
        } else if (type === 'capsule') {
            shapeConfig.geometry = new CapsuleGeometry(size[0], size[1]);
        } else if (type === 'convex') {
            const array = [];

            for (let i = 0, l = size.length; i < l; i += 3) {
                array.push(new Vec3(size[i], size[i + 1], size[i + 2]));
            }

            shapeConfig.geometry = new ConvexHullGeometry(array);
        }

        if (position !== undefined) {
            shapeConfig.position.copyFrom(new Vec3(position[0], position[1], position[2]));
        }

        if (quaternion !== undefined) {
            shapeConfig.rotation.fromQuat(new Quat(quaternion[0], quaternion[1], quaternion[2], quaternion[3]));
        }

        return new Shape(shapeConfig);
    }

    add(object) {
        if (object.type === 'joint') {
            return this.handleJoint(object);
        } else {
            return this.handleBody(object);
        }
    }

    get(name) {
        return this.map.get(name);
    }

    remove(name) {
        const object = this.map.get(name);

        if (object instanceof Joint) {
            this.world.removeJoint(object);
        } else if (object instanceof RigidBody) {
            this.world.removeRigidBody(object);
        }

        this.map.delete(name);
    }

    handleJoint({
        name,
        mode,
        body1,
        body2,
        position1,
        position2,
        worldAnchor,
        springDamper
    }) {
        let JointConfig;
        let Joint;

        if (mode === 'spherical') {
            JointConfig = SphericalJointConfig;
            Joint = SphericalJoint;
        } else if (mode === 'revolute') {
            JointConfig = RevoluteJointConfig;
            Joint = RevoluteJoint;
        } else if (mode === 'cylindrical') {
            JointConfig = CylindricalJointConfig;
            Joint = CylindricalJoint;
        } else if (mode === 'prismatic') {
            JointConfig = PrismaticJointConfig;
            Joint = PrismaticJoint;
        } else if (mode === 'universal') {
            JointConfig = UniversalJointConfig;
            Joint = UniversalJoint;
        } else if (mode === 'ragdoll') {
            JointConfig = RagdollJointConfig;
            Joint = RagdollJoint;
        } else if (mode === 'generic') {
            JointConfig = GenericJointConfig;
            Joint = GenericJoint;
        }

        const jointConfig = new JointConfig();
        jointConfig.rigidBody1 = this.map.get(body1);
        jointConfig.rigidBody2 = this.map.get(body2);

        if (worldAnchor) {
            const point = new Vec3(worldAnchor[0], worldAnchor[1], worldAnchor[2]);

            jointConfig.rigidBody1.getLocalPointTo(point, jointConfig.localAnchor1);
            jointConfig.rigidBody2.getLocalPointTo(point, jointConfig.localAnchor2);
        }

        if (position1) {
            jointConfig.localAnchor1.init(position1[0], position1[1], position1[2]);
        }

        if (position2) {
            jointConfig.localAnchor2.init(position2[0], position2[1], position2[2]);
        }

        if (springDamper) {
            jointConfig.springDamper.setSpring(springDamper[0], springDamper[1]); // frequency, dampingRatio
        }

        const joint = new Joint(jointConfig);
        this.world.addJoint(joint);

        this.map.set(name, joint);

        return joint;
    }

    handleBody({
        name,
        type,
        position,
        quaternion,
        size,
        density,
        friction,
        restitution,
        collisionMask,
        collisionGroup,
        gravityScale,
        linearVelocity,
        angularVelocity,
        linearDamping,
        angularDamping,
        autoSleep,
        kinematic,
        shapes
    }) {
        const bodyConfig = new RigidBodyConfig();

        if (autoSleep !== undefined) {
            bodyConfig.autoSleep = autoSleep;
        }

        if (kinematic !== undefined) {
            bodyConfig.type = RigidBodyType.KINEMATIC;
        } else if (density === 0 || type === undefined) {
            bodyConfig.type = RigidBodyType.STATIC;
        } else {
            bodyConfig.type = RigidBodyType.DYNAMIC;
        }

        const body = new RigidBody(bodyConfig);

        if (type !== undefined) {
            if (shapes !== undefined) {
                for (let i = 0; i < shapes.length; i++) {
                    const shape = shapes[i];

                    shape.density = density;
                    shape.friction = friction;
                    shape.restitution = restitution;
                    shape.collisionMask = collisionMask;
                    shape.collisionGroup = collisionGroup;

                    body.addShape(this.getShape(shape));
                }
            } else {
                body.addShape(this.getShape({
                    type,
                    size,
                    density,
                    friction,
                    restitution,
                    collisionMask,
                    collisionGroup
                }));
            }
        }

        if (position !== undefined) {
            body.setPosition(new Vec3(position[0], position[1], position[2]));
        }

        if (quaternion !== undefined) {
            body.setOrientation(new Quat(quaternion[0], quaternion[1], quaternion[2], quaternion[3]));
        }

        if (gravityScale !== undefined) {
            body.setGravityScale(gravityScale);
        }

        if (linearVelocity !== undefined) {
            body.setLinearVelocity(linearVelocity);
        }

        if (angularVelocity !== undefined) {
            body.setAngularVelocity(angularVelocity);
        }

        if (linearDamping !== undefined) {
            body.setLinearDamping(linearDamping);
        }

        if (angularDamping !== undefined) {
            body.setAngularDamping(angularDamping);
        }

        this.world.addRigidBody(body);

        if (density !== 0) {
            this.bodies.push(body);

            // Swap buffers
            const temp = this.array;
            this.array = new Float32Array(this.bodies.length * 8);
            this.array.set(temp);
        }

        this.map.set(name, body);

        return body;
    }

    setGravity(gravity) {
        this.world.setGravity(this.v1.init(gravity[0], gravity[1], gravity[2]));
    }

    setPosition(name, position) {
        const body = this.map.get(name);

        body.setPosition(this.v1.init(position[0], position[1], position[2]));
    }

    setOrientation(name, orientation) {
        const body = this.map.get(name);

        body.setOrientation(this.q.init(orientation[0], orientation[1], orientation[2], orientation[3]));
    }

    setGravityScale(name, gravityScale) {
        const body = this.map.get(name);

        body.setGravityScale(gravityScale);
    }

    setLinearVelocity(name, linearVelocity) {
        const body = this.map.get(name);

        body.setLinearVelocity(this.v1.init(linearVelocity[0], linearVelocity[1], linearVelocity[2]));
    }

    setAngularVelocity(name, angularVelocity) {
        const body = this.map.get(name);

        body.setAngularVelocity(this.v1.init(angularVelocity[0], angularVelocity[1], angularVelocity[2]));
    }

    setLinearDamping(name, linearDamping) {
        const body = this.map.get(name);

        body.setLinearDamping(this.v1.init(linearDamping[0], linearDamping[1], linearDamping[2]));
    }

    setAngularDamping(name, angularDamping) {
        const body = this.map.get(name);

        body.setAngularDamping(this.v1.init(angularDamping[0], angularDamping[1], angularDamping[2]));
    }

    setContactCallback(name, callback) {
        const body = this.map.get(name);

        const contactCallback = new ContactCallback();
        contactCallback.beginContact = contact => callback(body, name, contact);

        let shape = body.getShapeList();

        while (shape) {
            shape.setContactCallback(contactCallback);
            shape = shape.getNext();
        }
    }

    applyImpulse(name, impulse, positionInWorld) {
        const body = this.map.get(name);

        body.applyImpulse(this.v1.init(impulse[0], impulse[1], impulse[2]), this.v2.init(positionInWorld[0], positionInWorld[1], positionInWorld[2]));
    }

    wakeUp(name) {
        const body = this.map.get(name);

        body.wakeUp();
    }

    sleep(name) {
        const body = this.map.get(name);

        body.sleep();
    }

    step() {
        const array = this.array;

        this.world.step(this.timestep);

        let index = 0;

        for (let i = 0, l = this.bodies.length; i < l; i++) {
            const body = this.bodies[i];
            const position = body.getPosition();
            const quaternion = body.getOrientation();

            index = i * 8;

            if (body.isSleeping()) {
                array[index + 7] = 1;
            } else {
                array[index] = position.x;
                array[index + 1] = position.y;
                array[index + 2] = position.z;
                array[index + 3] = quaternion.x;
                array[index + 4] = quaternion.y;
                array[index + 5] = quaternion.z;
                array[index + 6] = quaternion.w;
                array[index + 7] = 0;
            }
        }
    }
}



---
File: /src/three/utils/physics/OimoPhysicsController.js
---

/**
 * @author pschroen / https://ufo.ai/
 *
 * Based on https://github.com/mrdoob/three.js/blob/66c460eca3c025678ff2bc0aa423f4ba10e9571e/examples/jsm/libs/OimoPhysics/index.js by VBT-YTokan
 * Based on https://github.com/mrdoob/three.js/blob/66c460eca3c025678ff2bc0aa423f4ba10e9571e/examples/jsm/physics/OimoPhysics.js by VBT-YTokan
 * Based on https://github.com/lo-th/phy
 */

import { Group, MathUtils, Matrix4 } from 'three';

/**
 * A controller class for using the {@link OimoPhysicsBuffer | OimoPhysicsBuffer}.
 */
export class OimoPhysicsController {
    constructor() {
        this.shapes = [];
        this.objects = [];
        this.map = new WeakMap();

        this.object = new Group();
        this.matrix = new Matrix4();
    }

    getObject(position, quaternion, scale, geometry, {
        name,
        density,
        friction,
        restitution,
        collisionMask,
        collisionGroup,
        gravityScale,
        linearVelocity,
        angularVelocity,
        linearDamping,
        angularDamping,
        autoSleep,
        kinematic,
        shapes
    }) {
        const object = {};

        if (name !== undefined) {
            object.name = name;
        } else {
            object.name = MathUtils.generateUUID();
        }

        if (position !== undefined) {
            object.position = position.toArray();
        }

        if (quaternion !== undefined) {
            object.quaternion = quaternion.toArray();
        }

        if (shapes !== undefined) {
            object.type = 'compound';
            object.shapes = [];

            for (let i = 0; i < shapes.length; i++) {
                const { position, quaternion, scale, geometry } = shapes[i];
                object.shapes.push(this.getObject(position, quaternion, scale, geometry, { name: `${object.name}_${i}` }));
            }
        } else if (geometry !== undefined) {
            const parameters = geometry.parameters;

            if (geometry.type === 'BoxGeometry') {
                const sx = parameters.width !== undefined ? (parameters.width * scale.x) / 2 : 0.5;
                const sy = parameters.height !== undefined ? (parameters.height * scale.y) / 2 : 0.5;
                const sz = parameters.depth !== undefined ? (parameters.depth * scale.z) / 2 : 0.5;

                object.type = 'box';
                object.size = [sx, sy, sz];
            } else if (geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry') {
                const radius = parameters.radius !== undefined ? parameters.radius * scale.x : 1;

                object.type = 'sphere';
                object.size = [radius];
            } else if (geometry.type === 'ConeGeometry') {
                const radius = parameters.radius !== undefined ? parameters.radius * scale.x : 1;
                const height = parameters.height !== undefined ? (parameters.height * scale.y) / 2 : 0.5;

                object.type = 'cone';
                object.size = [radius, height];
            } else if (geometry.type === 'CylinderGeometry') {
                const radius = parameters.radiusTop !== undefined ? parameters.radiusTop * scale.x : 1;
                const height = parameters.height !== undefined ? (parameters.height * scale.y) / 2 : 0.5;

                object.type = 'cylinder';
                object.size = [radius, height];
            } else if (geometry.type === 'CapsuleGeometry') {
                const radius = parameters.radius !== undefined ? parameters.radius * scale.x : 1;
                const height = parameters.length !== undefined ? (parameters.length * scale.y) / 2 : 0.5;

                object.type = 'capsule';
                object.size = [radius, height];
            } else if (geometry.type !== 'PlaneGeometry') {
                const vertices = geometry.getAttribute('position');
                const array = [];

                for (let i = 0; i < vertices.count; i++) {
                    array.push(
                        vertices.array[i * 3 + 0] * scale.x,
                        vertices.array[i * 3 + 1] * scale.y,
                        vertices.array[i * 3 + 2] * scale.z
                    );
                }

                object.type = 'convex';
                object.size = array;
            }
        }

        if (density !== undefined) {
            object.density = density;
        }

        if (friction !== undefined) {
            object.friction = friction;
        }

        if (restitution !== undefined) {
            object.restitution = restitution;
        }

        if (collisionMask !== undefined) {
            object.collisionMask = collisionMask;
        }

        if (collisionGroup !== undefined) {
            object.collisionGroup = collisionGroup;
        }

        if (gravityScale !== undefined) {
            object.gravityScale = gravityScale;
        }

        if (linearVelocity !== undefined) {
            object.linearVelocity = linearVelocity;
        }

        if (angularVelocity !== undefined) {
            object.angularVelocity = angularVelocity;
        }

        if (linearDamping !== undefined) {
            object.linearDamping = linearDamping;
        }

        if (angularDamping !== undefined) {
            object.angularDamping = angularDamping;
        }

        if (autoSleep !== undefined) {
            object.autoSleep = autoSleep;
        }

        if (kinematic !== undefined) {
            object.kinematic = kinematic;
        }

        return object;
    }

    getObjectBody(object, index = 0) {
        let body;

        if (object.isInstancedMesh) {
            body = this.map.get(object)[index];
        } else {
            body = this.map.get(object);
        }

        return body;
    }

    add(object, props) {
        if (object.geometry) {
            if (object.isInstancedMesh) {
                return this.handleInstancedMesh(object, object.geometry, props);
            } else {
                return this.handleMesh(object, object.geometry, props);
            }
        } else {
            return this.handleObject(object, props);
        }
    }

    get(object) {
        return this.map.get(object);
    }

    handleObject(object, props) {
        if (props === undefined) {
            props = object;
        }

        const body = this.getObject(null, null, null, null, props);
        this.shapes.push(body);

        if (object.isObject3D && props.density !== 0) {
            this.objects.push(object);
        }

        this.map.set(object, body);

        return body;
    }

    handleMesh(object, geometry, props) {
        if (object.parent && object.parent.isGroup) {
            object = object.parent;
        }

        if (props === undefined) {
            props = object;
        }

        const { position, quaternion, scale } = object;

        const body = this.getObject(position, quaternion, scale, geometry, props);
        this.shapes.push(body);

        if (props.density !== 0) {
            this.objects.push(object);
        }

        this.map.set(object, body);

        return body;
    }

    handleInstancedMesh(object, geometry, props = {}) {
        const bodies = [];
        const name = props.name || MathUtils.generateUUID();

        for (let i = 0; i < object.count; i++) {
            const { position, quaternion, scale } = this.object;

            object.getMatrixAt(i, this.matrix);
            this.matrix.decompose(position, quaternion, scale);

            props.name = `${name}_${i}`;

            const body = this.getObject(position, quaternion, scale, geometry, props);
            this.shapes.push(body);

            bodies.push(body);
        }

        if (props.density !== 0) {
            this.objects.push(object);
        }

        this.map.set(object, bodies);

        return bodies;
    }

    step(array) {
        let index = 0;

        for (let i = 0, il = this.objects.length; i < il; i++) {
            const object = this.objects[i];

            if (object.isInstancedMesh) {
                const bodies = this.map.get(object);

                for (let j = 0, jl = bodies.length; j < jl; j++) {
                    if (array[index + 7] !== 1) {
                        this.object.position.fromArray(array, index);
                        this.object.quaternion.fromArray(array, index + 3);
                        this.object.updateMatrix();

                        object.setMatrixAt(j, this.object.matrix);
                    }

                    index += 8;
                }

                object.instanceMatrix.needsUpdate = true;
                object.computeBoundingSphere();
            } else {
                if (array[index + 7] !== 1) {
                    object.position.fromArray(array, index);
                    object.quaternion.fromArray(array, index + 3);
                }

                index += 8;
            }
        }
    }
}



---
File: /src/three/utils/DrawBuffers.js
---

/**
 * @author pschroen / https://ufo.ai/
 *
 * Based on https://threejs.org/examples/#webgl_multiple_rendertargets by takahirox
 * Based on https://oframe.github.io/ogl/examples/?src=mrt.html by gordonnl
 * Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/motionBlurPass
 * Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/shader-replacement
 */

import { Color, HalfFloatType, InstancedBufferAttribute, Matrix4, WebGLRenderTarget } from 'three';

import { DrawBuffersMaterial } from '../materials/DrawBuffersMaterial.js';

/**
 * A class for rendering world positions, depth, and velocities in
 * screen UV space to draw buffers with MRT (Multiple Render Targets).
 */
export class DrawBuffers {
    constructor(renderer, scene, camera, channel, {
        interpolateGeometry = 1,
        smearIntensity = 1,
        cameraBlur = true
    } = {}) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.channel = channel;

        this.interpolateGeometry = interpolateGeometry;
        this.smearIntensity = smearIntensity;
        this.cameraBlur = cameraBlur;

        this.prevProjectionMatrix = new Matrix4();
        this.prevMatrixWorldInverse = new Matrix4();

        this.initialized = false;
        this.enabled = true;
        this.saveState = true;

        // Clear colors
        this.clearColor = new Color(0, 0, 0);
        this.currentClearColor = new Color();

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            type: HalfFloatType,
            count: 2
        });
    }

    setCamera(camera) {
        this.camera = camera;
    }

    setSize(width, height) {
        this.renderTarget.setSize(width, height);
    }

    update(renderTarget = this.renderTarget) {
        if (!this.enabled) {
            this.initialized = false;
            return;
        }

        if (!this.initialized) {
            this.prevProjectionMatrix.copy(this.camera.projectionMatrix);
            this.prevMatrixWorldInverse.copy(this.camera.matrixWorldInverse);
            this.initialized = true;
        }

        // Renderer state
        const currentRenderTarget = this.renderer.getRenderTarget();
        const currentBackground = this.scene.background;
        this.renderer.getClearColor(this.currentClearColor);
        const currentClearAlpha = this.renderer.getClearAlpha();

        // G-Buffer pass
        this.scene.background = null;
        this.renderer.setClearColor(this.clearColor, 1);

        this.scene.traverseVisible(this.setDrawBuffersMaterial);
        this.renderer.setRenderTarget(renderTarget);

        if (this.renderer.autoClear === false) {
            this.renderer.clear();
        }

        this.renderer.render(this.scene, this.camera);
        this.scene.traverseVisible(this.restoreOriginalMaterial);

        // Camera state for the next frame
        this.prevProjectionMatrix.copy(this.camera.projectionMatrix);
        this.prevMatrixWorldInverse.copy(this.camera.matrixWorldInverse);

        // Restore renderer settings
        this.scene.background = currentBackground;
        this.renderer.setClearColor(this.currentClearColor, currentClearAlpha);
        this.renderer.setRenderTarget(currentRenderTarget);
    }

    setDrawBuffersMaterial = object => {
        if (object.layers.isEnabled(this.channel)) {
            if (!object.drawBuffersInitialized) {
                object.prevMatrixWorld = object.matrixWorld.clone();

                if (object.isInstancedMesh) {
                    object.prevInstanceMatrix = new InstancedBufferAttribute(new Float32Array(object.instanceMatrix.array), 16);
                    object.geometry.setAttribute('instancePrevMatrix', object.prevInstanceMatrix);
                    object.drawBuffersMaterial = new DrawBuffersMaterial({ instancing: true });
                } else {
                    object.drawBuffersMaterial = new DrawBuffersMaterial();
                }

                object.drawBuffersInitialized = true;
            }

            object.originalMaterial = object.material;
            object.drawBuffersMaterial.uniforms.uPrevProjectionMatrix.value.copy(this.cameraBlur ? this.prevProjectionMatrix : this.camera.projectionMatrix);
            object.drawBuffersMaterial.uniforms.uPrevModelViewMatrix.value.multiplyMatrices(this.cameraBlur ? this.prevMatrixWorldInverse : this.camera.matrixWorldInverse, object.prevMatrixWorld);
            object.drawBuffersMaterial.uniforms.uInterpolateGeometry.value = this.interpolateGeometry;
            object.drawBuffersMaterial.uniforms.uSmearIntensity.value = this.smearIntensity;
            object.material = object.drawBuffersMaterial;
        }
    };

    restoreOriginalMaterial = object => {
        if (object.layers.isEnabled(this.channel)) {
            object.material = object.originalMaterial;

            // Current state for the next frame
            if (this.saveState) {
                object.prevMatrixWorld.copy(object.matrixWorld);

                if (object.isInstancedMesh) {
                    object.prevInstanceMatrix.copyArray(object.instanceMatrix.array);
                    object.prevInstanceMatrix.needsUpdate = true;
                }
            }
        }
    };

    destroy() {
        this.renderTarget.dispose();

        for (const prop in this) {
            this[prop] = null;
        }

        return null;
    }
}



---
File: /src/three/utils/Flowmap.js
---

/**
 * @author pschroen / https://ufo.ai/
 *
 * Based on https://oframe.github.io/ogl/examples/?src=mouse-flowmap.html by gordonnl
 */

import { GLSL3, HalfFloatType, Mesh, NoBlending, OrthographicCamera, RawShaderMaterial, Vector2 } from 'three';

import { getDoubleRenderTarget, getFullscreenTriangle } from '@alienkitty/space.js/three';

const vertexShader = /* glsl */ `
in vec3 position;
in vec2 uv;

out vec2 vUv;

void main() {
    vUv = uv;

    gl_Position = vec4(position, 1.0);
}
`;

const fragmentShader = /* glsl */ `
precision highp float;

uniform sampler2D tMap;

uniform float uFalloff;
uniform float uAlpha;
uniform float uDissipation;

uniform float uAspect;
uniform vec2 uMouse;
uniform vec2 uVelocity;

in vec2 vUv;

out vec4 FragColor;

void main() {
    vec4 color = texture(tMap, vUv) * uDissipation;

    vec2 cursor = vUv - uMouse;
    cursor.x *= uAspect;

    vec3 stamp = vec3(uVelocity * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(uVelocity)), 3.0));
    float falloff = smoothstep(uFalloff, 0.0, length(cursor)) * uAlpha;

    color.rgb = mix(color.rgb, stamp, falloff);

    FragColor = color;
}
`;

/**
 * A class for a mouse flowmap.
 */
export class Flowmap {
    constructor(renderer, {
        size = 128,
        falloff = 0.15,
        alpha = 1,
        dissipation = 0.98
    } = {}) {
        this.renderer = renderer;

        this.mouse = new Vector2();
        this.velocity = new Vector2();

        // Render targets
        this.mask = getDoubleRenderTarget(size, size, {
            type: HalfFloatType,
            depthBuffer: false
        });

        // Output uniform containing render target textures
        this.uniform = { value: this.mask.read.texture };

        // Flowmap material
        this.material = new RawShaderMaterial({
            glslVersion: GLSL3,
            uniforms: {
                tMap: this.uniform,

                uFalloff: { value: falloff },
                uAlpha: { value: alpha },
                uDissipation: { value: dissipation },

                // User needs to update these
                uAspect: { value: 1 },
                uMouse: { value: this.mouse },
                uVelocity: { value: this.velocity }
            },
            vertexShader,
            fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screenTriangle = getFullscreenTriangle();
        this.screen = new Mesh(this.screenTriangle, this.material);
        this.screen.frustumCulled = false;
    }

    update() {
        // Renderer state
        const currentRenderTarget = this.renderer.getRenderTarget();
        const currentAutoClear = this.renderer.autoClear;
        this.renderer.autoClear = false;

        this.renderer.setRenderTarget(this.mask.write);
        this.renderer.render(this.screen, this.screenCamera);
        this.mask.swap();

        this.uniform.value = this.mask.read.texture;

        // Restore renderer settings
        this.renderer.autoClear = currentAutoClear;
        this.renderer.setRenderTarget(currentRenderTarget);
    }

    destroy() {
        this.mask.dispose();
        this.material.dispose();
        this.screenTriangle.dispose();

        for (const prop in this) {
            this[prop] = null;
        }

        return null;
    }
}



---
File: /src/three/utils/Fluid.js
---

/**
 * @author pschroen / https://ufo.ai/
 *
 * Based on https://github.com/PavelDoGreat/WebGL-Fluid-Simulation
 * Based on https://oframe.github.io/ogl/examples/?src=post-fluid-distortion.html by gordonnl
 */

import {
    Color,
    GLSL3,
    HalfFloatType,
    Mesh,
    NearestFilter,
    NoBlending,
    OrthographicCamera,
    RGFormat,
    RawShaderMaterial,
    RedFormat,
    Vector2,
    WebGLRenderTarget
} from 'three';

import { getDoubleRenderTarget, getFullscreenTriangle } from '@alienkitty/space.js/three';

const baseVertexShader = /* glsl */ `
precision highp float;

in vec3 position;
in vec2 uv;

uniform vec2 texelSize;

out vec2 vUv;
out vec2 vL;
out vec2 vR;
out vec2 vT;
out vec2 vB;

void main () {
    vUv = uv;
    vL = vUv - vec2(texelSize.x, 0.0);
    vR = vUv + vec2(texelSize.x, 0.0);
    vT = vUv + vec2(0.0, texelSize.y);
    vB = vUv - vec2(0.0, texelSize.y);

    gl_Position = vec4(position, 1.0);
}
`;

const clearShader = /* glsl */ `
precision mediump float;
precision mediump sampler2D;

uniform sampler2D uTexture;
uniform float value;

in highp vec2 vUv;

out vec4 FragColor;

void main () {
    FragColor = value * texture(uTexture, vUv);
}
`;

const splatShader = /* glsl */ `
precision highp float;
precision highp sampler2D;

uniform sampler2D uTarget;
uniform float uAspect;
uniform vec3 color;
uniform vec2 point;
uniform float radius;

in vec2 vUv;

out vec4 FragColor;

void main () {
    vec2 p = vUv - point.xy;
    p.x *= uAspect;
    vec3 splat = exp(-dot(p, p) / radius) * color;
    vec3 base = texture(uTarget, vUv).xyz;

    FragColor = vec4(base + splat, 1.0);
}
`;

const advectionShader = /* glsl */ `
precision highp float;
precision highp sampler2D;

uniform sampler2D uVelocity;
uniform sampler2D uSource;
uniform vec2 texelSize;
uniform float dt;
uniform float dissipation;

in vec2 vUv;

out vec4 FragColor;

void main () {
    vec2 coord = vUv - dt * texture(uVelocity, vUv).xy * texelSize;

    FragColor = dissipation * texture(uSource, coord);
    FragColor.a = 1.0;
}
`;

const divergenceShader = /* glsl */ `
precision mediump float;
precision mediump sampler2D;

uniform sampler2D uVelocity;

in highp vec2 vUv;
in highp vec2 vL;
in highp vec2 vR;
in highp vec2 vT;
in highp vec2 vB;

out vec4 FragColor;

void main () {
    float L = texture(uVelocity, vL).x;
    float R = texture(uVelocity, vR).x;
    float T = texture(uVelocity, vT).y;
    float B = texture(uVelocity, vB).y;
    vec2 C = texture(uVelocity, vUv).xy;
    if (vL.x < 0.0) { L = -C.x; }
    if (vR.x > 1.0) { R = -C.x; }
    if (vT.y > 1.0) { T = -C.y; }
    if (vB.y < 0.0) { B = -C.y; }
    float div = 0.5 * (R - L + T - B);

    FragColor = vec4(div, 0.0, 0.0, 1.0);
}
`;

const curlShader = /* glsl */ `
precision mediump float;
precision mediump sampler2D;

uniform sampler2D uVelocity;

in highp vec2 vUv;
in highp vec2 vL;
in highp vec2 vR;
in highp vec2 vT;
in highp vec2 vB;

out vec4 FragColor;

void main () {
    float L = texture(uVelocity, vL).y;
    float R = texture(uVelocity, vR).y;
    float T = texture(uVelocity, vT).x;
    float B = texture(uVelocity, vB).x;
    float vorticity = R - L - T + B;

    FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
}
`;

const vorticityShader = /* glsl */ `
precision highp float;
precision highp sampler2D;

uniform sampler2D uVelocity;
uniform sampler2D uCurl;
uniform float curl;
uniform float dt;

in vec2 vUv;
in vec2 vL;
in vec2 vR;
in vec2 vT;
in vec2 vB;

out vec4 FragColor;

void main () {
    float L = texture(uCurl, vL).x;
    float R = texture(uCurl, vR).x;
    float T = texture(uCurl, vT).x;
    float B = texture(uCurl, vB).x;
    float C = texture(uCurl, vUv).x;
    vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
    force /= length(force) + 0.0001;
    force *= curl * C;
    force.y *= -1.0;
    vec2 vel = texture(uVelocity, vUv).xy;

    FragColor = vec4(vel + force * dt, 0.0, 1.0);
}
`;

const pressureShader = /* glsl */ `
precision mediump float;
precision mediump sampler2D;

uniform sampler2D uPressure;
uniform sampler2D uDivergence;

in highp vec2 vUv;
in highp vec2 vL;
in highp vec2 vR;
in highp vec2 vT;
in highp vec2 vB;

out vec4 FragColor;

void main () {
    float L = texture(uPressure, vL).x;
    float R = texture(uPressure, vR).x;
    float T = texture(uPressure, vT).x;
    float B = texture(uPressure, vB).x;
    float C = texture(uPressure, vUv).x;
    float divergence = texture(uDivergence, vUv).x;
    float pressure = (L + R + B + T - divergence) * 0.25;

    FragColor = vec4(pressure, 0.0, 0.0, 1.0);
}
`;

const gradientSubtractShader = /* glsl */ `
precision mediump float;
precision mediump sampler2D;

uniform sampler2D uPressure;
uniform sampler2D uVelocity;

in highp vec2 vUv;
in highp vec2 vL;
in highp vec2 vR;
in highp vec2 vT;
in highp vec2 vB;

out vec4 FragColor;

void main () {
    float L = texture(uPressure, vL).x;
    float R = texture(uPressure, vR).x;
    float T = texture(uPressure, vT).x;
    float B = texture(uPressure, vB).x;
    vec2 velocity = texture(uVelocity, vUv).xy;
    velocity.xy -= vec2(R - L, T - B);

    FragColor = vec4(velocity, 0.0, 1.0);
}
`;

/**
 * A class for fluid distortion.
 */
export class Fluid {
    constructor(renderer, {
        simRes = 128,
        dyeRes = 512,
        iterations = 3,
        densityDissipation = 0.97,
        velocityDissipation = 0.98,
        pressureDissipation = 0.8,
        curlStrength = 20,
        radius = 0.2
    } = {}) {
        this.renderer = renderer;
        this.simRes = simRes;
        this.dyeRes = dyeRes;
        this.iterations = iterations;
        this.densityDissipation = densityDissipation;
        this.velocityDissipation = velocityDissipation;
        this.pressureDissipation = pressureDissipation;
        this.curlStrength = curlStrength;
        this.radius = radius;

        this.splats = [];

        // Fluid simulation render targets
        this.density = getDoubleRenderTarget(dyeRes, dyeRes, {
            type: HalfFloatType,
            depthBuffer: false
        });

        this.velocity = getDoubleRenderTarget(simRes, simRes, {
            type: HalfFloatType,
            format: RGFormat,
            depthBuffer: false
        });

        this.pressure = getDoubleRenderTarget(simRes, simRes, {
            type: HalfFloatType,
            format: RedFormat,
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            depthBuffer: false
        });

        this.divergence = new WebGLRenderTarget(simRes, simRes, {
            type: HalfFloatType,
            format: RedFormat,
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            depthBuffer: false
        });

        this.curl = new WebGLRenderTarget(simRes, simRes, {
            type: HalfFloatType,
            format: RedFormat,
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            depthBuffer: false
        });

        // Output uniform containing render target textures
        this.uniform = { value: this.density.read.texture };

        // Common uniform
        const texelSize = { value: new Vector2(1 / simRes, 1 / simRes) };

        // Fluid simulation materials
        this.clearMaterial = new RawShaderMaterial({
            glslVersion: GLSL3,
            uniforms: {
                texelSize,
                uTexture: { value: null },
                value: { value: pressureDissipation }
            },
            vertexShader: baseVertexShader,
            fragmentShader: clearShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });

        this.splatMaterial = new RawShaderMaterial({
            glslVersion: GLSL3,
            uniforms: {
                texelSize,
                uTarget: { value: null },
                uAspect: { value: 1 },
                color: { value: new Color() },
                point: { value: new Vector2() },
                radius: { value: 1 }
            },
            vertexShader: baseVertexShader,
            fragmentShader: splatShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });

        this.advectionMaterial = new RawShaderMaterial({
            glslVersion: GLSL3,
            uniforms: {
                texelSize,
                dyeTexelSize: { value: new Vector2(1 / dyeRes, 1 / dyeRes) },
                uVelocity: { value: null },
                uSource: { value: null },
                dt: { value: 0.016 },
                dissipation: { value: 1 }
            },
            vertexShader: baseVertexShader,
            fragmentShader: advectionShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });

        this.divergenceMaterial = new RawShaderMaterial({
            glslVersion: GLSL3,
            uniforms: {
                texelSize,
                uVelocity: { value: null }
            },
            vertexShader: baseVertexShader,
            fragmentShader: divergenceShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });

        this.curlMaterial = new RawShaderMaterial({
            glslVersion: GLSL3,
            uniforms: {
                texelSize,
                uVelocity: { value: null }
            },
            vertexShader: baseVertexShader,
            fragmentShader: curlShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });

        this.vorticityMaterial = new RawShaderMaterial({
            glslVersion: GLSL3,
            uniforms: {
                texelSize,
                uVelocity: { value: null },
                uCurl: { value: null },
                curl: { value: curlStrength },
                dt: { value: 0.016 }
            },
            vertexShader: baseVertexShader,
            fragmentShader: vorticityShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });

        this.pressureMaterial = new RawShaderMaterial({
            glslVersion: GLSL3,
            uniforms: {
                texelSize,
                uPressure: { value: null },
                uDivergence: { value: null }
            },
            vertexShader: baseVertexShader,
            fragmentShader: pressureShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });

        this.gradientSubtractMaterial = new RawShaderMaterial({
            glslVersion: GLSL3,
            uniforms: {
                texelSize,
                uPressure: { value: null },
                uVelocity: { value: null }
            },
            vertexShader: baseVertexShader,
            fragmentShader: gradientSubtractShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });

        // Fullscreen triangle
        this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.screenTriangle = getFullscreenTriangle();
        this.screen = new Mesh(this.screenTriangle);
        this.screen.frustumCulled = false;
    }

    update() {
        const renderer = this.renderer;
        const simRes = this.simRes;
        const dyeRes = this.dyeRes;
        const iterations = this.iterations;
        const densityDissipation = this.densityDissipation;
        const velocityDissipation = this.velocityDissipation;
        const pressureDissipation = this.pressureDissipation;
        const curlStrength = this.curlStrength;
        const radius = this.radius;

        // Renderer state
        const currentRenderTarget = renderer.getRenderTarget();
        const currentAutoClear = renderer.autoClear;
        renderer.autoClear = false;

        // Render all of the inputs since the last frame
        for (let i = this.splats.length - 1; i >= 0; i--) {
            const { x, y, dx, dy } = this.splats.splice(i, 1)[0];

            this.splatMaterial.uniforms.uTarget.value = this.velocity.read.texture;
            this.splatMaterial.uniforms.point.value.set(x, y);
            this.splatMaterial.uniforms.color.value.set(dx, dy, 1);
            this.splatMaterial.uniforms.radius.value = radius / 100;
            this.screen.material = this.splatMaterial;
            renderer.setRenderTarget(this.velocity.write);
            renderer.render(this.screen, this.screenCamera);
            this.velocity.swap();

            this.splatMaterial.uniforms.uTarget.value = this.density.read.texture;
            this.screen.material = this.splatMaterial;
            renderer.setRenderTarget(this.density.write);
            renderer.render(this.screen, this.screenCamera);
            this.density.swap();
        }

        // Perform all of the fluid simulation renders
        this.curlMaterial.uniforms.uVelocity.value = this.velocity.read.texture;
        this.screen.material = this.curlMaterial;
        renderer.setRenderTarget(this.curl);
        renderer.render(this.screen, this.screenCamera);

        this.vorticityMaterial.uniforms.uVelocity.value = this.velocity.read.texture;
        this.vorticityMaterial.uniforms.uCurl.value = this.curl.texture;
        this.vorticityMaterial.uniforms.curl.value = curlStrength;
        this.screen.material = this.vorticityMaterial;
        renderer.setRenderTarget(this.velocity.write);
        renderer.render(this.screen, this.screenCamera);
        this.velocity.swap();

        this.divergenceMaterial.uniforms.uVelocity.value = this.velocity.read.texture;
        this.screen.material = this.divergenceMaterial;
        renderer.setRenderTarget(this.divergence);
        renderer.render(this.screen, this.screenCamera);

        this.clearMaterial.uniforms.uTexture.value = this.pressure.read.texture;
        this.clearMaterial.uniforms.value.value = pressureDissipation;
        this.screen.material = this.clearMaterial;
        renderer.setRenderTarget(this.pressure.write);
        renderer.render(this.screen, this.screenCamera);
        this.pressure.swap();

        this.pressureMaterial.uniforms.uDivergence.value = this.divergence.texture;

        for (let i = 0; i < iterations; i++) {
            this.pressureMaterial.uniforms.uPressure.value = this.pressure.read.texture;
            this.screen.material = this.pressureMaterial;
            renderer.setRenderTarget(this.pressure.write);
            renderer.render(this.screen, this.screenCamera);
            this.pressure.swap();
        }

        this.gradientSubtractMaterial.uniforms.uPressure.value = this.pressure.read.texture;
        this.gradientSubtractMaterial.uniforms.uVelocity.value = this.velocity.read.texture;
        this.screen.material = this.gradientSubtractMaterial;
        renderer.setRenderTarget(this.velocity.write);
        renderer.render(this.screen, this.screenCamera);
        this.velocity.swap();

        this.advectionMaterial.uniforms.dyeTexelSize.value.set(1 / simRes, 1 / simRes);
        this.advectionMaterial.uniforms.uVelocity.value = this.velocity.read.texture;
        this.advectionMaterial.uniforms.uSource.value = this.velocity.read.texture;
        this.advectionMaterial.uniforms.dissipation.value = velocityDissipation;
        this.screen.material = this.advectionMaterial;
        renderer.setRenderTarget(this.velocity.write);
        renderer.render(this.screen, this.screenCamera);
        this.velocity.swap();

        this.advectionMaterial.uniforms.dyeTexelSize.value.set(1 / dyeRes, 1 / dyeRes);
        this.advectionMaterial.uniforms.uVelocity.value = this.velocity.read.texture;
        this.advectionMaterial.uniforms.uSource.value = this.density.read.texture;
        this.advectionMaterial.uniforms.dissipation.value = densityDissipation;
        this.screen.material = this.advectionMaterial;
        renderer.setRenderTarget(this.density.write);
        renderer.render(this.screen, this.screenCamera);
        this.density.swap();

        this.uniform.value = this.density.read.texture;

        // Restore renderer settings
        renderer.autoClear = currentAutoClear;
        renderer.setRenderTarget(currentRenderTarget);
    }

    destroy() {
        this.density.dispose();
        this.velocity.dispose();
        this.pressure.dispose();
        this.divergence.dispose();
        this.curl.dispose();

        this.clearMaterial.dispose();
        this.splatMaterial.dispose();
        this.advectionMaterial.dispose();
        this.divergenceMaterial.dispose();
        this.curlMaterial.dispose();
        this.vorticityMaterial.dispose();
        this.pressureMaterial.dispose();
        this.gradientSubtractMaterial.dispose();

        this.screenTriangle.dispose();

        for (const prop in this) {
            this[prop] = null;
        }

        return null;
    }
}



---
File: /src/three/utils/MotionBlur.js
---

/**
 * @author pschroen / https://ufo.ai/
 *
 * Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/motionBlurPass
 * Based on https://github.com/gkjohnson/threejs-sandbox/tree/master/shader-replacement
 */

import { Color, HalfFloatType, InstancedBufferAttribute, Matrix4, WebGLRenderTarget } from 'three';

import { MotionBlurVelocityMaterial } from '../materials/MotionBlurVelocityMaterial.js';

/**
 * A class for per-object motion blur.
 */
export class MotionBlur {
    constructor(renderer, scene, camera, channel, {
        interpolateGeometry = 1,
        smearIntensity = 1,
        cameraBlur = true
    } = {}) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.channel = channel;

        this.interpolateGeometry = interpolateGeometry;
        this.smearIntensity = smearIntensity;
        this.cameraBlur = cameraBlur;

        this.prevProjectionMatrix = new Matrix4();
        this.prevMatrixWorldInverse = new Matrix4();

        this.initialized = false;
        this.enabled = true;
        this.saveState = true;

        // Clear colors
        this.clearColor = new Color(0, 0, 0);
        this.currentClearColor = new Color();

        // Render targets
        this.renderTarget = new WebGLRenderTarget(1, 1, {
            type: HalfFloatType
        });
    }

    setCamera(camera) {
        this.camera = camera;
    }

    setSize(width, height) {
        this.renderTarget.setSize(width, height);
    }

    update(renderTarget = this.renderTarget) {
        if (!this.enabled) {
            this.initialized = false;
            return;
        }

        if (!this.initialized) {
            this.prevProjectionMatrix.copy(this.camera.projectionMatrix);
            this.prevMatrixWorldInverse.copy(this.camera.matrixWorldInverse);
            this.initialized = true;
        }

        // Renderer state
        const currentRenderTarget = this.renderer.getRenderTarget();
        const currentBackground = this.scene.background;
        this.renderer.getClearColor(this.currentClearColor);
        const currentClearAlpha = this.renderer.getClearAlpha();

        // Velocity pass
        this.scene.background = null;
        this.renderer.setClearColor(this.clearColor, 1);

        this.scene.traverseVisible(this.setVelocityMaterial);
        this.renderer.setRenderTarget(renderTarget);

        if (this.renderer.autoClear === false) {
            this.renderer.clear();
        }

        this.renderer.render(this.scene, this.camera);
        this.scene.traverseVisible(this.restoreOriginalMaterial);

        // Camera state for the next frame
        this.prevProjectionMatrix.copy(this.camera.projectionMatrix);
        this.prevMatrixWorldInverse.copy(this.camera.matrixWorldInverse);

        // Restore renderer settings
        this.scene.background = currentBackground;
        this.renderer.setClearColor(this.currentClearColor, currentClearAlpha);
        this.renderer.setRenderTarget(currentRenderTarget);
    }

    setVelocityMaterial = object => {
        if (object.layers.isEnabled(this.channel)) {
            if (!object.velocityInitialized) {
                object.prevMatrixWorld = object.matrixWorld.clone();

                if (object.isInstancedMesh) {
                    object.prevInstanceMatrix = new InstancedBufferAttribute(new Float32Array(object.instanceMatrix.array), 16);
                    object.geometry.setAttribute('instancePrevMatrix', object.prevInstanceMatrix);
                    object.velocityMaterial = new MotionBlurVelocityMaterial({ instancing: true });
                } else {
                    object.velocityMaterial = new MotionBlurVelocityMaterial();
                }

                object.velocityInitialized = true;
            }

            object.originalMaterial = object.material;
            object.velocityMaterial.uniforms.uPrevProjectionMatrix.value.copy(this.cameraBlur ? this.prevProjectionMatrix : this.camera.projectionMatrix);
            object.velocityMaterial.uniforms.uPrevModelViewMatrix.value.multiplyMatrices(this.cameraBlur ? this.prevMatrixWorldInverse : this.camera.matrixWorldInverse, object.prevMatrixWorld);
            object.velocityMaterial.uniforms.uInterpolateGeometry.value = this.interpolateGeometry;
            object.velocityMaterial.uniforms.uSmearIntensity.value = this.smearIntensity;
            object.material = object.velocityMaterial;
        }
    };

    restoreOriginalMaterial = object => {
        if (object.layers.isEnabled(this.channel)) {
            object.material = object.originalMaterial;

            // Current state for the next frame
            if (this.saveState) {
                object.prevMatrixWorld.copy(object.matrixWorld);

                if (object.isInstancedMesh) {
                    object.prevInstanceMatrix.copyArray(object.instanceMatrix.array);
                    object.prevInstanceMatrix.needsUpdate = true;
                }
            }
        }
    };

    destroy() {
        this.renderTarget.dispose();

        for (const prop in this) {
            this[prop] = null;
        }

        return null;
    }
}



---
File: /src/three/utils/Reflector.js
---

/**
 * @author pschroen / https://ufo.ai/
 *
 * Based on https://github.com/mrdoob/three.js/blob/dev/examples/jsm/objects/Reflector.js by Slayvin
 */

import {
    Group,
    Matrix4,
    Mesh,
    OrthographicCamera,
    PerspectiveCamera,
    Plane,
    Vector3,
    Vector4,
    WebGLRenderTarget
} from 'three';

import { getDoubleRenderTarget, getFullscreenTriangle } from '@alienkitty/space.js/three';

import { ReflectorBlurMaterial } from '../materials/ReflectorBlurMaterial.js';

/**
 * A class for reflections.
 */
export class Reflector extends Group {
    constructor({
        width = 512,
        height = 512,
        clipBias = 0,
        blurIterations = 8
    } = {}) {
        super();

        this.clipBias = clipBias;
        this.blurIterations = blurIterations;

        this.reflectorPlane = new Plane();
        this.normal = new Vector3();
        this.reflectorWorldPosition = new Vector3();
        this.cameraWorldPosition = new Vector3();
        this.rotationMatrix = new Matrix4();
        this.lookAtPosition = new Vector3(0, 0, -1);
        this.clipPlane = new Vector4();

        this.view = new Vector3();
        this.target = new Vector3();
        this.q = new Vector4();

        this.textureMatrix = new Matrix4();
        this.virtualCamera = new PerspectiveCamera();

        // Uniform containing texture matrix
        this.textureMatrixUniform = { value: this.textureMatrix };

        // Render targets
        this.renderTarget = new WebGLRenderTarget(width, height);

        if (this.blurIterations > 0) {
            this.blur = getDoubleRenderTarget(1, 1, {
                depthBuffer: false
            });

            // Reflection blur material
            this.blurMaterial = new ReflectorBlurMaterial();
            this.blurMaterial.uniforms.uResolution.value.set(width, height);

            // Fullscreen triangle
            this.screenCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
            this.screenTriangle = getFullscreenTriangle();
            this.screen = new Mesh(this.screenTriangle, this.blurMaterial);
            this.screen.frustumCulled = false;
        }

        // Uniform containing render target textures
        this.renderTargetUniform = { value: this.blur ? this.blur.read.texture : this.renderTarget.texture };
    }

    setSize(width, height) {
        this.renderTarget.setSize(width, height);

        if (this.blur) {
            this.blur.setSize(width, height);

            this.blurMaterial.uniforms.uResolution.value.set(width, height);
        }
    }

    update(renderer, scene, camera) {
        this.reflectorWorldPosition.setFromMatrixPosition(this.matrixWorld);
        this.cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);

        this.rotationMatrix.extractRotation(this.matrixWorld);

        this.normal.set(0, 0, 1);
        this.normal.applyMatrix4(this.rotationMatrix);

        this.view.subVectors(this.reflectorWorldPosition, this.cameraWorldPosition);

        // Avoid rendering when reflector is facing away
        if (this.view.dot(this.normal) > 0) {
            return;
        }

        this.view.reflect(this.normal).negate();
        this.view.add(this.reflectorWorldPosition);

        this.rotationMatrix.extractRotation(camera.matrixWorld);

        this.lookAtPosition.set(0, 0, -1);
        this.lookAtPosition.applyMatrix4(this.rotationMatrix);
        this.lookAtPosition.add(this.cameraWorldPosition);

        this.target.subVectors(this.reflectorWorldPosition, this.lookAtPosition);
        this.target.reflect(this.normal).negate();
        this.target.add(this.reflectorWorldPosition);

        this.virtualCamera.position.copy(this.view);
        this.virtualCamera.up.set(0, 1, 0);
        this.virtualCamera.up.applyMatrix4(this.rotationMatrix);
        this.virtualCamera.up.reflect(this.normal);
        this.virtualCamera.lookAt(this.target);

        this.virtualCamera.far = camera.far; // Used in WebGLBackground

        this.virtualCamera.updateMatrixWorld();
        this.virtualCamera.projectionMatrix.copy(camera.projectionMatrix);

        // Update the texture matrix
        this.textureMatrix.set(
            0.5, 0.0, 0.0, 0.5,
            0.0, 0.5, 0.0, 0.5,
            0.0, 0.0, 0.5, 0.5,
            0.0, 0.0, 0.0, 1.0
        );

        this.textureMatrix.multiply(this.virtualCamera.projectionMatrix);
        this.textureMatrix.multiply(this.virtualCamera.matrixWorldInverse);
        this.textureMatrix.multiply(this.matrixWorld);

        // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
        // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
        this.reflectorPlane.setFromNormalAndCoplanarPoint(this.normal, this.reflectorWorldPosition);
        this.reflectorPlane.applyMatrix4(this.virtualCamera.matrixWorldInverse);

        this.clipPlane.set(this.reflectorPlane.normal.x, this.reflectorPlane.normal.y, this.reflectorPlane.normal.z, this.reflectorPlane.constant);

        const projectionMatrix = this.virtualCamera.projectionMatrix;

        this.q.x = (Math.sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
        this.q.y = (Math.sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
        this.q.z = -1;
        this.q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];

        // Calculate the scaled plane vector
        this.clipPlane.multiplyScalar(2 / this.clipPlane.dot(this.q));

        // Replacing the third row of the projection matrix
        projectionMatrix.elements[2] = this.clipPlane.x;
        projectionMatrix.elements[6] = this.clipPlane.y;
        projectionMatrix.elements[10] = this.clipPlane.z + 1 - this.clipBias;
        projectionMatrix.elements[14] = this.clipPlane.w;

        // Renderer state
        const currentRenderTarget = renderer.getRenderTarget();
        const currentXrEnabled = renderer.xr.enabled;
        const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
        renderer.xr.enabled = false; // Avoid camera modification
        renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows

        renderer.setRenderTarget(this.renderTarget);

        // Make sure the depth buffer is writable so it can be properly cleared
        // https://github.com/mrdoob/three.js/issues/18897
        renderer.state.buffers.depth.setMask(true);

        if (renderer.autoClear === false) {
            renderer.clear();
        }

        renderer.render(scene, this.virtualCamera);

        // Blur reflection
        if (this.blur) {
            const blurIterations = this.blurIterations;

            for (let i = 0; i < blurIterations; i++) {
                if (i === 0) {
                    this.blurMaterial.uniforms.tMap.value = this.renderTarget.texture;
                } else {
                    this.blurMaterial.uniforms.tMap.value = this.blur.read.texture;
                }

                const radius = (blurIterations - i - 1) * 0.5;
                this.blurMaterial.uniforms.uDirection.value.set(
                    i % 2 === 0 ? radius : 0,
                    i % 2 === 0 ? 0 : radius
                );

                renderer.setRenderTarget(this.blur.write);

                if (renderer.autoClear === false) {
                    renderer.clear();
                }

                renderer.render(this.screen, this.screenCamera);
                this.blur.swap();

                this.renderTargetUniform.value = this.blur.read.texture;
            }
        }

        // Restore renderer settings
        renderer.xr.enabled = currentXrEnabled;
        renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
        renderer.setRenderTarget(currentRenderTarget);
    }

    destroy() {
        this.renderTarget.dispose();

        if (this.blur) {
            this.blur.dispose();
            this.blurMaterial.dispose();
            this.screenTriangle.dispose();
        }

        for (const prop in this) {
            this[prop] = null;
        }

        return null;
    }
}



---
File: /src/three/utils/SoftShadows.js
---

/**
 * @author pschroen / https://ufo.ai/
 *
 * Based on https://threejs.org/examples/#webgl_shadowmap_pcss by spidersharma03
 */

import { ShaderChunk } from 'three';

/**
 * A three.js shader patch for PCSS (Percent Closer Soft-Shadows).
 */
export class SoftShadows {
    static init({
        size = 0.005,
        frustum = 3.75,
        near = 9.5,
        samples = 17,
        rings = 11
    } = {}) {
        let shader = ShaderChunk.shadowmap_pars_fragment;

        shader = shader.replace(
            '#ifdef USE_SHADOWMAP',
            /* glsl */ `
            #ifdef USE_SHADOWMAP

            #define LIGHT_WORLD_SIZE ${size.toFixed(3)}
            #define LIGHT_FRUSTUM_WIDTH ${frustum.toFixed(2)}
            #define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)
            #define NEAR_PLANE ${near.toFixed(1)}

            #define NUM_SAMPLES ${samples.toFixed(0)}
            #define NUM_RINGS ${rings.toFixed(0)}
            #define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES

            vec2 poissonDisk[NUM_SAMPLES];

            void initPoissonSamples(vec2 randomSeed) {
                float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);
                float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);

                // JSFiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
                float angle = rand(randomSeed) * PI2;
                float radius = INV_NUM_SAMPLES;
                float radiusStep = radius;

                for (int i = 0; i < NUM_SAMPLES; i++) {
                    poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);
                    radius += radiusStep;
                    angle += ANGLE_STEP;
                }
            }

            float penumbraSize(float zReceiver, float zBlocker) { // Parallel plane estimation
                return (zReceiver - zBlocker) / zBlocker;
            }

            float findBlocker(sampler2D shadowMap, vec2 uv, float zReceiver) {
                // This uses similar triangles to compute what
                // area of the shadow map we should search
                float searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;
                float blockerDepthSum = 0.0;
                int numBlockers = 0;

                for (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {
                    float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));
                    if (shadowMapDepth < zReceiver) {
                        blockerDepthSum += shadowMapDepth;
                        numBlockers++;
                    }
                }

                if (numBlockers == 0) return -1.0;

                return blockerDepthSum / float(numBlockers);
            }

            float PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {
                float sum = 0.0;
                float depth;
                #pragma unroll_loop_start
                for (int i = 0; i < NUM_SAMPLES; i++) {
                    depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * filterRadius));
                    if (zReceiver <= depth) sum += 1.0;
                }
                #pragma unroll_loop_end
                #pragma unroll_loop_start
                for (int i = 0; i < NUM_SAMPLES; i++) {
                    depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[i].yx * filterRadius));
                    if (zReceiver <= depth) sum += 1.0;
                }
                #pragma unroll_loop_end
                return sum / (2.0 * float(NUM_SAMPLES));
            }

            float PCSS(sampler2D shadowMap, vec4 coords) {
                vec2 uv = coords.xy;
                float zReceiver = coords.z; // Assumed to be eye-space z in this code

                initPoissonSamples(uv);

                // Blocker search
                float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);

                // There are no occluders so early out (this saves filtering)
                if (avgBlockerDepth == -1.0) return 1.0;

                // Penumbra size
                float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
                float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;

                // Filtering
                return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);
            }
            `
        );

        shader = shader.replace(
            '#if defined( SHADOWMAP_TYPE_PCF )',
            /* glsl */ `
            return PCSS(shadowMap, shadowCoord);

            #if defined( SHADOWMAP_TYPE_PCF )
            `
        );

        ShaderChunk.shadowmap_pars_fragment = shader;
    }
}



---
File: /src/three/utils/Text.js
---

/**
 * @author pschroen / https://ufo.ai/
 *
 * Based on https://oframe.github.io/ogl/examples/?src=msdf-text.html by gordonnl
 */

/**
 * A class for creating MSDF (Multichannel Signed Distance Fields) text buffers.
 */
export class Text {
    constructor({
        font,
        text,
        width = Infinity,
        align = 'left',
        size = 1,
        letterSpacing = 0,
        lineHeight = 1.4,
        wordSpacing = 0,
        wordBreak = false
    } = {}) {
        this.font = font;
        this.text = text;
        this.width = width;
        this.align = align;
        this.size = size;
        this.letterSpacing = letterSpacing;
        this.lineHeight = lineHeight;
        this.wordSpacing = wordSpacing;
        this.wordBreak = wordBreak;

        this.newline = /\n/;
        this.whitespace = /\s/;

        this.parseFont();
        this.createGeometry();
    }

    parseFont() {
        this.glyphs = {};
        this.font.chars.forEach(d => this.glyphs[d.char] = d);
    }

    createGeometry() {
        this.fontHeight = this.font.common.lineHeight;
        this.baseline = this.font.common.base;

        // Use baseline so that actual text height is as close to 'size' value as possible
        this.scale = this.size / this.baseline;

        // Strip spaces and newlines to get actual character length for buffers
        const chars = this.text.replace(/[ \n]/g, '');
        const numChars = chars.length;

        // Create output buffers
        this.buffers = {
            position: new Float32Array(numChars * 4 * 3),
            uv: new Float32Array(numChars * 4 * 2),
            id: new Float32Array(numChars * 4),
            index: new Uint16Array(numChars * 6)
        };

        // Set values for buffers that don't require calculation
        for (let i = 0; i < numChars; i++) {
            this.buffers.id.set([i, i, i, i], i * 4);
            this.buffers.index.set([i * 4, i * 4 + 2, i * 4 + 1, i * 4 + 1, i * 4 + 2, i * 4 + 3], i * 6);
        }

        this.layout();
    }

    layout() {
        const lines = [];

        let cursor = 0;

        let wordCursor = 0;
        let wordWidth = 0;
        let line = newLine();

        function newLine() {
            const line = {
                width: 0,
                glyphs: []
            };
            lines.push(line);
            wordCursor = cursor;
            wordWidth = 0;
            return line;
        }

        const maxTimes = 100;
        let count = 0;
        while (cursor < this.text.length && count < maxTimes) {
            count++;

            const char = this.text[cursor];

            // Skip whitespace at start of line
            if (!line.width && this.whitespace.test(char)) {
                cursor++;
                wordCursor = cursor;
                wordWidth = 0;
                continue;
            }

            // If newline char, skip to next line
            if (this.newline.test(char)) {
                cursor++;
                line = newLine();
                continue;
            }

            const glyph = this.glyphs[char] || this.glyphs[' '];

            // Find any applicable kern pairs
            if (line.glyphs.length) {
                const prevGlyph = line.glyphs[line.glyphs.length - 1][0];
                const kern = this.getKernPairOffset(glyph.id, prevGlyph.id) * this.scale;
                line.width += kern;
                wordWidth += kern;
            }

            // Add char to line
            line.glyphs.push([glyph, line.width]);

            // Calculate advance for next glyph
            let advance = 0;

            // If whitespace, update location of current word for line breaks
            if (this.whitespace.test(char)) {
                wordCursor = cursor;
                wordWidth = 0;

                // Add wordspacing
                advance += this.wordSpacing * this.size;
            } else {
                // Add letterspacing
                advance += this.letterSpacing * this.size;
            }

            advance += glyph.xadvance * this.scale;

            line.width += advance;
            wordWidth += advance;

            // If width defined
            if (line.width > this.width) {
                // If can break words, undo latest glyph if line not empty and create new line
                if (this.wordBreak && line.glyphs.length > 1) {
                    line.width -= advance;
                    line.glyphs.pop();
                    line = newLine();
                    continue;

                    // If not first word, undo current word and cursor and create new line
                } else if (!this.wordBreak && wordWidth !== line.width) {
                    const numGlyphs = cursor - wordCursor + 1;
                    line.glyphs.splice(-numGlyphs, numGlyphs);
                    cursor = wordCursor;
                    line.width -= wordWidth;
                    line = newLine();
                    continue;
                }
            }

            cursor++;

            // Reset infinite loop catch
            count = 0;
        }

        // Remove last line if empty
        if (!line.width) lines.pop();

        this.populateBuffers(lines);
    }

    populateBuffers(lines) {
        const texW = this.font.common.scaleW;
        const texH = this.font.common.scaleH;

        // For all fonts tested, a little offset was needed to be right on the baseline, hence 0.07
        let y = 0.07 * this.size;
        let j = 0;

        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            const line = lines[lineIndex];

            for (let i = 0; i < line.glyphs.length; i++) {
                const glyph = line.glyphs[i][0];
                let x = line.glyphs[i][1];

                if (this.align === 'center') {
                    x -= line.width * 0.5;
                } else if (this.align === 'right') {
                    x -= line.width;
                }

                // If space, don't add to geometry
                if (this.whitespace.test(glyph.char)) continue;

                // Apply char sprite offsets
                x += glyph.xoffset * this.scale;
                y -= glyph.yoffset * this.scale;

                // Each letter is a quad, axis bottom left
                const w = glyph.width * this.scale;
                const h = glyph.height * this.scale;
                this.buffers.position.set([x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0], j * 4 * 3);

                const u = glyph.x / texW;
                const uw = glyph.width / texW;
                const v = 1 - glyph.y / texH;
                const vh = glyph.height / texH;
                this.buffers.uv.set([u, v - vh, u, v, u + uw, v - vh, u + uw, v], j * 4 * 2);

                // Reset cursor to baseline
                y += glyph.yoffset * this.scale;

                j++;
            }

            y -= this.size * this.lineHeight;
        }

        this.numLines = lines.length;
        this.height = this.numLines * this.size * this.lineHeight;
        this.width = Math.max(...lines.map(line => line.width));
    }

    getKernPairOffset(id1, id2) {
        for (let i = 0; i < this.font.kernings.length; i++) {
            const k = this.font.kernings[i];
            if (k.first < id1) continue;
            if (k.second < id2) continue;
            if (k.first > id1) return 0;
            if (k.first === id1 && k.second > id2) return 0;
            return k.amount;
        }
        return 0;
    }

    // Update buffers with new layout
    resize({ width }) {
        this.width = width;
        this.layout();
    }

    // Completely change text (like creating new Text)
    update({ text }) {
        this.text = text;
        this.createGeometry();
    }
}



---
File: /src/three/utils/Wobble.js
---

/**
 * @author pschroen / https://ufo.ai/
 */

import { Vector3 } from 'three';

import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

/**
 * A class for applying Perlin noise to a position in 3D space,
 * with frequency, amplitude, scale, and linear interpolation parameters.
 */
export class Wobble {
    constructor(position) {
        this.position = position;

        this.origin = new Vector3();
        this.target = new Vector3();
        this.perlin = new ImprovedNoise();
        this.frequency = new Vector3(1, 1, 1);
        this.amplitude = new Vector3(1, 1, 1);
        this.scale = 1;
        this.lerpSpeed = 0.02;

        if (this.position) {
            this.origin.copy(this.position);
        }
    }

    update(time) {
        this.target.x = this.perlin.noise(time * this.frequency.x, 1, 1) * this.amplitude.x;
        this.target.y = this.perlin.noise(1, time * this.frequency.y, 1) * this.amplitude.y;
        this.target.z = this.perlin.noise(1, 1, time * this.frequency.z) * this.amplitude.z;

        this.target.multiplyScalar(this.scale);
        this.target.add(this.origin);

        if (this.position) {
            this.position.lerp(this.target, this.lerpSpeed);
        }
    }
}



---
File: /src/all.three.js
---

// Loaders
export { Loader } from '@alienkitty/space.js/src/loaders/Loader.js';
export { AssetLoader } from '@alienkitty/space.js/src/loaders/AssetLoader.js';
export { BufferLoader } from '@alienkitty/space.js/src/loaders/BufferLoader.js';
export { MultiLoader } from '@alienkitty/space.js/src/loaders/MultiLoader.js';
export { ImageBitmapLoader } from '@alienkitty/space.js/src/loaders/ImageBitmapLoader.js';
export { ImageBitmapLoaderThread } from '@alienkitty/space.js/src/loaders/ImageBitmapLoaderThread.js';
export { TextureLoader } from '@alienkitty/space.js/src/three/loaders/TextureLoader.js';
export { CubeTextureLoader } from '@alienkitty/space.js/src/three/loaders/CubeTextureLoader.js';
export { EnvironmentTextureLoader } from '@alienkitty/space.js/src/three/loaders/EnvironmentTextureLoader.js';
export { BufferGeometryLoader } from '@alienkitty/space.js/src/three/loaders/BufferGeometryLoader.js';
export { BufferGeometryLoaderThread } from '@alienkitty/space.js/src/three/loaders/BufferGeometryLoaderThread.js';

// Math
// export { Color } from '@alienkitty/space.js/src/math/Color.js';
// export { Vector2 } from '@alienkitty/space.js/src/math/Vector2.js';

// Path
export { SVGPathProperties } from '@alienkitty/space.js/src/path/SVGPathProperties.js';

// Tween
export * from '@alienkitty/space.js/src/tween/Ticker.js';
export * from '@alienkitty/space.js/src/tween/BezierEasing.js';
export { Easing } from '@alienkitty/space.js/src/tween/Easing.js';
export * from '@alienkitty/space.js/src/tween/Tween.js';

// Utils
export * from '@alienkitty/space.js/src/utils/Utils.js';
export { EventEmitter } from '@alienkitty/space.js/src/utils/EventEmitter.js';
export { Interface } from '@alienkitty/space.js/src/utils/Interface.js';
export { Stage } from '@alienkitty/space.js/src/utils/Stage.js';
export * from '@alienkitty/space.js/src/utils/Router.js';
export { Component } from '@alienkitty/space.js/src/utils/Component.js';
export { LinkedList } from '@alienkitty/space.js/src/utils/LinkedList.js';
export { ObjectPool } from '@alienkitty/space.js/src/utils/ObjectPool.js';
export { Cluster } from '@alienkitty/space.js/src/utils/Cluster.js';
export { Thread } from '@alienkitty/space.js/src/utils/Thread.js';
export * from '@alienkitty/space.js/src/three/utils/Utils3D.js';

// Audio
export { WebAudio } from '@alienkitty/space.js/src/audio/WebAudio.js';
export { WebAudioParam } from '@alienkitty/space.js/src/audio/WebAudioParam.js';
export { Sound } from '@alienkitty/space.js/src/audio/Sound.js';
export { WebAudio3D } from '@alienkitty/space.js/src/three/audio/WebAudio3D.js';
export { Sound3D } from '@alienkitty/space.js/src/three/audio/Sound3D.js';

// Panels
export { Panel } from '@alienkitty/space.js/src/panels/Panel.js';
export { PanelItem } from '@alienkitty/space.js/src/panels/PanelItem.js';
export { PanelLink } from '@alienkitty/space.js/src/panels/PanelLink.js';
export { PanelThumbnail } from '@alienkitty/space.js/src/panels/PanelThumbnail.js';
export { PanelGraph } from '@alienkitty/space.js/src/panels/PanelGraph.js';
export { PanelMeter } from '@alienkitty/space.js/src/panels/PanelMeter.js';
export { List } from '@alienkitty/space.js/src/panels/List.js';
export { ListToggle } from '@alienkitty/space.js/src/panels/ListToggle.js';
export { ListSelect } from '@alienkitty/space.js/src/panels/ListSelect.js';
export { Slider } from '@alienkitty/space.js/src/panels/Slider.js';
export { Toggle } from '@alienkitty/space.js/src/panels/Toggle.js';
export { Content } from '@alienkitty/space.js/src/panels/Content.js';
export { ColorPicker } from '@alienkitty/space.js/src/panels/ColorPicker.js';
export * from '@alienkitty/space.js/src/three/panels/Custom.js';
export * from '@alienkitty/space.js/src/three/panels/Options.js';
export * from '@alienkitty/space.js/src/three/panels/Panels.js';
export * from '@alienkitty/space.js/src/three/panels/Patches.js';

// UI
export { UI } from '@alienkitty/space.js/src/ui/UI.js';
export { Header } from '@alienkitty/space.js/src/ui/Header.js';
export { HeaderInfo } from '@alienkitty/space.js/src/ui/HeaderInfo.js';
export { Footer } from '@alienkitty/space.js/src/ui/Footer.js';
export { FooterTitle } from '@alienkitty/space.js/src/ui/FooterTitle.js';
export { NavTitle } from '@alienkitty/space.js/src/ui/NavTitle.js';
export { NavLink } from '@alienkitty/space.js/src/ui/NavLink.js';
export { Details } from '@alienkitty/space.js/src/ui/Details.js';
export { DetailsInfo } from '@alienkitty/space.js/src/ui/DetailsInfo.js';
export { DetailsTitle } from '@alienkitty/space.js/src/ui/DetailsTitle.js';
export { DetailsLink } from '@alienkitty/space.js/src/ui/DetailsLink.js';
export { DetailsButton } from '@alienkitty/space.js/src/ui/DetailsButton.js';
export { MuteButton } from '@alienkitty/space.js/src/ui/MuteButton.js';
export { AudioButton } from '@alienkitty/space.js/src/ui/AudioButton.js';
export { AudioButtonInfo } from '@alienkitty/space.js/src/ui/AudioButtonInfo.js';
export { DividerLine } from '@alienkitty/space.js/src/ui/DividerLine.js';
export { Info } from '@alienkitty/space.js/src/ui/Info.js';
export { Title } from '@alienkitty/space.js/src/ui/Title.js';
export { Link } from '@alienkitty/space.js/src/ui/Link.js';
export { Menu } from '@alienkitty/space.js/src/ui/Menu.js';
export { MenuItem } from '@alienkitty/space.js/src/ui/MenuItem.js';
export { Thumbnail } from '@alienkitty/space.js/src/ui/Thumbnail.js';
export { Graph } from '@alienkitty/space.js/src/ui/Graph.js';
export { GraphSegments } from '@alienkitty/space.js/src/ui/GraphSegments.js';
export { GraphLabel } from '@alienkitty/space.js/src/ui/GraphLabel.js';
export { GraphMarker } from '@alienkitty/space.js/src/ui/GraphMarker.js';
export { RadialGraph } from '@alienkitty/space.js/src/ui/RadialGraph.js';
export { RadialGraphCanvas } from '@alienkitty/space.js/src/ui/RadialGraphCanvas.js';
export { RadialGraphSegments } from '@alienkitty/space.js/src/ui/RadialGraphSegments.js';
export { RadialGraphSegmentsCanvas } from '@alienkitty/space.js/src/ui/RadialGraphSegmentsCanvas.js';
export { RadialGraphTracker } from '@alienkitty/space.js/src/ui/RadialGraphTracker.js';
export { RadialGraphContainer } from '@alienkitty/space.js/src/ui/RadialGraphContainer.js';
export { Meter } from '@alienkitty/space.js/src/ui/Meter.js';
export { LineCanvas } from '@alienkitty/space.js/src/ui/LineCanvas.js';
export { Reticle } from '@alienkitty/space.js/src/ui/Reticle.js';
export { ReticleCanvas } from '@alienkitty/space.js/src/ui/ReticleCanvas.js';
export { ReticleInfo } from '@alienkitty/space.js/src/ui/ReticleInfo.js';
export { Tracker } from '@alienkitty/space.js/src/ui/Tracker.js';
export { Point } from '@alienkitty/space.js/src/ui/Point.js';
export { PointInfo } from '@alienkitty/space.js/src/ui/PointInfo.js';
export { TargetNumber } from '@alienkitty/space.js/src/ui/TargetNumber.js';
export { Progress } from '@alienkitty/space.js/src/ui/Progress.js';
export { ProgressCanvas } from '@alienkitty/space.js/src/ui/ProgressCanvas.js';
export { Input } from '@alienkitty/space.js/src/ui/Input.js';
export { InputField } from '@alienkitty/space.js/src/ui/InputField.js';
export { InputTotal } from '@alienkitty/space.js/src/ui/InputTotal.js';
export { Point3D } from '@alienkitty/space.js/src/three/ui/Point3D.js';

// Extras
export { Smooth } from '@alienkitty/space.js/src/extras/Smooth.js';
export { SmoothSkew } from '@alienkitty/space.js/src/extras/SmoothSkew.js';
export { SmoothViews } from '@alienkitty/space.js/src/extras/SmoothViews.js';
export { Magnetic } from '@alienkitty/space.js/src/extras/Magnetic.js';

// Three
export * from './three/materials/Materials.js';
export { Wobble } from './three/utils/Wobble.js';
export { Flowmap } from './three/utils/Flowmap.js';
export { Fluid } from './three/utils/Fluid.js';
export { Reflector } from './three/utils/Reflector.js';
export { MotionBlur } from './three/utils/MotionBlur.js';
export { DrawBuffers } from './three/utils/DrawBuffers.js';
export { SoftShadows } from './three/utils/SoftShadows.js';
export { Text } from './three/utils/Text.js';

// Physics
export { OimoPhysics, RigidBodyConfig, RigidBodyType, SphericalJointConfig, UniversalJointConfig } from './three/utils/physics/OimoPhysics.js';
export { OimoPhysicsBuffer } from './three/utils/physics/OimoPhysicsBuffer.js';
export { OimoPhysicsController } from './three/utils/physics/OimoPhysicsController.js';

// Dependencies
export * from 'three';
export { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
export { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
export { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
export { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
export { OrbitControls } from 'three/addons/controls/OrbitControls.js';
export { MapControls } from 'three/addons/controls/MapControls.js';



---
File: /src/ogl.js
---

export * from './ogl/programs/Programs.js';



---
File: /src/three.js
---

export * from './three/materials/Materials.js';
export { Wobble } from './three/utils/Wobble.js';
export { Flowmap } from './three/utils/Flowmap.js';
export { Fluid } from './three/utils/Fluid.js';
export { Reflector } from './three/utils/Reflector.js';
export { MotionBlur } from './three/utils/MotionBlur.js';
export { DrawBuffers } from './three/utils/DrawBuffers.js';
export { SoftShadows } from './three/utils/SoftShadows.js';
export { Text } from './three/utils/Text.js';



---
File: /src/three.oimophysics.js
---

export * from './three/utils/physics/OimoPhysics.js';
export { OimoPhysicsBuffer } from './three/utils/physics/OimoPhysicsBuffer.js';
export { OimoPhysicsController } from './three/utils/physics/OimoPhysicsController.js';



---
File: /eslint.config.js
---

import globals from 'globals';
import js from '@eslint/js';
import html from 'eslint-plugin-html';

export default [
  js.configs.recommended,
  {
    files: ['**/*.js', '**/*.html'],
    ignores: [
      'eslint.config.js',
      '**/rollup.config.js',
      '**/public/assets/js/*.js'
    ],
    plugins: {
      html
    },
    languageOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      globals: {
        ...globals.browser
      }
    },
    rules: {
      'arrow-parens': ['error', 'as-needed'],
      'arrow-spacing': ['error', { 'before': true, 'after': true }],
      'comma-dangle': ['warn', 'never'],
      'comma-spacing': ['error', { 'before': false, 'after': true }],
      'curly': ['error', 'multi-line'],
      'eqeqeq': ['error', 'always'],
      'indent': ['error', 4, { 'SwitchCase': 1, 'ignoredNodes': ['TemplateLiteral *'] }],
      'key-spacing': ['error', { 'beforeColon': false, 'afterColon': true }],
      'keyword-spacing': ['error', { 'before': true, 'after': true }],
      'linebreak-style': ['error', 'unix'],
      'lines-between-class-members': ['error', 'always', { 'exceptAfterSingleLine': true }],
      'new-parens': 'error',
      'no-inner-declarations': 'off',
      'no-return-await': 'error',
      'object-curly-spacing': ['error', 'always'],
      'object-shorthand': ['error', 'always'],
      'one-var': ['error', { 'initialized': 'never' }],
      'padded-blocks': ['error', 'never'],
      'prefer-arrow-callback': 'error',
      'prefer-const': ['error', { 'destructuring': 'any' }],
      'quotes': ['error', 'single'],
      'semi-spacing': ['error', { 'before': false, 'after': true }],
      'semi': ['error', 'always'],
      'sort-imports': ['warn', { 'ignoreDeclarationSort': true }],
      'space-before-blocks': ['error', 'always'],
      'space-before-function-paren': ['error', { 'anonymous': 'always', 'named': 'never', 'asyncArrow': 'always' }],
      'space-in-parens': ['error', 'never'],
      'space-infix-ops': 'error',
      'space-unary-ops': ['error', { 'words': true, 'nonwords': false }]
    }
  }
];

