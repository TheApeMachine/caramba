# Meeting Notes: MOSAIC Event-Driven Architecture & Phase 2 Planning

**Date:** 2026-01-02
**Topic:** MOSAIC Architecture, Event-Driven Implementation, Commitment Lifecycle

## 1. Meeting Summary
The team confirmed the successful architectural pivot of **MOSAIC** from a standard token-based language model to an **Event-Driven Organism**. The "Phase 1" implementation—comprising the Event Bus, Event Encoders/Decoders, and the Differentiable VM (Virtual Machine) with soft control surfaces—was validated through a successful training run which saw loss converge to **0.36**.

Following this validation, the team defined the specifications for **Phase 2: The Negotiating Organism**. The focus of Phase 2 is to implement a "Commitment Lifecycle," enabling the model to track obligations (Open/Close loops) during multi-turn negotiations. The team agreed to implement this via **meta-fields** on existing events rather than distinct event types.

───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

                                                                                Phase 2: Commitment Lifecycle — Implementation Spec

Goal: Teach the model to track open/close commitments during multi-turn interactions.

───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
                                                                                          1. Schema Update: core/event.py

Add two fields to EventEnvelope:


 @dataclass(frozen=True, slots=True)
 class EventEnvelope:
     # ... existing fields ...

     # Phase 2: Commitment tracking
     commitment_delta: int = 0          # +1 (open), -1 (close), 0 (neutral)
     commitment_id: str | None = None   # UUID linking open/close pairs


Changes required:

 • Add fields with defaults
 • Update to_json_dict(): serialize new fields (skip commitment_id if None)
 • Update from_json_dict(): parse new fields with validation (commitment_delta ∈ {-1, 0, 1})

───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
                                                                                       2. Codec Update: core/event_codec.py

No code changes needed — the codec serializes the full JSON dict, so new fields are automatically included.

───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
                                                                                      3. Model Update: layer/mosaic/block.py

Add a commitment head:


 # In MosaicBlockLayerConfig
 commitment_head_enabled: bool = False

 # In MosaicBlockLayer.__init__
 if cfg.commitment_head_enabled:
     self.commitment_head = nn.Linear(cfg.d_model, 3)  # [close, neutral, open]

 # In forward(), emit to ctx.mosaic_aux_out:
 if hasattr(self, 'commitment_head'):
     ctx.mosaic_aux_out["mosaic_commitment_logits"] = self.commitment_head(x)  # (B, T, 3)


───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
                                                                                    4. Objective Update: trainer/objectives.py

Add commitment loss to MosaicNextTokenWithAuxObjective:


 # New init parameter
 aux_commitment_weight: float = 0.0

 # In loss():
 tc = _maybe_get(batch, "mosaic_teacher_commitment_delta")
 pc = _maybe_get(outputs, "mosaic_commitment_logits")
 if (
     self.aux_commitment_weight > 0.0
     and isinstance(tc, Tensor)
     and isinstance(pc, Tensor)
     and pc.ndim == 3
     and tc.shape == pc.shape[:2]
 ):
     # Map delta {-1, 0, 1} → class indices {0, 1, 2}
     labels = (tc.long() + 1).clamp(0, 2)
     ce = F.cross_entropy(
         pc.float().view(-1, 3),
         labels.view(-1),
         ignore_index=-100,  # positions where teacher is masked
     )
     loss = loss + self.aux_commitment_weight * ce

 # In metrics():
 # Add aux_commitment_ce, aux_commitment_weighted


───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
                                                                                      5. Dataset Update: data/event_trace.py

Extend _EventTraceBuilder with commitment tracking:


 # New field in builder
 self.commitment_delta: list[int] = []

 # In _append_token():
 self.commitment_delta.append(int(cd))  # new param cd: int = 0

 # In append_event():
 # Add new parameter: commitment_delta: int = 0
 # Apply to token span (similar to opcode_span)


New trace pattern (negotiation curriculum):


 # In __getitem__():
 # After write phase, add negotiation events:

 # 1. Agent accepts task (commitment opens)
 env_accept = EventEnvelope(
     type="Message",
     sender="agent",
     payload={"text": "I will look for that file"},
     commitment_delta=+1,
     commitment_id=f"{idx:08x}c{j:02x}",
     ...
 )
 # Supervise: commitment_delta=+1 on the text span

 # 2. Agent works (neutral)
 # ... tool calls, intermediate events ...
 # Supervise: commitment_delta=0

 # 3. Agent completes (commitment closes)
 env_complete = EventEnvelope(
     type="Message",
     sender="agent",
     payload={"text": "Here is the content"},
     commitment_delta=-1,
     commitment_id=f"{idx:08x}c{j:02x}",  # same ID as open
     ...
 )
 # Supervise: commitment_delta=-1 on the text span


Output tensor:


 out["mosaic_teacher_commitment_delta"] = torch.tensor(b.commitment_delta[:-1], dtype=torch.long)


Masking: Use -100 for tokens outside commitment-relevant spans.

───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
                                                                                6. New Preset: config/presets/mosaic_commitment.yml


 version: 2
 name: mosaic_commitment
 notes: |
   Phase 2: Commitment lifecycle training.
   Model learns to open/close commitments during multi-turn negotiations.

 vars:
   d_model: 256
   n_layers: 4
   vocab_size: 2048
   block_size: 512  # longer for multi-turn
   mem_buckets: 4096
   mem_hashes: 2

 targets:
   - type: experiment
     name: mosaic_commitment_train
     backend: torch

     model:
       type: model.mosaic_lm
       d_model: ${d_model}
       n_layers: ${n_layers}
       vocab_size: ${vocab_size}
       block_size: ${block_size}
       mem_buckets: ${mem_buckets}
       mem_hashes: ${mem_hashes}
       commitment_head_enabled: true  # NEW

     objective:
       type: objective.mosaic_event_prediction
       aux_opcode_weight: 0.1
       aux_commitment_weight: 0.1  # NEW

     dataset:
       type: dataset.mosaic_event_traces
       block_size: ${block_size}
       n_pairs: 3
       distractor_events: 4
       negotiation_pairs: 2  # NEW: number of commitment open/close cycles
       sleep_replay_per_pair: 1


───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
                                                                                              7. File Change Summary


  File                                   Action
 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  core/event.py                          Add commitment_delta, commitment_id fields
  config/layer.py                        Add commitment_head_enabled: bool to MosaicBlockLayerConfig
  layer/mosaic/block.py                  Add commitment head + logit emission
  trainer/objectives.py                  Add aux_commitment_weight + loss + metrics
  data/event_trace.py                    Add commitment tracking to builder + negotiation curriculum
  config/presets/mosaic_commitment.yml   New preset
  runtime/engine/torch_engine.py         Register new preset (if not auto-discovered)


───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
                                                                                         8. Acceptance Criteria (Phase 2)

 1 Runtime: caramba run mosaic_commitment completes without errors
 2 Learning: aux_commitment_ce decreases over training
 3 Behavior: On negotiation traces, model predicts +1 at "I will do X" and -1 at "Here is the result"

───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Team consensus: This is a minimal, testable extension. No architectural changes to MOSAIC core—just a new head and supervision signal, following the exact pattern established in Phase 1.                         

## 2. Key Ideas & Consensus

### A. Events vs. Tokens (The Paradigm Shift)
*   **Concept:** The model's external interface is exclusively **Event-based** (JSON envelopes), while the internal compute substrate still operates on discrete steps (effectively "tokens" or "VM time-steps").
*   **Consensus:** **Strong Consensus**.
*   **Details:**
    *   **Claude** clarified that the MOSAIC core is event-agnostic; the change is in the I/O layer.
    *   **Gemini** and **ChatGPT** aligned on "Event-Native training from Day 1" rather than bootstrapping with pure text.
    *   **Architecture:** `Event -> Encoder -> Latent Steps -> MOSAIC Core -> Decoder -> Response Event`.

### B. Phase 1 Verification (Acceptance Tests)
*   **Concept:** Validation of the code changes made to support the event architecture and differentiable VM.
*   **Consensus:** **Passed**.
*   **Results:**
    *   **Acceptance A (Runtime):** Passed. No crashes on consumer hardware (12-24GB VRAM constraint respected).
    *   **Acceptance B (Learning):** Passed. Loss dropped from initialization to **0.36**, indicating gradients are flowing through the Event Encoder, Opcode Heads, and Memory Gates.
    *   **Acceptance C (Memory Behavior):** Passed (inferred). The low loss on the associative recall dataset implies the model is correctly using `WRITE_MEM` and `READ_MEM` opcodes.

### C. Phase 2: Commitment Representation
*   **Concept:** How to teach the model to track "promises" (e.g., "I will find that file" = Open Loop).
*   **Consensus:** **Strong Consensus** on using **Meta-Fields**.
*   **Arguments:**
    *   **Gemini** and **ChatGPT** argued that a commitment is a property of a speech act (e.g., a message), not necessarily a separate atomic event.
    *   **Decision:** Add `commitment_delta` (`+1`, `0`, `-1`) and `commitment_id` fields to the standard `EventEnvelope`.

### D. Canonical Code Structure
*   **Status:** Resolved.
*   **Decision:** `layer/mosaic/memory.py` is the canonical memory implementation. Legacy files (`layer/mosaic_memory.py`, `layer/mosaic_state.py`) were slated for deletion/deprecation to prevent duplication.

## 3. Action Items / Next Steps (Phase 2 Work Order)

The team agreed on a strict "Work Order" for the implementation team to execute Phase 2.

### Core Schema Updates
*   [ ] **Modify `core/event.py`**: Update the `EventEnvelope` dataclass to include:
    *   `commitment_delta: int = 0` (Values: `-1` for close, `0` neutral, `+1` for open).
    *   `commitment_id: str | None = None` (UUID linking open/close pairs).

### Model & Configuration Updates
*   [ ] **Update `config/layer.py`**: Add `commitment_head_enabled: bool = False`.
*   [ ] **Update `layer/mosaic/block.py`**: Implement the **Commitment Head**:
    *   A linear projection (`d_model` → 3 logits) to predict the commitment state.
    *   Output stored in `ctx.mosaic_aux_out["mosaic_commitment_logits"]`.

### Training Objectives
*   [ ] **Update `trainer/objectives.py`**: Add `aux_commitment_weight`.
*   [ ] **Implement Loss**: CrossEntropy loss between the new logits and `mosaic_teacher_commitment_delta` (mapping `{-1, 0, 1}` to class indices).

### Dataset & Curriculum
*   [ ] **Update `data/event_trace.py`**: Extend the builder to track commitments.
*   [ ] **Create Negotiation Scenarios**: Generate synthetic traces where:
    1.  Agent accepts task ("I will...") → `delta=+1`
    2.  Agent works (Tools) → `delta=0`
    3.  Agent resolves ("Here is...") → `delta=-1`

### Execution
*   [ ] **Create Preset**: `config/presets/mosaic_commitment.yml` (based on `mosaic_event_native` but with commitment heads enabled).
*   [ ] **Validation**: Run `caramba run mosaic_commitment` and verify `aux_commitment_ce` loss trends downward.