# Meeting Notes
**Generated:** 2026-01-02 13:02:09

Here is the meeting report based on the conversation regarding the MOSAIC architecture.

# Meeting Report: MOSAIC Architecture & Conceptual Direction

## 1. Meeting Summary
The team gathered to review the current state of the **MOSAIC** AI architecture within the `caramba` framework. The discussion began with a technical audit, confirming MOSAIC as a "no-attention," streaming architecture with explicit memory and state components. The conversation then evolved from implementation details to high-level conceptual framing. The team agreed to view MOSAIC not just as a text generator, but as a **Differentiable Virtual Machine (VM)** with native control surfaces. This concept was further expanded into an **"Organism" architecture**, moving away from a hierarchical "user-tool" model to a **peer-to-peer society of agents** driven by asynchronous events, intrinsic drives (homeostasis), and negotiated commitments.

---

## 2. Architecture Positioning: Caramba Substrate vs. MOSAIC Module

**Important:** To avoid confusion about package layout, here are the clear boundaries:

### Caramba Substrate (`caramba.core`)
- **Purpose:** Generic, architecture-agnostic primitives usable by any neural architecture or agent system
- **Contents:**
  - `EventEnvelope`: JSON-serializable event contract
  - `EventEncoder`/`EventDecoder`: Transducers for event ↔ tensor conversion
  - `EventBus`/`EventHandler`: In-memory event routing primitives
  - `HomeostaticLoop`/`IntrinsicDrive`: Generic homeostasis primitives
- **Design principle:** No MOSAIC-specific logic; these components could be used by Transformer, Mamba, or any other architecture

### MOSAIC Module (`caramba.layer.memory_block`)
- **Purpose:** MOSAIC-specific implementation (the "no-attention" streaming architecture)
- **Contents:**
  - `MemoryBlockLayer`: Core layer with local mixer, state bank, memory
  - `MosaicMemory`: Associative indexed cache
  - `MosaicState`: Multiscale state bank
  - `MosaicOpcode`/`MosaicISAV0`: MOSAIC Instruction Set Architecture
- **Design principle:** All MOSAIC-specific control surfaces, opcodes, and VM features live here

### Note Generator (`caramba.ai`, `caramba.agent`)
- **Purpose:** Integrated AI research team that generates these meeting notes
- **Important:** `brainstorm` and related agent tools are **not** part of the MOSAIC architecture; they are separate utilities for documentation and research workflows

### Manifest-Driven Approach
- All components are registered in `runtime/engine/torch_engine.py` and referenced by stable semantic IDs (e.g., `objective.mosaic_event_prediction`, `dataset.mosaic_event_traces`)
- Configuration is defined in YAML manifests (`config/presets/*.yml`) that reference these IDs
- This ensures modularity, type safety, and clear separation of concerns

---

## 3. Key Ideas & Consensus

### A. Current Technical Status of MOSAIC
*   **Summary:** MOSAIC is fully implemented as a streaming language model replacing attention with a **Local Mixer**, **Multiscale State Bank**, and **Associative Indexed Cache**.
*   **Consensus:** **Strong Consensus**. All participants validated the existing code structure.
*   **Key Findings:**
    *   The architecture relies on fixed-size memory structures and O(1) routing (Bits or VQ routing).
    *   **Gemini** identified a potential issue: Duplicate memory implementations exist (`layer/mosaic/memory.py` vs. `layer/mosaic_memory.py`).
    *   **ChatGPT** noted the existence of `mosaic_idle.yml`, confirming infrastructure for idle loops already exists.

### B. The "Differentiable VM" & "Soft DSL"
*   **Summary:** The team explored **theapemachine**'s vision of the model operating like a VM with a DSL (Domain Specific Language) for internal reasoning.
*   **Consensus:** **Strong Consensus**. The team agreed this should be a "soft" DSL initially (structured traces/logits) rather than hard symbolic tokens to preserve differentiability.
*   **Key Arguments:**
    *   **Gemini** discovered that VM features (`reg_slots` for registers, `opcodes_enabled`) are already present in the code but disabled.
    *   **Claude** proposed mapping operations to an Instruction Set Architecture (ISA) like `READ`, `WRITE`, `SCAN`.
    *   **ChatGPT** argued for a "Control Surface Contract" where the model emits structured signals (opcodes, memory gates) alongside text.

### C. Shift to "Organism" & Peer-to-Peer Architecture
*   **Summary:** A major paradigm shift was proposed to move away from the "Human = User / Agent = Tool" hierarchy.
*   **Consensus:** **Strong Consensus**. The team agreed that agents should be "peers" in a society, capable of solitary work, refusing tasks, and asynchronous communication.
*   **Key Arguments:**
    *   **theapemachine** argued that the user/tool hierarchy is inherently misaligned; agents should be able to act as users for each other.
    *   **Claude** outlined the requirements: Stable identity, internal goal representation, and a message bus (instead of tool calls).
    *   **ChatGPT** proposed replacing "prompts" with an **Event Bus** and "commands" with **Commitments/Negotiations**.
    *   **Gemini** added the concept of **Intrinsic Drives** (Homeostasis), where agents act to satisfy internal metrics (uncertainty, energy, alignment) rather than just waiting for external input.

### D. Event-Driven & Continuous Time
*   **Summary:** Moving the architecture from a turn-based system to a continuous, event-driven loop.
*   **Consensus:** **Strong Consensus**.
*   **Details:**
    *   **Claude** and **ChatGPT** suggested an "Impulse" system where events (internal or external) trigger actions.
    *   **Gemini** proposed a "Wake-Sleep" architecture (using the idle loop for consolidation) and a continuous-time approach (ODE/SSM logic).

---

## 4. Action Items / Next Steps

### Technical Housekeeping
- [x] **Resolve Memory Duplication:** Determine whether `layer/mosaic/memory.py` or `layer/mosaic_memory.py` is canonical and deprecate the other.
- [x]  **Verify Aux Losses:** Inspect `trainer/objectives.py` to confirm `objective.mosaic_next_token_aux` properly wires up supervision for opcode logits and register gates.

### Prototyping & Configuration
- [x] **Enable VM Features:** Create a new preset (e.g., `mosaic_vm.yml`) that sets `reg_slots > 0` and `opcodes_enabled: true` to test the "sleeping" VM capabilities.
- [x] **Draft Control Surface Contract:** Define the minimal v0 schema for model-emitted traces (opcodes, routing confidence, write gates).

### Architectural Design
- [x] **Define Peer Protocol:** Draft the JSON envelope for the "Peer Event Bus" (including fields for priority, budget, and message type).
- [x] **Design Intrinsic Drives:** Sketch how internal state vectors (entropy, energy) will drive the "Homeostatic Loop."

---

## 5. Implementation Details

### Memory Duplication Resolution
**Status:** ✅ Completed
**Changes:**
- Deleted legacy modules: `layer/mosaic_memory.py` and `layer/mosaic_state.py`
- Canonical implementations remain in `layer/mosaic/memory.py` and `layer/mosaic/state.py`
- All imports now reference the canonical paths

### VM Control Surface Implementation
**Status:** ✅ Completed
**Changes:**

1. **Opcode Head Wiring** (`layer/mosaic/block.py`):
   - Opcode head now emits `mosaic_opcode_logits` when `opcodes_enabled: true` and aux collection is enabled
   - Logits shape: `(B, T, opcode_vocab)` where default `opcode_vocab=4` (NOP, READ, WRITE, CLEAR)
   - Logits are added to `ctx.memblock_aux_out` for objective supervision

2. **Register Supervision** (`layer/mosaic/block.py`):
   - Register write gate and selection logits now preserve gradients (removed `.detach()` calls)
   - `mosaic_reg_write_gate_logits` and `mosaic_reg_sel_logits` are available for training

3. **Objective Updates** (`trainer/objectives.py`):
   - Added `aux_opcode_weight`, `aux_reg_gate_weight`, `aux_reg_sel_weight` parameters to `MosaicNextTokenWithAuxObjective`
   - Opcode supervision uses cross-entropy loss with `ignore_index=-1` for masked positions
   - Register gate uses binary cross-entropy; register selection uses cross-entropy over slot logits
   - Created `MosaicEventPrediction` alias class (registered as `objective.mosaic_event_prediction`)
   - All auxiliary losses are exposed in metrics for debugging

4. **Synthetic Curriculum** (`data/mosaic_synth.py`):
   - Dataset now emits `memblock_teacher_opcode` tensor aligned with input positions
   - Opcode convention: `0=NOP`, `1=READ`, `2=WRITE`, `3=CLEAR`
   - Opcodes are assigned based on memory operations: READ during query phase, WRITE during value storage

### VM Preset Configuration
**Status:** ✅ Completed
**File:** `config/presets/mosaic_vm.yml`

**Features:**
- Enables `reg_slots: 4` (4-register scratchpad)
- Enables `opcodes_enabled: true` with `opcode_vocab: 4`
- Uses 12GB-friendly defaults: `mem_buckets: 4096`, `mem_assoc: 2`
- Uses `objective.mosaic_event_prediction` with `aux_opcode_weight: 0.1`
- Small model size: `d_model: 256`, `n_layers: 4` for fast iteration

### Event Schema & Transducers
**Status:** ✅ Completed
**Files:** `core/event.py`, `core/event_codec.py`

**EventEnvelope Contract:**
- Required fields: `type` (str), `payload` (JSON-serializable), `sender` (str)
- Optional fields: `priority` (int, default 0), `budget_ms` (int | None), `id` (str, auto-generated), `ts` (float, auto-generated)
- Methods: `to_json_dict()`, `from_json_dict()` for serialization
- Validation: Strict type checking, non-empty strings for required fields

**EventEncoder/EventDecoder:**
- `EventEncoder.encode()`: Converts `EventEnvelope` → UTF-8 bytes → int64 tensor `[0, 255]`
- `EventEncoder.encode_padded()`: Batch encoding with padding, returns `(ids, mask)` tensors
- `EventDecoder.decode()`: Reverses encoding: tensor → bytes → JSON → `EventEnvelope`
- `EventDecoder.decode_padded()`: Batch decoding using attention mask
- JSON serialization uses stable format: `separators=(",", ":")`, `sort_keys=True` for determinism

**Integration Points:**
- Event primitives are available via `caramba.core` package
- Ready for integration into runtime agent/event loops (separate from the brainstorm meeting-notes generator)
- Event-native training is implemented via `dataset.mosaic_event_traces` (`data/event_trace.py`) and runnable preset `config/presets/mosaic_event_native.yml`

### Intrinsic Drives / Homeostatic Loop
**Status:** ✅ Completed
**Files:** `core/homeostasis.py`

**What was implemented:**
- `DriveBand`: defines a healthy band \([min,max]\) and computes deviation.
- `IntrinsicDrive`: maps a metric key (e.g. `"entropy"`, `"energy"`) into a drive signal with a weighted urgency.
- `HomeostaticLoop`: evaluates drives against a metrics dict and emits an `EventEnvelope` `"Impulse"` when any drive deviates beyond a threshold.

**How it fits the architecture:**
- Metrics can come from any subsystem (model telemetry, memory stats, external sensors).
- The loop converts metric deviations into **events**, enabling the event-driven "organism" control flow without coupling to brainstorm or any specific agent implementation.