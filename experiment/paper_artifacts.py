"""Paper artifact helpers (manifest-driven).

This module collects benchmark outputs produced by manifest targets and writes
paper-ready tables/figures into a specified output directory.

It is used by:
- a `process` target (`paper_collect_artifacts`) so the workflow stays manifest-driven
- an optional CLI wrapper script under `artifacts/paper/` for convenience
"""
from __future__ import annotations

import json
import os
from dataclasses import dataclass
from pathlib import Path

from caramba.config.manifest import Manifest
from caramba.config.target import ExperimentTargetConfig, ProcessTargetConfig


class ConfigurationError(Exception):
    """Raised when configuration setup fails."""


class MatplotlibImportError(Exception):
    """Raised when matplotlib import fails."""


class NoRowsToPlotError(Exception):
    """Raised when attempting to plot with no data rows."""


@dataclass(frozen=True)
class AblationRow:
    name: str
    perplexity: float
    tokens_per_sec: float


def _latest_run_dir(artifact_root: Path, manifest_name: str, target: str) -> Path | None:
    base = artifact_root / manifest_name / target
    if not base.exists():
        return None
    dirs = [p for p in base.iterdir() if p.is_dir()]
    if not dirs:
        return None
    # Timestamp directories are YYYYMMDD_HHMMSS; lexicographic max == latest.
    return sorted(dirs, key=lambda p: p.name)[-1]


def _read_report_metrics(run_dir: Path, *, name: str) -> AblationRow | None:
    rp = run_dir / "report.json"
    if not rp.exists():
        return None
    try:
        data = json.loads(rp.read_text(encoding="utf-8"))
    except Exception:
        # Return None on read errors to preserve graceful continuation
        return None

    summary = data.get("summary", {}) if isinstance(data, dict) else {}
    if not isinstance(summary, dict):
        summary = {}

    # In scratch runs there is no teacher; ArtifactGenerator leaves teacher_* as 0.
    ppl = float(summary.get("student_perplexity", 0.0) or 0.0)
    tps = float(summary.get("student_tokens_per_sec", 0.0) or 0.0)
    return AblationRow(name=str(name), perplexity=ppl, tokens_per_sec=tps)


def _write_json(out_dir: Path, *, manifest: str, rows: list[AblationRow]) -> Path:
    out = out_dir / "ablation_results.json"
    payload = {
        "manifest": manifest,
        "rows": [
            {"name": r.name, "perplexity": r.perplexity, "tokens_per_sec": r.tokens_per_sec}
            for r in rows
        ],
    }
    out.write_text(json.dumps(payload, indent=2) + "\n", encoding="utf-8")
    return out


def _write_latex_table(out_dir: Path, *, title: str, rows: list[AblationRow]) -> Path:
    out = out_dir / "ablation_tables.tex"
    if not rows:
        out.write_text("% No ablation results found.\n", encoding="utf-8")
        return out

    # Control baseline for deltas (first row).
    control = rows[0]
    lines: list[str] = []
    lines.append("% Auto-generated by Caramba (paper_collect_artifacts)\n")
    lines.append("\\begin{table}[htbp]\n")
    lines.append("\\centering\n")
    lines.append("\\small\n")
    lines.append(f"\\caption{{{title}}}\n")
    lines.append("\\label{tab:ablation_results}\n")
    lines.append("\\begin{tabular}{@{}lrrrr@{}}\n")
    lines.append("\\toprule\n")
    lines.append(
        "\\textbf{Variant} & \\textbf{PPL}$\\downarrow$ & $\\Delta$PPL & "
        "\\textbf{tok/s}$\\uparrow$ & $\\times$ \\\\\n"
    )
    lines.append("\\midrule\n")
    for r in rows:
        dppl = float(r.perplexity) - float(control.perplexity)
        speed = (float(r.tokens_per_sec) / float(control.tokens_per_sec)) if float(control.tokens_per_sec) > 0 else 0.0
        lines.append(
            f"{r.name} & {r.perplexity:.3f} & {dppl:+.3f} & {r.tokens_per_sec:.1f} & {speed:.2f} \\\\\n"
        )
    lines.append("\\bottomrule\n")
    lines.append("\\end{tabular}\n")
    lines.append("\\end{table}\n")
    out.write_text("".join(lines), encoding="utf-8")
    return out


def _write_plots(out_dir: Path, *, title_prefix: str, rows: list[AblationRow]) -> list[Path]:
    # Avoid Matplotlib cache warnings on read-only home dirs (CI/sandboxes).
    cfg_dir = out_dir / ".mplconfig"
    try:
        cfg_dir.mkdir(parents=True, exist_ok=True)
    except (OSError, PermissionError) as e:
        raise ConfigurationError(f"Failed to create MPLCONFIGDIR: {e}") from e
    os.environ.setdefault("MPLCONFIGDIR", str(cfg_dir))

    try:
        import matplotlib

        matplotlib.use("Agg")
        import matplotlib.pyplot as plt
    except Exception as e:
        raise MatplotlibImportError(f"Failed to import matplotlib: {e}") from e

    if not rows:
        # Return empty list to preserve backward compatibility
        return []

    names = [r.name for r in rows]
    ppl = [r.perplexity for r in rows]
    tps = [r.tokens_per_sec for r in rows]

    paths: list[Path] = []

    plots = [{
        "color": "#e67e22",
        "label": "Perplexity ↓",
        "title": f"{title_prefix}: Held-out Perplexity",
        "path": "ablation_perplexity.png",
        "data": {
            "names": names,
            "ppl": ppl,
        }
    }, {
        "color": "#2ecc71",
        "label": "Tokens / sec ↑",
        "title": f"{title_prefix}: Cached Decode Throughput",
        "path": "ablation_latency_tokens_per_sec.png",
        "data": {
            "names": names,
            "tps": tps,
        }
    }]
    for plot in plots:
        fig, ax = plt.subplots(figsize=(10, 4))
        ax.bar(plot["data"]["names"], plot["data"]["ppl"], color=plot["color"])
        ax.set_ylabel(plot["label"])
        ax.set_title(plot["title"])
        ax.grid(True, axis="y", alpha=0.2)
        ax.tick_params(axis="x", rotation=20)
        fig.tight_layout()
        p = out_dir / plot["path"]
        fig.savefig(p, dpi=200, bbox_inches="tight")
        plt.close(fig)
        paths.append(p)

    return paths


def collect_ablation_artifacts(
    *,
    manifest: Manifest,
    manifest_path: Path | None,
    artifact_root: Path = Path("artifacts"),
    out_dir: Path = Path("artifacts/paper"),
    title: str = "DBA Ablations",
    targets: list[str] | None = None,
) -> dict[str, Path]:
    """Collect latest per-target benchmark artifacts into paper-ready outputs."""
    out_dir.mkdir(parents=True, exist_ok=True)

    manifest_name = str(manifest.name or (manifest_path.stem if manifest_path else "manifest"))

    if targets is None:
        # Collect all experiment targets from this manifest in declaration order.
        # (Skip process targets, including this collector.)
        exp_targets: list[str] = []
        for t in manifest.targets:
            if isinstance(t, ExperimentTargetConfig):
                exp_targets.append(str(t.name))
            elif isinstance(t, ProcessTargetConfig):
                continue
        targets = exp_targets

    rows: list[AblationRow] = []
    for tname in targets:
        run_dir = _latest_run_dir(Path(artifact_root), manifest_name, str(tname))

        if run_dir is None:
            continue

        row = _read_report_metrics(run_dir, name=str(tname))

        if row is None:
            continue

        rows.append(row)

    written: dict[str, Path] = {}
    written["ablation_results.json"] = _write_json(out_dir, manifest=manifest_name, rows=rows)
    written["ablation_tables.tex"] = _write_latex_table(out_dir, title=str(title), rows=rows)
    for p in _write_plots(out_dir, title_prefix=str(title), rows=rows):
        written[p.name] = p

    # Return written outputs (even if empty) for logging.
    return written

