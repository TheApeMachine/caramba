// Code generated by capnpc-go. DO NOT EDIT.

package event

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Artifact capnp.Struct

// Artifact_TypeID is the unique identifier for the type Artifact.
const Artifact_TypeID = 0x9cc399b32bed09b5

func NewArtifact(s *capnp.Segment) (Artifact, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 5})
	return Artifact(st), err
}

func NewRootArtifact(s *capnp.Segment) (Artifact, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 5})
	return Artifact(st), err
}

func ReadRootArtifact(msg *capnp.Message) (Artifact, error) {
	root, err := msg.Root()
	return Artifact(root.Struct()), err
}

func (s Artifact) String() string {
	str, _ := text.Marshal(0x9cc399b32bed09b5, capnp.Struct(s))
	return str
}

func (s Artifact) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Artifact) DecodeFromPtr(p capnp.Ptr) Artifact {
	return Artifact(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Artifact) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Artifact) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Artifact) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Artifact) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Artifact) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Artifact) Type() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Artifact) HasType() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact) TypeBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Artifact) SetType(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Artifact) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Artifact) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Artifact) Origin() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s Artifact) HasOrigin() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Artifact) OriginBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s Artifact) SetOrigin(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s Artifact) Role() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Artifact) HasRole() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Artifact) RoleBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Artifact) SetRole(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Artifact) Payload() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return []byte(p.Data()), err
}

func (s Artifact) HasPayload() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Artifact) SetPayload(v []byte) error {
	return capnp.Struct(s).SetData(4, v)
}

// Artifact_List is a list of Artifact.
type Artifact_List = capnp.StructList[Artifact]

// NewArtifact creates a new list of Artifact.
func NewArtifact_List(s *capnp.Segment, sz int32) (Artifact_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 5}, sz)
	return capnp.StructList[Artifact](l), err
}

// Artifact_Future is a wrapper for a Artifact promised by a client call.
type Artifact_Future struct{ *capnp.Future }

func (f Artifact_Future) Struct() (Artifact, error) {
	p, err := f.Future.Ptr()
	return Artifact(p.Struct()), err
}

const schema_e363a5839bf866c5 = "x\xda<\x8b=J\x03Q\x18E\xef\xfd\xde<EH" +
	"\xd0'S\xa8KP4\xa4M\xe3\xcf\x0a\xfcl\xac\x87" +
	"d\x12\x06\xf3\xf3\x88\x0f!\x95\x85[\xb00\xa8\x18!" +
	"\x82B\x04E\x05;\x0b\xc9\x02,\\\x81\xb5\xbd\xddH" +
	"\x10\xd3\xdds9g\xe1j+*\x17\xdf\x08\xd1\xd8\xce" +
	"\xe4/s\xdfkO\xfd\xf7\x0b\xe82\x99\x8f\xeb?\xe7" +
	"'7\xd5/X;\x0b\x94\xc7\x8bt\x9f\x93\xf1\xb1O" +
	"\xac\xe7\xfe\xa0QJ\x8f\xd2\xb6\x09\xa5\xa4\x1b\xb2zR" +
	"\x0d\x1b\xd5\xc4\xb7}e\xfb\x0f\x19vI]2\x11\x10" +
	"\x11p\xfd\x15@O\x0du td\xcc\xc9y\xb9\x0a" +
	"\xe8\x99\xa1\x0e\x85\x94\x98\x02\xb8\xeb=@\x07\x86:\x12" +
	":#1\x0d\xe0\xee*\x80\x0e\x0d\xf5A\xe8\"\x133" +
	"\x02\xdc\xfd\xa4\xbe5\xd4g\xa1\xb3QL\x0b\xb8\xc7\x1d" +
	"@G\x86\xfa*4Y\x8d\x05\x08\x0b\xe0|\xe8\xf9\xf4" +
	"\x1f\xf2\x90\xb5\xd2\xc3\x90\xb4@O\x0b\xa1\x057;\xdd" +
	"\xac\x91\xb5\xa7~\xb7\xd3\x9c\xfa\xc7>\xe95;I\x8d" +
	"E\x08\x8b\xe0o\x00\x00\x00\xff\xff\x9d5B\xaf"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_e363a5839bf866c5,
		Nodes: []uint64{
			0x9cc399b32bed09b5,
		},
		Compressed: true,
	})
}
