// Code generated by capnpc-go. DO NOT EDIT.

package optimize

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
)

type Optimize capnp.Struct

// Optimize_TypeID is the unique identifier for the type Optimize.
const Optimize_TypeID = 0xa93e61250aae894c

func NewOptimize(s *capnp.Segment) (Optimize, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 2})
	return Optimize(st), err
}

func NewRootOptimize(s *capnp.Segment) (Optimize, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 2})
	return Optimize(st), err
}

func ReadRootOptimize(msg *capnp.Message) (Optimize, error) {
	root, err := msg.Root()
	return Optimize(root.Struct()), err
}

func (s Optimize) String() string {
	str, _ := text.Marshal(0xa93e61250aae894c, capnp.Struct(s))
	return str
}

func (s Optimize) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Optimize) DecodeFromPtr(p capnp.Ptr) Optimize {
	return Optimize(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Optimize) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Optimize) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Optimize) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Optimize) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Optimize) Operation() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Optimize) HasOperation() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Optimize) OperationBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Optimize) SetOperation(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Optimize) System() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Optimize) HasSystem() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Optimize) SystemBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Optimize) SetSystem(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Optimize) Temperature() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Optimize) SetTemperature(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Optimize) TopP() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Optimize) SetTopP(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Optimize) TopK() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Optimize) SetTopK(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Optimize) FrequencyPenalty() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Optimize) SetFrequencyPenalty(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Optimize) PresencePenalty() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Optimize) SetPresencePenalty(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

// Optimize_List is a list of Optimize.
type Optimize_List = capnp.StructList[Optimize]

// NewOptimize creates a new list of Optimize.
func NewOptimize_List(s *capnp.Segment, sz int32) (Optimize_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 40, PointerCount: 2}, sz)
	return capnp.StructList[Optimize](l), err
}

// Optimize_Future is a wrapper for a Optimize promised by a client call.
type Optimize_Future struct{ *capnp.Future }

func (f Optimize_Future) Struct() (Optimize, error) {
	p, err := f.Future.Ptr()
	return Optimize(p.Struct()), err
}

const schema_efed8c3251756e7a = "x\xdaL\x8a\xb1J#Q\x18\x85\xcf\xb9w&\x81M" +
	"\x96\xdd\x0bSn\xb1\x8d\x8d\xa0!\x96)\xd4Z\x05\xf3" +
	"\xfb\x06c\xb8\xca\xa0\x99\xb9N&ER\xda)\x82\xcf" +
	"ac\xa3\x82\x8d\x18!\x82\x82\x82B,\x04\x05K\x1b" +
	"\xf1\x11F\"\x8e\xd8\x9d\xef\xfb\xce\xdf\xa3y\xaf\xfe\xfb" +
	"\x9cP\x12\xf8\xa5|i\xe7\xf0\xd7D8{\x00\xf9O" +
	"?\xef\xc7]\x99\xd9{{\x87\xaf\xca@\xfdr\x81\xe6" +
	"q<\x1e\xf6\x89\xa9\xdcm\xac\xd7B\x17\xd5\xbc\xc4e" +
	"Q;\xea\xdbZ1\xa6[\xa1\x8b]c\xf9\x0b\x81&" +
	")\xff\xb4\x07x\x04\xcc\xc9\x0a \xc7\x9a2P4d" +
	"\xc0\xb1<k\x00r\xaa)CE\xaa\x80\x0a0\x17\xab" +
	"\x80\x0c4\xe5F\xd1h\x06\xd4\x80\xb9\x9e\x04d\xa8)" +
	"w\x8a\xc6S\x01=\xc0\xdc\x8e\xe5\x95\xa6\x8c\x14\x8d\xaf" +
	"\x03\xfa\x80\xb9\xdf\x05d\xa4)/\x8a\xa6\xe4\x05,\x01" +
	"\xe6y\x1b\x90'MyU\xcc\x13g\xd30\x8b\x120" +
	"f\x15\x8aUp\xae\xd3\xebd\xb6]`\x9e\xd9\xf6\xe7" +
	"\x09\xe5njY\x81b\x05\xfc\x93%\xae\xf9\x13\x16\x0b" +
	"\xc8\xd7R\xbb\xd5\xb5q\x8b\xbd\xa6\x8d\xc3\xcd\xac\x07|" +
	"7\x97\xda\x8e\x8d[\x96E*\xcaG\x00\x00\x00\xff\xff" +
	" b[("

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_efed8c3251756e7a,
		Nodes: []uint64{
			0xa93e61250aae894c,
		},
		Compressed: true,
	})
}
