// Code generated by capnpc-go. DO NOT EDIT.

package datura

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
	strconv "strconv"
)

type Artifact capnp.Struct

// Artifact_TypeID is the unique identifier for the type Artifact.
const Artifact_TypeID = 0xb1092b0e00ae75e5

func NewArtifact(s *capnp.Segment) (Artifact, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 14})
	return Artifact(st), err
}

func NewRootArtifact(s *capnp.Segment) (Artifact, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 14})
	return Artifact(st), err
}

func ReadRootArtifact(msg *capnp.Message) (Artifact, error) {
	root, err := msg.Root()
	return Artifact(root.Struct()), err
}

func (s Artifact) String() string {
	str, _ := text.Marshal(0xb1092b0e00ae75e5, capnp.Struct(s))
	return str
}

func (s Artifact) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Artifact) DecodeFromPtr(p capnp.Ptr) Artifact {
	return Artifact(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Artifact) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Artifact) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact) Uuid() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Artifact) HasUuid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Artifact) SetUuid(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Artifact) Checksum() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Artifact) HasChecksum() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact) SetChecksum(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Artifact) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Artifact) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Artifact) Mediatype() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s Artifact) HasMediatype() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Artifact) MediatypeBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s Artifact) SetMediatype(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s Artifact) Origin() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Artifact) HasOrigin() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Artifact) OriginBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Artifact) SetOrigin(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Artifact) Issuer() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s Artifact) HasIssuer() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Artifact) IssuerBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s Artifact) SetIssuer(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s Artifact) Role() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s Artifact) SetRole(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

func (s Artifact) Scope() uint32 {
	return capnp.Struct(s).Uint32(12)
}

func (s Artifact) SetScope(v uint32) {
	capnp.Struct(s).SetUint32(12, v)
}

func (s Artifact) PseudonymHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return []byte(p.Data()), err
}

func (s Artifact) HasPseudonymHash() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Artifact) SetPseudonymHash(v []byte) error {
	return capnp.Struct(s).SetData(5, v)
}

func (s Artifact) MerkleRoot() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return []byte(p.Data()), err
}

func (s Artifact) HasMerkleRoot() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Artifact) SetMerkleRoot(v []byte) error {
	return capnp.Struct(s).SetData(6, v)
}

func (s Artifact) Metadata() (Artifact_Metadata_List, error) {
	p, err := capnp.Struct(s).Ptr(7)
	return Artifact_Metadata_List(p.List()), err
}

func (s Artifact) HasMetadata() bool {
	return capnp.Struct(s).HasPtr(7)
}

func (s Artifact) SetMetadata(v Artifact_Metadata_List) error {
	return capnp.Struct(s).SetPtr(7, v.ToPtr())
}

// NewMetadata sets the metadata field to a newly
// allocated Artifact_Metadata_List, preferring placement in s's segment.
func (s Artifact) NewMetadata(n int32) (Artifact_Metadata_List, error) {
	l, err := NewArtifact_Metadata_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Artifact_Metadata_List{}, err
	}
	err = capnp.Struct(s).SetPtr(7, l.ToPtr())
	return l, err
}
func (s Artifact) Payload() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(8)
	return []byte(p.Data()), err
}

func (s Artifact) HasPayload() bool {
	return capnp.Struct(s).HasPtr(8)
}

func (s Artifact) SetPayload(v []byte) error {
	return capnp.Struct(s).SetData(8, v)
}

func (s Artifact) EncryptedPayload() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(9)
	return []byte(p.Data()), err
}

func (s Artifact) HasEncryptedPayload() bool {
	return capnp.Struct(s).HasPtr(9)
}

func (s Artifact) SetEncryptedPayload(v []byte) error {
	return capnp.Struct(s).SetData(9, v)
}

func (s Artifact) EncryptedKey() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(10)
	return []byte(p.Data()), err
}

func (s Artifact) HasEncryptedKey() bool {
	return capnp.Struct(s).HasPtr(10)
}

func (s Artifact) SetEncryptedKey(v []byte) error {
	return capnp.Struct(s).SetData(10, v)
}

func (s Artifact) EphemeralPublicKey() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(11)
	return []byte(p.Data()), err
}

func (s Artifact) HasEphemeralPublicKey() bool {
	return capnp.Struct(s).HasPtr(11)
}

func (s Artifact) SetEphemeralPublicKey(v []byte) error {
	return capnp.Struct(s).SetData(11, v)
}

func (s Artifact) Approvals() (Artifact_Approval_List, error) {
	p, err := capnp.Struct(s).Ptr(12)
	return Artifact_Approval_List(p.List()), err
}

func (s Artifact) HasApprovals() bool {
	return capnp.Struct(s).HasPtr(12)
}

func (s Artifact) SetApprovals(v Artifact_Approval_List) error {
	return capnp.Struct(s).SetPtr(12, v.ToPtr())
}

// NewApprovals sets the approvals field to a newly
// allocated Artifact_Approval_List, preferring placement in s's segment.
func (s Artifact) NewApprovals(n int32) (Artifact_Approval_List, error) {
	l, err := NewArtifact_Approval_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Artifact_Approval_List{}, err
	}
	err = capnp.Struct(s).SetPtr(12, l.ToPtr())
	return l, err
}
func (s Artifact) Signature() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(13)
	return []byte(p.Data()), err
}

func (s Artifact) HasSignature() bool {
	return capnp.Struct(s).HasPtr(13)
}

func (s Artifact) SetSignature(v []byte) error {
	return capnp.Struct(s).SetData(13, v)
}

// Artifact_List is a list of Artifact.
type Artifact_List = capnp.StructList[Artifact]

// NewArtifact creates a new list of Artifact.
func NewArtifact_List(s *capnp.Segment, sz int32) (Artifact_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 14}, sz)
	return capnp.StructList[Artifact](l), err
}

// Artifact_Future is a wrapper for a Artifact promised by a client call.
type Artifact_Future struct{ *capnp.Future }

func (f Artifact_Future) Struct() (Artifact, error) {
	p, err := f.Future.Ptr()
	return Artifact(p.Struct()), err
}

type Artifact_Metadata capnp.Struct
type Artifact_Metadata_value Artifact_Metadata
type Artifact_Metadata_value_Which uint16

const (
	Artifact_Metadata_value_Which_textValue   Artifact_Metadata_value_Which = 0
	Artifact_Metadata_value_Which_intValue    Artifact_Metadata_value_Which = 1
	Artifact_Metadata_value_Which_floatValue  Artifact_Metadata_value_Which = 2
	Artifact_Metadata_value_Which_boolValue   Artifact_Metadata_value_Which = 3
	Artifact_Metadata_value_Which_binaryValue Artifact_Metadata_value_Which = 4
)

func (w Artifact_Metadata_value_Which) String() string {
	const s = "textValueintValuefloatValueboolValuebinaryValue"
	switch w {
	case Artifact_Metadata_value_Which_textValue:
		return s[0:9]
	case Artifact_Metadata_value_Which_intValue:
		return s[9:17]
	case Artifact_Metadata_value_Which_floatValue:
		return s[17:27]
	case Artifact_Metadata_value_Which_boolValue:
		return s[27:36]
	case Artifact_Metadata_value_Which_binaryValue:
		return s[36:47]

	}
	return "Artifact_Metadata_value_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Artifact_Metadata_TypeID is the unique identifier for the type Artifact_Metadata.
const Artifact_Metadata_TypeID = 0xc121b65fcd3a05ee

func NewArtifact_Metadata(s *capnp.Segment) (Artifact_Metadata, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Artifact_Metadata(st), err
}

func NewRootArtifact_Metadata(s *capnp.Segment) (Artifact_Metadata, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Artifact_Metadata(st), err
}

func ReadRootArtifact_Metadata(msg *capnp.Message) (Artifact_Metadata, error) {
	root, err := msg.Root()
	return Artifact_Metadata(root.Struct()), err
}

func (s Artifact_Metadata) String() string {
	str, _ := text.Marshal(0xc121b65fcd3a05ee, capnp.Struct(s))
	return str
}

func (s Artifact_Metadata) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Artifact_Metadata) DecodeFromPtr(p capnp.Ptr) Artifact_Metadata {
	return Artifact_Metadata(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Artifact_Metadata) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Artifact_Metadata) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact_Metadata) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact_Metadata) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact_Metadata) Key() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Artifact_Metadata) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Artifact_Metadata) KeyBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Artifact_Metadata) SetKey(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Artifact_Metadata) Value() Artifact_Metadata_value { return Artifact_Metadata_value(s) }

func (s Artifact_Metadata_value) Which() Artifact_Metadata_value_Which {
	return Artifact_Metadata_value_Which(capnp.Struct(s).Uint16(0))
}
func (s Artifact_Metadata_value) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact_Metadata_value) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact_Metadata_value) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact_Metadata_value) TextValue() (string, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != textValue")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Artifact_Metadata_value) HasTextValue() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact_Metadata_value) TextValueBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Artifact_Metadata_value) SetTextValue(v string) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetText(1, v)
}

func (s Artifact_Metadata_value) IntValue() int64 {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != intValue")
	}
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Artifact_Metadata_value) SetIntValue(v int64) {
	capnp.Struct(s).SetUint16(0, 1)
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s Artifact_Metadata_value) FloatValue() float64 {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != floatValue")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Artifact_Metadata_value) SetFloatValue(v float64) {
	capnp.Struct(s).SetUint16(0, 2)
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Artifact_Metadata_value) BoolValue() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != boolValue")
	}
	return capnp.Struct(s).Bit(64)
}

func (s Artifact_Metadata_value) SetBoolValue(v bool) {
	capnp.Struct(s).SetUint16(0, 3)
	capnp.Struct(s).SetBit(64, v)
}

func (s Artifact_Metadata_value) BinaryValue() ([]byte, error) {
	if capnp.Struct(s).Uint16(0) != 4 {
		panic("Which() != binaryValue")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Artifact_Metadata_value) HasBinaryValue() bool {
	if capnp.Struct(s).Uint16(0) != 4 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact_Metadata_value) SetBinaryValue(v []byte) error {
	capnp.Struct(s).SetUint16(0, 4)
	return capnp.Struct(s).SetData(1, v)
}

// Artifact_Metadata_List is a list of Artifact_Metadata.
type Artifact_Metadata_List = capnp.StructList[Artifact_Metadata]

// NewArtifact_Metadata creates a new list of Artifact_Metadata.
func NewArtifact_Metadata_List(s *capnp.Segment, sz int32) (Artifact_Metadata_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Artifact_Metadata](l), err
}

// Artifact_Metadata_Future is a wrapper for a Artifact_Metadata promised by a client call.
type Artifact_Metadata_Future struct{ *capnp.Future }

func (f Artifact_Metadata_Future) Struct() (Artifact_Metadata, error) {
	p, err := f.Future.Ptr()
	return Artifact_Metadata(p.Struct()), err
}
func (p Artifact_Metadata_Future) Value() Artifact_Metadata_value_Future {
	return Artifact_Metadata_value_Future{p.Future}
}

// Artifact_Metadata_value_Future is a wrapper for a Artifact_Metadata_value promised by a client call.
type Artifact_Metadata_value_Future struct{ *capnp.Future }

func (f Artifact_Metadata_value_Future) Struct() (Artifact_Metadata_value, error) {
	p, err := f.Future.Ptr()
	return Artifact_Metadata_value(p.Struct()), err
}

type Artifact_Approval capnp.Struct

// Artifact_Approval_TypeID is the unique identifier for the type Artifact_Approval.
const Artifact_Approval_TypeID = 0x8cc20228b0f1020d

func NewArtifact_Approval(s *capnp.Segment) (Artifact_Approval, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Artifact_Approval(st), err
}

func NewRootArtifact_Approval(s *capnp.Segment) (Artifact_Approval, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Artifact_Approval(st), err
}

func ReadRootArtifact_Approval(msg *capnp.Message) (Artifact_Approval, error) {
	root, err := msg.Root()
	return Artifact_Approval(root.Struct()), err
}

func (s Artifact_Approval) String() string {
	str, _ := text.Marshal(0x8cc20228b0f1020d, capnp.Struct(s))
	return str
}

func (s Artifact_Approval) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Artifact_Approval) DecodeFromPtr(p capnp.Ptr) Artifact_Approval {
	return Artifact_Approval(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Artifact_Approval) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Artifact_Approval) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact_Approval) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact_Approval) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact_Approval) ZkProof() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Artifact_Approval) HasZkProof() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Artifact_Approval) SetZkProof(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Artifact_Approval) OperatorBlindSignature() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Artifact_Approval) HasOperatorBlindSignature() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact_Approval) SetOperatorBlindSignature(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// Artifact_Approval_List is a list of Artifact_Approval.
type Artifact_Approval_List = capnp.StructList[Artifact_Approval]

// NewArtifact_Approval creates a new list of Artifact_Approval.
func NewArtifact_Approval_List(s *capnp.Segment, sz int32) (Artifact_Approval_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Artifact_Approval](l), err
}

// Artifact_Approval_Future is a wrapper for a Artifact_Approval promised by a client call.
type Artifact_Approval_Future struct{ *capnp.Future }

func (f Artifact_Approval_Future) Struct() (Artifact_Approval, error) {
	p, err := f.Future.Ptr()
	return Artifact_Approval(p.Struct()), err
}

const schema_85d3acc39d94e0f8 = "x\xda\x84\xd4]h\x1cU\x1b\x07\xf0\xff\xff\x9c\xfdL" +
	"v\xb3Yf\xaeJC\xda\xb7}1~\xa4\xcd\x877" +
	"\x86@\xdbP\xa1\xa6\x08\x99\x0c\x06,\x16=\xd9=I" +
	"\xc6\xcc\xee\x0c\xb33\xa9+\x96\xdeX\x10\xa9 RA" +
	"\xc4\x82\x97^\x88\xe8\x8d\x17\x82\x88z\xa17\x81\x88^" +
	"((Th\xc1B\x95V\x14#VG\xce\xd6\xfd\xb0" +
	"\xa0\xee\xdd\xf9\x9d\xaf\xe7<\xfb<3\xb5O\x1c\xcdL" +
	"\x97?\x11\x10\xce\xbel.-\x8b\x9boO\x88\x8f." +
	"\xa0z\x80\xbf\\M\xde\x1a\xb9\xb7\xf8NV\xe4\x81\xd9" +
	"\x87\xb8J\xeb4\xf3\x80\xf5(\xcf\xa07\xeb\xec\xa1H" +
	"w/_\xbc\xf4\xf1\x9b\x9f\x9fGv\xc4\xac}\x9f{" +
	"hm\xf3.`\xf6\x1a?\x90`\xfaCvn\xfb\xf1" +
	"w\xf7\x7f\x08\xe7\x00\xc5\xdf\x0f\x1e\xcb\xad\xd2\x9a\xce\x99" +
	"\x83'sg\xc0\xb4ru\xe5\xc7\x99\x9dov\xe0\xdc" +
	"G\xd1\xdf\xf9\x88\xc83\x0b\xcc6r/\x11\x9c=\x9b" +
	"\x1b'&\xd3ps\xfdp]\xc5I&R\x87U\x14" +
	"{k\xaa\x16\x1f\xaa\xa9\xb0\x19\xce\x1d\xeb\x0e\x8f\x85a" +
	"\x14\xe4\xb7\x94\xbfD:\x05\x99\x012\x04\xaaw/\x00" +
	"\xceAIgJ\xb0J\xda48\xf9\x1e\xe0LI:" +
	"\xf3\x82\xe7\x9e\xde\\\x8a\x82`\x8de\x08\x96\xc14\x08" +
	"u\xa4\xe2 \xe2\x82\xef5\xeb\xae\xb7~\xa4\xa9\xe2$" +
	"\xd2\xbd\x05\xddh\xe4?E#k\xb1S\xe0@>\xaa" +
	"\xc5\xc5\x81\xa4\x17\x17\xd3\x87u\xac\xea*V\x00\xd2N" +
	"\xe0[\xca\x07\xe0\x1c\xef\xc6mm\xf3\x1e\xc0\xfd\x94\x92" +
	"\xee\x17\xec\x87n}\xc6E\xc0\xdd1\xfe5\x05)l" +
	"\x0a\xc0\xfa\x8a\xcb\x80\xfb\xa5\xe1+f\xb9\x146%`" +
	"}\xdb\xf1\xcb\xc6\xaf\x1b\xcfH\x9b\x19\xc0\xba\xc69\xc0" +
	"\xbdb\xfc\x86\xf1l\xc66y\xb7\xbe\xef\xf8w\xc6\x7f" +
	"2\x9e\x136s\x80u\xb3\x13\xceu\xe3\xbb\xc6\xf3\xd2" +
	"\xeeT\xc9\xcf\x9c\x01\xdc\x1b\xc6o\x19/dm\x16\x00" +
	"\xebWF\x80\xbbk<#\x04\xab\xc5\x9c\xcd\"`Q" +
	"\x9c\x02\x96\x85\xa4[2<\x94\xb79\x04XEa^" +
	"U0~\xd0\xf8p\xc1\xe60`\xed\x17\x0b\x80\xbb\xd7" +
	"\xf8\x84\xf1R\xd1f\x09\xb0\xfe/\x9e\x07\xdc\x09\xe3\xf7" +
	"\x1b/\x0f\xd9,\x03\xd6\xb4x\x12p\xa7\x8c\xcf\x1b\x1f" +
	"\x19\xb69\x02X\x0f\x88W\x01w\xde\xf8\x09\xe3\x95\x92" +
	"\xcd\x0a`=(Lz\x8e\x1b\x7f\xc2\xf8h\xd9\xe6(" +
	"`\x9d\xee\xf8c\xc67\x84`%I\xbcz\xef\xff\xaf" +
	"m\xe8\xdaf+i\x00\xe8Y\xec5t+V\x0d0" +
	"d\x16\x82Y0m\xe8\xba\xa7\xe2v\x08j\x96 X" +
	"\x02\x8f\x04\x91\xb7\xee5{C\xaf\xd5Jt\xd4\x1dV" +
	"\xa2\xc0\xd7,@\xb0\x00\x8e\xb7jA\xd8\x1b\xa5aK" +
	"'\xf5\xa0\xd9\xc6x\xe3\x84jm\xf4.n\xe8h\xd3" +
	"\xd7\xcb\x01d\x10\x0f`\xaf\xbc8\x02.Ir\xb4_" +
	"\x8d\xa0\xc1s\xa1j\xfb\x81\xea?K7kQ;\x8c" +
	"5\xebK\xb7g\x06\x9e\xd7\x9dC\xa5~R\xb7\xfb\x1c" +
	"n\xe8\x86\x8e\x14\xfd\xa5d\xd5\xf7j'\xe5\xc0\xa4\xea" +
	"\xd65[\xfd z]p;\x88\xb4\xe5\xadw\xba\xcb" +
	"\xe4\xe8\xce\xfe\xfa\xb7n\xef4P^\xc5\xea\x8en\xff" +
	"_\xbf\xdb\xcd\xaf\xff\x99\xa9N\xce@\xe47u\xbb\x9b" +
	"\xec\xf1-\xe5'\xbawY\xf6\xbf.S\xb1:d\xb6" +
	"P;\xb6\xcc\xecM\xd3\xbf\xbe%g\x97\x01\xe7\x19I" +
	"\xe79\xc11\xfeaX\x00\xd5\xf3\x8b\x80\xf3\xac\xa4\xf3" +
	"\xa2\xe0\x98\xf8\xdd\xb0\x04\xaa/\x9c\x02\x9c\x0b\x92\xce+" +
	"\x82c\xf2Vz\xb4\xd3\x8e\xd5\x97\xcd!\x17%\x9d\xd7" +
	"\x05\xc72\xbf\x99\xd5Y\xa0zi\x15p^\x93t\xde" +
	"\x10Lc\xfdT\xbc\xa2\xfcd\xa0\x9cR\xaf\xd9!m" +
	"\xfe\xe8n\xd9\xad\xf9\x812\x0a\x99h\x0eCp\x18L" +
	"W\x83\xc0\xefn&\x04i\xcck\xaa\xa8\xbd\xa2\x90\xf7" +
	"\x93^\xf6\xff\x0c\x00\x00\xff\xff*Lg\xe7"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_85d3acc39d94e0f8,
		Nodes: []uint64{
			0x8cc20228b0f1020d,
			0xb1092b0e00ae75e5,
			0xc121b65fcd3a05ee,
			0xd0ddd032f256e50f,
		},
		Compressed: true,
	})
}
