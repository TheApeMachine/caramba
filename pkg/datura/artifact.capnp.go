// Code generated by capnpc-go. DO NOT EDIT.

package datura

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
	strconv "strconv"
)

type Artifact capnp.Struct

// Artifact_TypeID is the unique identifier for the type Artifact.
const Artifact_TypeID = 0xb1092b0e00ae75e5

func NewArtifact(s *capnp.Segment) (Artifact, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 11})
	return Artifact(st), err
}

func NewRootArtifact(s *capnp.Segment) (Artifact, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 11})
	return Artifact(st), err
}

func ReadRootArtifact(msg *capnp.Message) (Artifact, error) {
	root, err := msg.Root()
	return Artifact(root.Struct()), err
}

func (s Artifact) String() string {
	str, _ := text.Marshal(0xb1092b0e00ae75e5, capnp.Struct(s))
	return str
}

func (s Artifact) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Artifact) DecodeFromPtr(p capnp.Ptr) Artifact {
	return Artifact(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Artifact) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Artifact) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact) Uuid() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Artifact) HasUuid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Artifact) SetUuid(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Artifact) Checksum() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Artifact) HasChecksum() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact) SetChecksum(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Artifact) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Artifact) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Artifact) Mediatype() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s Artifact) HasMediatype() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Artifact) MediatypeBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s Artifact) SetMediatype(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s Artifact) Role() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s Artifact) SetRole(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

func (s Artifact) Scope() uint32 {
	return capnp.Struct(s).Uint32(12)
}

func (s Artifact) SetScope(v uint32) {
	capnp.Struct(s).SetUint32(12, v)
}

func (s Artifact) PseudonymHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Artifact) HasPseudonymHash() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Artifact) SetPseudonymHash(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s Artifact) MerkleRoot() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return []byte(p.Data()), err
}

func (s Artifact) HasMerkleRoot() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Artifact) SetMerkleRoot(v []byte) error {
	return capnp.Struct(s).SetData(4, v)
}

func (s Artifact) Metadata() (Artifact_Metadata_List, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return Artifact_Metadata_List(p.List()), err
}

func (s Artifact) HasMetadata() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Artifact) SetMetadata(v Artifact_Metadata_List) error {
	return capnp.Struct(s).SetPtr(5, v.ToPtr())
}

// NewMetadata sets the metadata field to a newly
// allocated Artifact_Metadata_List, preferring placement in s's segment.
func (s Artifact) NewMetadata(n int32) (Artifact_Metadata_List, error) {
	l, err := NewArtifact_Metadata_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Artifact_Metadata_List{}, err
	}
	err = capnp.Struct(s).SetPtr(5, l.ToPtr())
	return l, err
}
func (s Artifact) EncryptedPayload() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return []byte(p.Data()), err
}

func (s Artifact) HasEncryptedPayload() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Artifact) SetEncryptedPayload(v []byte) error {
	return capnp.Struct(s).SetData(6, v)
}

func (s Artifact) EncryptedKey() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(7)
	return []byte(p.Data()), err
}

func (s Artifact) HasEncryptedKey() bool {
	return capnp.Struct(s).HasPtr(7)
}

func (s Artifact) SetEncryptedKey(v []byte) error {
	return capnp.Struct(s).SetData(7, v)
}

func (s Artifact) EphemeralPublicKey() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(8)
	return []byte(p.Data()), err
}

func (s Artifact) HasEphemeralPublicKey() bool {
	return capnp.Struct(s).HasPtr(8)
}

func (s Artifact) SetEphemeralPublicKey(v []byte) error {
	return capnp.Struct(s).SetData(8, v)
}

func (s Artifact) Approvals() (Artifact_Approval_List, error) {
	p, err := capnp.Struct(s).Ptr(9)
	return Artifact_Approval_List(p.List()), err
}

func (s Artifact) HasApprovals() bool {
	return capnp.Struct(s).HasPtr(9)
}

func (s Artifact) SetApprovals(v Artifact_Approval_List) error {
	return capnp.Struct(s).SetPtr(9, v.ToPtr())
}

// NewApprovals sets the approvals field to a newly
// allocated Artifact_Approval_List, preferring placement in s's segment.
func (s Artifact) NewApprovals(n int32) (Artifact_Approval_List, error) {
	l, err := NewArtifact_Approval_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Artifact_Approval_List{}, err
	}
	err = capnp.Struct(s).SetPtr(9, l.ToPtr())
	return l, err
}
func (s Artifact) Signature() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(10)
	return []byte(p.Data()), err
}

func (s Artifact) HasSignature() bool {
	return capnp.Struct(s).HasPtr(10)
}

func (s Artifact) SetSignature(v []byte) error {
	return capnp.Struct(s).SetData(10, v)
}

// Artifact_List is a list of Artifact.
type Artifact_List = capnp.StructList[Artifact]

// NewArtifact creates a new list of Artifact.
func NewArtifact_List(s *capnp.Segment, sz int32) (Artifact_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 11}, sz)
	return capnp.StructList[Artifact](l), err
}

// Artifact_Future is a wrapper for a Artifact promised by a client call.
type Artifact_Future struct{ *capnp.Future }

func (f Artifact_Future) Struct() (Artifact, error) {
	p, err := f.Future.Ptr()
	return Artifact(p.Struct()), err
}

type Artifact_Metadata capnp.Struct
type Artifact_Metadata_value Artifact_Metadata
type Artifact_Metadata_value_Which uint16

const (
	Artifact_Metadata_value_Which_textValue   Artifact_Metadata_value_Which = 0
	Artifact_Metadata_value_Which_intValue    Artifact_Metadata_value_Which = 1
	Artifact_Metadata_value_Which_floatValue  Artifact_Metadata_value_Which = 2
	Artifact_Metadata_value_Which_boolValue   Artifact_Metadata_value_Which = 3
	Artifact_Metadata_value_Which_binaryValue Artifact_Metadata_value_Which = 4
)

func (w Artifact_Metadata_value_Which) String() string {
	const s = "textValueintValuefloatValueboolValuebinaryValue"
	switch w {
	case Artifact_Metadata_value_Which_textValue:
		return s[0:9]
	case Artifact_Metadata_value_Which_intValue:
		return s[9:17]
	case Artifact_Metadata_value_Which_floatValue:
		return s[17:27]
	case Artifact_Metadata_value_Which_boolValue:
		return s[27:36]
	case Artifact_Metadata_value_Which_binaryValue:
		return s[36:47]

	}
	return "Artifact_Metadata_value_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Artifact_Metadata_TypeID is the unique identifier for the type Artifact_Metadata.
const Artifact_Metadata_TypeID = 0xc121b65fcd3a05ee

func NewArtifact_Metadata(s *capnp.Segment) (Artifact_Metadata, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Artifact_Metadata(st), err
}

func NewRootArtifact_Metadata(s *capnp.Segment) (Artifact_Metadata, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Artifact_Metadata(st), err
}

func ReadRootArtifact_Metadata(msg *capnp.Message) (Artifact_Metadata, error) {
	root, err := msg.Root()
	return Artifact_Metadata(root.Struct()), err
}

func (s Artifact_Metadata) String() string {
	str, _ := text.Marshal(0xc121b65fcd3a05ee, capnp.Struct(s))
	return str
}

func (s Artifact_Metadata) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Artifact_Metadata) DecodeFromPtr(p capnp.Ptr) Artifact_Metadata {
	return Artifact_Metadata(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Artifact_Metadata) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Artifact_Metadata) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact_Metadata) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact_Metadata) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact_Metadata) Key() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Artifact_Metadata) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Artifact_Metadata) KeyBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Artifact_Metadata) SetKey(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Artifact_Metadata) Value() Artifact_Metadata_value { return Artifact_Metadata_value(s) }

func (s Artifact_Metadata_value) Which() Artifact_Metadata_value_Which {
	return Artifact_Metadata_value_Which(capnp.Struct(s).Uint16(0))
}
func (s Artifact_Metadata_value) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact_Metadata_value) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact_Metadata_value) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact_Metadata_value) TextValue() (string, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != textValue")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Artifact_Metadata_value) HasTextValue() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact_Metadata_value) TextValueBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Artifact_Metadata_value) SetTextValue(v string) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetText(1, v)
}

func (s Artifact_Metadata_value) IntValue() int64 {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != intValue")
	}
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Artifact_Metadata_value) SetIntValue(v int64) {
	capnp.Struct(s).SetUint16(0, 1)
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s Artifact_Metadata_value) FloatValue() float64 {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != floatValue")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Artifact_Metadata_value) SetFloatValue(v float64) {
	capnp.Struct(s).SetUint16(0, 2)
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Artifact_Metadata_value) BoolValue() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != boolValue")
	}
	return capnp.Struct(s).Bit(64)
}

func (s Artifact_Metadata_value) SetBoolValue(v bool) {
	capnp.Struct(s).SetUint16(0, 3)
	capnp.Struct(s).SetBit(64, v)
}

func (s Artifact_Metadata_value) BinaryValue() ([]byte, error) {
	if capnp.Struct(s).Uint16(0) != 4 {
		panic("Which() != binaryValue")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Artifact_Metadata_value) HasBinaryValue() bool {
	if capnp.Struct(s).Uint16(0) != 4 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact_Metadata_value) SetBinaryValue(v []byte) error {
	capnp.Struct(s).SetUint16(0, 4)
	return capnp.Struct(s).SetData(1, v)
}

// Artifact_Metadata_List is a list of Artifact_Metadata.
type Artifact_Metadata_List = capnp.StructList[Artifact_Metadata]

// NewArtifact_Metadata creates a new list of Artifact_Metadata.
func NewArtifact_Metadata_List(s *capnp.Segment, sz int32) (Artifact_Metadata_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Artifact_Metadata](l), err
}

// Artifact_Metadata_Future is a wrapper for a Artifact_Metadata promised by a client call.
type Artifact_Metadata_Future struct{ *capnp.Future }

func (f Artifact_Metadata_Future) Struct() (Artifact_Metadata, error) {
	p, err := f.Future.Ptr()
	return Artifact_Metadata(p.Struct()), err
}
func (p Artifact_Metadata_Future) Value() Artifact_Metadata_value_Future {
	return Artifact_Metadata_value_Future{p.Future}
}

// Artifact_Metadata_value_Future is a wrapper for a Artifact_Metadata_value promised by a client call.
type Artifact_Metadata_value_Future struct{ *capnp.Future }

func (f Artifact_Metadata_value_Future) Struct() (Artifact_Metadata_value, error) {
	p, err := f.Future.Ptr()
	return Artifact_Metadata_value(p.Struct()), err
}

type Artifact_Approval capnp.Struct

// Artifact_Approval_TypeID is the unique identifier for the type Artifact_Approval.
const Artifact_Approval_TypeID = 0x8cc20228b0f1020d

func NewArtifact_Approval(s *capnp.Segment) (Artifact_Approval, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Artifact_Approval(st), err
}

func NewRootArtifact_Approval(s *capnp.Segment) (Artifact_Approval, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Artifact_Approval(st), err
}

func ReadRootArtifact_Approval(msg *capnp.Message) (Artifact_Approval, error) {
	root, err := msg.Root()
	return Artifact_Approval(root.Struct()), err
}

func (s Artifact_Approval) String() string {
	str, _ := text.Marshal(0x8cc20228b0f1020d, capnp.Struct(s))
	return str
}

func (s Artifact_Approval) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Artifact_Approval) DecodeFromPtr(p capnp.Ptr) Artifact_Approval {
	return Artifact_Approval(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Artifact_Approval) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Artifact_Approval) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Artifact_Approval) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Artifact_Approval) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Artifact_Approval) ZkProof() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Artifact_Approval) HasZkProof() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Artifact_Approval) SetZkProof(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Artifact_Approval) OperatorBlindSignature() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Artifact_Approval) HasOperatorBlindSignature() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Artifact_Approval) SetOperatorBlindSignature(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// Artifact_Approval_List is a list of Artifact_Approval.
type Artifact_Approval_List = capnp.StructList[Artifact_Approval]

// NewArtifact_Approval creates a new list of Artifact_Approval.
func NewArtifact_Approval_List(s *capnp.Segment, sz int32) (Artifact_Approval_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Artifact_Approval](l), err
}

// Artifact_Approval_Future is a wrapper for a Artifact_Approval promised by a client call.
type Artifact_Approval_Future struct{ *capnp.Future }

func (f Artifact_Approval_Future) Struct() (Artifact_Approval, error) {
	p, err := f.Future.Ptr()
	return Artifact_Approval(p.Struct()), err
}

const schema_85d3acc39d94e0f8 = "x\xda\x84\x93_h\x1cU\x14\xc6\xbf\xef\xde\x9d\xecn" +
	"\x92m\\f@(\x86\xa8\x15\xfc\x9b6&/R\x04" +
	"\xdb>i\x8a\x90\x9b\xc5\x80\x05\x91\x9b\xdd\x9bd\xcc\xec" +
	"\xce0;\x93\xba\xd2\xa0\x0f\x0d\x14I!H\x0aU\x12" +
	"\xe8\x83B\x1f\xaa\xd4\x17A\xc1\x07\x15\xb1>\x14\"\xfa" +
	"\"T\xf0\xc1\x80\xbe\x08\xea\x83\x82\xad#w\xe8\xfe\xb1" +
	"\xa0\xce\xdb\xfc\xee\xb9\xe7|\xf7\x9c\xefL\xfd\xc6c\x85" +
	"\xc7+_\x08\x08u\xaf3\x94U\xc4/W\x1f\x12\x9f" +
	"n\xa2z\x88\xbf\xef\xa7\xef\x1dx\xb4\xfc\xbe#\x8a\xc0" +
	"\xcc3\\\xa4\xfb\x02\x8b\x80\xfb<O\xa3w\xaa\x0eR" +
	"d\x7f|\xbf\xbd\xfb\xd9\x95\xaf7\xe0\x8c\xd8\xd8\x8fy" +
	"\x90\xeeu>\x08\xcc\xfc\xc4\xbb%\x98\xfd\xec\x1c\xbd\xfe" +
	"\xe2\x07\xf7}\x02u\x88\xe2\x9f\x89}g\x91\xee\xbac" +
	"\x13w\x9c\xd3`6\xb6\xbf\xf0\xeb\xf4\xdew{P\x8f" +
	"Q\xf4o>'\x8at\x80\x99\x0f\x9d7\x08\xce|\xe9" +
	"L\x10\x93Y\xb4\xba|\xa4\xa1\x93\xb4\x10\xeb#:N" +
	"\xfc%]O\x0e\xd7u\xd4\x8a\x8e\x1e\xef\xfe\x1e\x8f\xa2" +
	"8,\xae\xe9`\x8eT%Y\x00\x0a\x04\xaa\x0f\x9f\x00" +
	"\xd4\x03\x92jJ\xb0Jz\xb4p\xf2#@MI\xaa" +
	"'\x05_}eu.\x0e\xc3%V X\x01\xb30" +
	"2\xb1N\xc2\x98'\x02\xbf\xd5\xa8\xf9\xcbO\xb5t\x92" +
	"\xc6\xa6\x17\xd0U#\xffM\x8d\xac'\xaa\xc4\x81~T" +
	"\xcb\xb3\x03M/\xcff\xcf\x9aD7t\xa2\x01d\xb9" +
	"\xf05\x1d\x00POtu\xbb\x1d>\x02\xd4\x12J\xd6" +
	"^c_\xba\xbb\xceY\xa0v\xc6\xf2s\x14\xa4\xf0(" +
	"\x00w\x83\xf3@\xed\xac\xc5[6\\\x0a\x8f\x12p\xcf" +
	"\xe7|\xd3\xf2\x8b\x96\x17\x84\xc7\x02\xe0^\xc8\xd3oY" +
	"\xbec\xb9#=\xdbw\xf7MN\x03\xb5m\xcb/Y" +
	">$=\x0e\x01\xee.c\xa0\xb6c\xf9e\xcb\x8b\x05" +
	"/w\xc9;<\x05\xd4\xde\xb6\xfc\xaa\xe5%\xc7c\x09" +
	"p\xdf\xcde^\xb1\xfc\x9a\xe5\xe5!\x8fe\xc0\xfd\x9c" +
	"\xaf\x03\xb5k\x96\x7fc\xf9p\xd1\xe30\xe0~\xc5\x97" +
	"\x80\xda\x9e\xe57,\x1f)y\x1c\x01\xdco\xf9\x16P" +
	"\xbba\xf9\x8f\x96\x8f\x96=\x8e\x02\xee~\xfe\xae\x1f(" +
	"9/\x04\xab\x95a\x8f\x15\xc0\xbd\x95\xe3\x9b6\xbc$" +
	"\x04\xc7\xd2\xd4o\xf4\xe6V_1\xf5\xd5v\xda\x04\xd0" +
	"c\x89\xdf4\xedD7\xc1\x88\x0e\x04\x1d0k\x9a\x86" +
	"\xaf\x93N\x04\x1a\x8eBp\x14\x1c\x8b\xc3\xc0\xb0\x04\xc1" +
	"\x128\xd1\xae\x87Q\xef/\x8b\xda&m\x84\xad\x0e&" +
	"\x9aO\xeb\xf6J/u\xd3\xc4\xab\x81\x99\x0f!\xc3d" +
	"\x00\xf6\x06\xcf\x03\xe0\x9c$\xef\xea\xfb\x04\xb403\xad" +
	"z\xdc\x89\x12\xc3\xc6\x9c\xee\x04\xa1n\x0c\x08\xee\x9ea" +
	"\xacq\xd2t\xfa8Z1M\x13k\x06s\xe9b\xe0" +
	"\xd7O\xca\x81C\xddu\x18\xdb\xfd\xa2=?\xde.\xda" +
	"\xf6\x97s\x9f\xdbW\xdf\xe9\xf4\xff\xda\xbb\xdc\xcaE\x9d" +
	"\xe8;\xf6\xee\xfe\xfe\xde\xd9\xaf\xbf\xf0\xd5\xc9i\x88\xe2" +
	"\xaa\xe9t\x9b;\xb1\xa6\x83\xd4\xf4\x8a9\xffWL'" +
	"\xfa\xb0\xbdB\xa3<Y\xb8'\xcbno\xf5\xfa<\xa0" +
	"\xceH\xaas\x82\xe3\xfc\xcbb\x01T7f\x01uV" +
	"Rm\x09\x8e\x8b[\x16K\xa0z\xfe\x14\xa06%\xd5" +
	"E\xc1qy3;\x96/F\xf5\x82M\xb2-\xa9." +
	"\x09\x8e\x17\xfe\xb4\xd1\x0eP\xdd]\x04\xd4\x8e\xa4\xba," +
	"\x98%\xe6\xe5dA\x07\xe9\x80A2\xbf\x95#c\x07" +
	"\xdb5\xd2R\x10jK!S\xc3\x11\x08\x8e\x80\xd9b" +
	"\x18\x06\xdd\xcb\x84 -\xf3[:\xee,h\x14\x83\xb4" +
	"\xd7\xfd\xbf\x03\x00\x00\xff\xff=r[1"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_85d3acc39d94e0f8,
		Nodes: []uint64{
			0x8cc20228b0f1020d,
			0xb1092b0e00ae75e5,
			0xc121b65fcd3a05ee,
			0xd0ddd032f256e50f,
		},
		Compressed: true,
	})
}
