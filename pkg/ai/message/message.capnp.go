// Code generated by capnpc-go. DO NOT EDIT.

package message

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	toolcall "github.com/theapemachine/caramba/pkg/ai/toolcall"
)

type Message capnp.Struct

// Message_TypeID is the unique identifier for the type Message.
const Message_TypeID = 0x82401d7c68f14b9e

func NewMessage(s *capnp.Segment) (Message, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Message(st), err
}

func NewRootMessage(s *capnp.Segment) (Message, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Message(st), err
}

func ReadRootMessage(msg *capnp.Message) (Message, error) {
	root, err := msg.Root()
	return Message(root.Struct()), err
}

func (s Message) String() string {
	str, _ := text.Marshal(0x82401d7c68f14b9e, capnp.Struct(s))
	return str
}

func (s Message) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Message) DecodeFromPtr(p capnp.Ptr) Message {
	return Message(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Message) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Message) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Message) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Message) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Message) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Message) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Message) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Message) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Message) Role() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Message) HasRole() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Message) RoleBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Message) SetRole(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Message) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s Message) HasName() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Message) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s Message) SetName(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s Message) Content() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Message) HasContent() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Message) ContentBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Message) SetContent(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Message) ToolCalls() (toolcall.ToolCall_List, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return toolcall.ToolCall_List(p.List()), err
}

func (s Message) HasToolCalls() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Message) SetToolCalls(v toolcall.ToolCall_List) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewToolCalls sets the toolCalls field to a newly
// allocated toolcall.ToolCall_List, preferring placement in s's segment.
func (s Message) NewToolCalls(n int32) (toolcall.ToolCall_List, error) {
	l, err := toolcall.NewToolCall_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return toolcall.ToolCall_List{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}

// Message_List is a list of Message.
type Message_List = capnp.StructList[Message]

// NewMessage creates a new list of Message.
func NewMessage_List(s *capnp.Segment, sz int32) (Message_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5}, sz)
	return capnp.StructList[Message](l), err
}

// Message_Future is a wrapper for a Message promised by a client call.
type Message_Future struct{ *capnp.Future }

func (f Message_Future) Struct() (Message, error) {
	p, err := f.Future.Ptr()
	return Message(p.Struct()), err
}

const schema_d4c9c9f76e88a0d9 = "x\xda<\xc8=J3Q\x18\xc5\xf1s\xees\xf3\xbe" +
	"MLrq*1\xd8\xd8\x18\xd0A\xec\xac\x82)E" +
	"\xc8\xe3\x0e\x868\xc4\xe0|\xe1La\x11\xf1\x83\x88\x11" +
	"#\xb8\x02\xb1\x14\x1b\xd7\x91\xdeFp\x13V\x96#\x83" +
	"\x98\xea\x9c\xdf\xbf\xf5\xda\xb5\xdbK\xa9\x81\xd1\xd5\xda\xbf" +
	"\xf2i\xff\xebx\xdc\xee^\xc3\xb5Y~<O\x93\xef" +
	"\xf9\xfc\x1d\xb5\xda\x7f`\xa7\xcd\x0e\x977Y\xdd\x0d\xae" +
	"\x11\xbd2;\x19\xfa\xc1\xc8\x8f%\xcc\xf3`\x18\xfa\xf1" +
	"\xefn\x0d\x82,\xc9v\x0f\xc2\xbcY\xb1O\xaa'\x16" +
	"\xb0\x04\xdc\xf9\x0a\xa0gB\x9d\x18:\xd2c\x15\xaf:" +
	"\x80\x8e\x85:5t\xc6x4\x80\xbb\xa9\xe2\xa5Pg" +
	"\x86N\xc4\xa3\x00\xeen\x0f\xd0\x89P\x1f\x0d\x9d\xb5\x1e" +
	"-\xe0\x1e\x0e\x01\x9d\x09\xf5\xc5PFG\xac\xc3\xb0\x0e" +
	"6O\xd3(\\ \x09\xe2\x05.\x06iR\x84I\xf1" +
	"\xe7\xb2H\xd3\xa8\x17D\x11\x98\xb3\x01\xf6\x85l\x95\xfa" +
	"y\xfb\xb6\xde\xc8\xee\x01V\xf1'\x00\x00\xff\xff\xade" +
	">\x01"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_d4c9c9f76e88a0d9,
		Nodes: []uint64{
			0x82401d7c68f14b9e,
		},
		Compressed: true,
	})
}
