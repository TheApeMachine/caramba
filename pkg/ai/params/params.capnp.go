// Code generated by capnpc-go. DO NOT EDIT.

package params

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
)

type Params capnp.Struct

// Params_TypeID is the unique identifier for the type Params.
const Params_TypeID = 0xc35b8a4838998a1e

func NewParams(s *capnp.Segment) (Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 2})
	return Params(st), err
}

func NewRootParams(s *capnp.Segment) (Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 2})
	return Params(st), err
}

func ReadRootParams(msg *capnp.Message) (Params, error) {
	root, err := msg.Root()
	return Params(root.Struct()), err
}

func (s Params) String() string {
	str, _ := text.Marshal(0xc35b8a4838998a1e, capnp.Struct(s))
	return str
}

func (s Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Params) DecodeFromPtr(p capnp.Ptr) Params {
	return Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Params) Model() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Params) HasModel() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Params) ModelBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Params) SetModel(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Params) Temperature() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Params) SetTemperature(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Params) TopP() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Params) SetTopP(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Params) TopK() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Params) SetTopK(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Params) FrequencyPenalty() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Params) SetFrequencyPenalty(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Params) PresencePenalty() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Params) SetPresencePenalty(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

func (s Params) MaxTokens() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(40))
}

func (s Params) SetMaxTokens(v float64) {
	capnp.Struct(s).SetUint64(40, math.Float64bits(v))
}

func (s Params) Stream() bool {
	return capnp.Struct(s).Bit(384)
}

func (s Params) SetStream(v bool) {
	capnp.Struct(s).SetBit(384, v)
}

func (s Params) Format() (ResponseFormat, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return ResponseFormat(p.Struct()), err
}

func (s Params) HasFormat() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Params) SetFormat(v ResponseFormat) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewFormat sets the format field to a newly
// allocated ResponseFormat struct, preferring placement in s's segment.
func (s Params) NewFormat() (ResponseFormat, error) {
	ss, err := NewResponseFormat(capnp.Struct(s).Segment())
	if err != nil {
		return ResponseFormat{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Params_List is a list of Params.
type Params_List = capnp.StructList[Params]

// NewParams creates a new list of Params.
func NewParams_List(s *capnp.Segment, sz int32) (Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 56, PointerCount: 2}, sz)
	return capnp.StructList[Params](l), err
}

// Params_Future is a wrapper for a Params promised by a client call.
type Params_Future struct{ *capnp.Future }

func (f Params_Future) Struct() (Params, error) {
	p, err := f.Future.Ptr()
	return Params(p.Struct()), err
}
func (p Params_Future) Format() ResponseFormat_Future {
	return ResponseFormat_Future{Future: p.Future.Field(1, nil)}
}

type ResponseFormat capnp.Struct

// ResponseFormat_TypeID is the unique identifier for the type ResponseFormat.
const ResponseFormat_TypeID = 0x9772ae3f5bece367

func NewResponseFormat(s *capnp.Segment) (ResponseFormat, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return ResponseFormat(st), err
}

func NewRootResponseFormat(s *capnp.Segment) (ResponseFormat, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return ResponseFormat(st), err
}

func ReadRootResponseFormat(msg *capnp.Message) (ResponseFormat, error) {
	root, err := msg.Root()
	return ResponseFormat(root.Struct()), err
}

func (s ResponseFormat) String() string {
	str, _ := text.Marshal(0x9772ae3f5bece367, capnp.Struct(s))
	return str
}

func (s ResponseFormat) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (ResponseFormat) DecodeFromPtr(p capnp.Ptr) ResponseFormat {
	return ResponseFormat(capnp.Struct{}.DecodeFromPtr(p))
}

func (s ResponseFormat) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s ResponseFormat) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s ResponseFormat) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s ResponseFormat) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s ResponseFormat) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s ResponseFormat) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s ResponseFormat) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s ResponseFormat) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s ResponseFormat) Description() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s ResponseFormat) HasDescription() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s ResponseFormat) DescriptionBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s ResponseFormat) SetDescription(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s ResponseFormat) Schema() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s ResponseFormat) HasSchema() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s ResponseFormat) SchemaBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s ResponseFormat) SetSchema(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s ResponseFormat) Strict() bool {
	return capnp.Struct(s).Bit(0)
}

func (s ResponseFormat) SetStrict(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// ResponseFormat_List is a list of ResponseFormat.
type ResponseFormat_List = capnp.StructList[ResponseFormat]

// NewResponseFormat creates a new list of ResponseFormat.
func NewResponseFormat_List(s *capnp.Segment, sz int32) (ResponseFormat_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3}, sz)
	return capnp.StructList[ResponseFormat](l), err
}

// ResponseFormat_Future is a wrapper for a ResponseFormat promised by a client call.
type ResponseFormat_Future struct{ *capnp.Future }

func (f ResponseFormat_Future) Struct() (ResponseFormat, error) {
	p, err := f.Future.Ptr()
	return ResponseFormat(p.Struct()), err
}

const schema_d4c9c9f76e88a0d4 = "x\xdal\x92=k\x14]\x1c\xc5\xcf\xb9w&\x13H" +
	"Bv\x9e\x99\x07\x03\xbeEH!\x82\xaek\x1a\xd9f" +
	"\xadD\xb0\xd9\xbbc\x17\x9b\xeb\xecMv\xc9\xceKf" +
	"&\x90tb%\xfb\x05\xc4\xceO\xe0\x97\xb0J\x9f\xc6" +
	"ZD\x05\x05\x03\x01\x15\x94\x91\xbba6)\xac.\xe7" +
	"w\xfe\x17\xce\xff\xe5\xee:\x1f8\x9d\x95K\x02B\xad" +
	"\xb9\x0b\xf5\xce\x87\xaf[\xbd\xb7\xc5+\xa8\xcbd}\xfc" +
	"\xe6e\xfa\xe3\xe8\xe8\x18\xae\xf4\x80\xce\xc9\x80\x81K\x0f" +
	"\x08\xc8O`}m\xfa\xfa\xfe\xa3\xe9\xd6;[\xec]" +
	"(\x16\x1e\xb0\xf9\x9e\xff1\xf8b\xab7?\xb2&n" +
	"\xd7\xf9\xeeN[\x8f\xdb\xb9\xa3\x0b\x9d\x94\xed|\xf6\xdc" +
	"\x89u\x9e\xe6\xdd\x81)\xf3,-\xcd\xc3\xacH4\xab" +
	">\xa9Z\xd2\x01\x1c\x02\xbe\xbe\x05\xa8\xa7\x92j$\xe8" +
	"\x93!-4\xcf\x005\x94T\xb9\xa0/DH\x01\xf8" +
	"I\x17P#IU\x09R\x86\x94\x80\xbfg\xd9DR" +
	"\x1d\x08\xae\xa6:1\\\x86\xe02X\x0fM\x19\x17\xe3" +
	"\xbc\x827\xce\xd2\x86\xf6\xcaxd\x12}.\xabb\x1c" +
	"W$\x04\x09\xce\x9b\x90\xffh\xa2o\x05K\x1b~c" +
	"\x1e\xfe\xdb=@}\x96T\xa7\x82M\xf6\x13\x9b\xfd\xbb" +
	"\xa4\xfam\xb3\xf3,\xfb/\xdb\xe5\xa9\xe4\x80\x82\xbe\x14" +
	"g\xe1\xffX\xf8S2r,udHg6\xfe)" +
	"\x109\x94\x8cZ\x96\xbbNH\x17\x08V\xf8\x02\x88\x96" +
	"-_\xb3|\xc1\x0d\xb9\x00\x04\xffs\x00D\xa1\xe5\xeb" +
	"\x14\xecx\xcf\x19\xce\xf6x\x95] Z\xb3\xc6\x86\xfd" +
	"\xb0\xc8\x90\x8b@pc\xc6\xafX~\x93\x82\xd7\x93l" +
	"h&\xf3\xb9U&\xc9M\xa1+x\xfb\x85\xe1\x12\x04" +
	"\x97\xc0\xd5*\xcb\xfb\x17\xc5\xe3F\xd4\xdb\x85\xd9\xdb7" +
	"i\xcc\xc3\xbeI\xf5\xa4:\x04\xe6^^\x98\xd2\xa4\xb1" +
	"ac\xcd\x9dD\x1f<\xc9vM\x0a\x96\x0d\xb3\xcb0" +
	":i\x96\xd1\xdb\xb6\xd7R\xb1u~\xb6 [\xe0\xdf" +
	"\x00\x00\x00\xff\xffsf\x98\xa1"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_d4c9c9f76e88a0d4,
		Nodes: []uint64{
			0x9772ae3f5bece367,
			0xc35b8a4838998a1e,
		},
		Compressed: true,
	})
}
